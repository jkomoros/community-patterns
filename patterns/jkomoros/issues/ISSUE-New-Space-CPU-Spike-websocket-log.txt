Data
Length
Time
{"invocation":{"cmd":"/memory/transact","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"changes":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{"application/json":{"ba4jcaonil6wuioyr42chb3yqqagdlylzo5er7g3frd6e2kz5j2uwmmsa":{"is":{"value":{"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U":"OWNER","*":"WRITE"}}}}}}},"iss":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcbuzx7ba6efeng7j7ix4makuoladikqh47itur4f2syup4sw3om4w":{}},"signature":{"/":{"bytes":"MjoW3f2JWyYA/VbO44qui3aTDI2Qo98aq0TitDZk6gCouC+UVvHKcNTkXqdWlpTql7+mjH4bd2bNUOMhZ0sAAw"}}}}	684	
16:19:03.525
{"invocation":{"cmd":"/memory/graph/query","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"selectSchema":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{"application/commit+json":{"_":{"path":[],"schemaContext":{"schema":false,"rootSchema":false}}}},"of:baedreian4rizr7evvwkfaak64oejc6lktp2ctwzqkhves6knkg66unh7fe":{"application/json":{"_":{"path":[],"schemaContext":{"schema":{"type":"object","properties":{"allCharms":{"type":"array","items":{"not":true,"asCell":true}},"recentCharms":{"type":"array","items":{"not":true,"asCell":true}},"defaultPattern":{"not":true,"asCell":true}}},"rootSchema":{"type":"object","properties":{"allCharms":{"type":"array","items":{"not":true,"asCell":true}},"recentCharms":{"type":"array","items":{"not":true,"asCell":true}},"defaultPattern":{"not":true,"asCell":true}}}}}}}},"subscribe":true,"excludeSent":true},"iss":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcasw7wsiprhptaco7bu5tcnqtcm5ngiqs4pa7x4xb5tqx6jgur56e":{}},"signature":{"/":{"bytes":"kop/InBnU2I45u6fW06dZ7HT+n4CnsmBa/I5fCeKLUDc8lSR6LPirP8X2asYau3uS3pnzoijXY+65Pdhu2v8Dg"}}}}	1205	
16:19:03.525
{"invocation":{"cmd":"/memory/graph/query","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"selectSchema":{"of:baedreiahv63wxwgaem4hzjkizl4qncfgvca7pj5cvdon7cukumfon3ioye":{"application/json":{"_":{"path":[],"schemaContext":{"schema":{"type":"array","items":{"not":true,"asCell":true},"ifc":{"classification":["secret"]}},"rootSchema":{"type":"array","items":{"not":true,"asCell":true},"ifc":{"classification":["secret"]}}}}}}},"subscribe":true,"excludeSent":true,"classification":["secret"]},"iss":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcabytrt73eediw4kk6vkdg4byu62f6yduq7rsqjsf4ityn35jjfau":{}},"signature":{"/":{"bytes":"b2yOlitvuwLGqRJjBxLUsCttcHGgQoPSk+1BvXjcyGbH+M7VpBjqx+YMWjLT49+4aO4Xs6VDGI1RFN8EOKUzCA"}}}}	836	
16:19:03.525
{"invocation":{"cmd":"/memory/graph/query","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"selectSchema":{"of:baedreihxpwcmhvzpf5weuf4ceow4zbahqikvu5ploox36ipeuvqnminyba":{"application/json":{"_":{"path":[],"schemaContext":{"schema":{"type":"array","items":{"not":true,"asCell":true},"ifc":{"classification":["secret"]}},"rootSchema":{"type":"array","items":{"not":true,"asCell":true},"ifc":{"classification":["secret"]}}}}}}},"subscribe":true,"excludeSent":true,"classification":["secret"]},"iss":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcax3v24akgyzaxwlq57zxbvdamzk5rwanxx3iqemi3mzchsomdq37":{}},"signature":{"/":{"bytes":"xndwjNV177aCfX5DQJkzwgFerj7SZp31NHo4H4O2v3oXChdlrRPIS4yg3gnXc27YQj1u7OV01HGy2qz8N1E5BA"}}}}	836	
16:19:03.525
{"invocation":{"cmd":"/memory/graph/query","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"selectSchema":{"of:baedreian4rizr7evvwkfaak64oejc6lktp2ctwzqkhves6knkg66unh7fe":{"application/json":{"_":{"path":["recentCharms"],"schemaContext":{"schema":{"type":"array","items":{"not":true,"asCell":true},"ifc":{"classification":["secret"]}},"rootSchema":{"type":"array","items":{"not":true,"asCell":true},"ifc":{"classification":["secret"]}}}}}}},"subscribe":true,"excludeSent":true,"classification":["secret"]},"iss":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcbudxr4oysb5igejed26be5b37xstyzrrhammjys3ylzktic2phff":{}},"signature":{"/":{"bytes":"9XIaACU62DYn6DT9UFOUg7dl2mZKfiHvx5q4HbEroNxeDGeJnL8mTmESMe4bfs1em5Ptsn/tziB9MHXcTNPxDw"}}}}	850	
16:19:03.525
{"the":"task/return","of":"job:ba4jcbuzx7ba6efeng7j7ix4makuoladikqh47itur4f2syup4sw3om4w","is":{"error":{"name":"ConflictError","stack":"ConflictError: The application/json of did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs in did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs already exists as ba4jcbds3artabbhb2265tu6uf6m6n7skxiq7xa6u4st5ea23ao3bqapr\n at Module.conflict (file:///Users/alex/Code/labs/packages/memory/error.ts:25:29)\n at swap (file:///Users/alex/Code/labs/packages/memory/space.ts:765:19)\n at commit (file:///Users/alex/Code/labs/packages/memory/space.ts:801:5)\n at sqliteTransaction (https://jsr.io/@db/sqlite/0.12.0/src/database.ts:874:28)\n at execute (file:///Users/alex/Code/labs/packages/memory/space.ts:838:11)\n at file:///Users/alex/Code/labs/packages/memory/space.ts:865:12\n at traceSync (file:///Users/alex/Code/labs/packages/memory/telemetry.ts:69:20)\n at transact (file:///Users/alex/Code/labs/packages/memory/space.ts:856:10)\n at file:///Users/alex/Code/labs/packages/memory/space.ts:219:14\n at traceSync (file:///Users/alex/Code/labs/packages/memory/telemetry.ts:69:20)\n at Space.transact (file:///Users/alex/Code/labs/packages/memory/space.ts:213:12)\n at file:///Users/alex/Code/labs/packages/memory/memory.ts:189:26\n at eventLoopTick (ext:core/01_core.js:179:7)\n at async file:///Users/alex/Code/labs/packages/memory/telemetry.ts:127:22\n at async transact (file:///Users/alex/Code/labs/packages/memory/memory.ts:172:10)\n at async file:///Users/alex/Code/labs/packages/memory/memory.ts:75:7\n at async file:///Users/alex/Code/labs/packages/memory/telemetry.ts:127:22\n at async Memory.perform (file:///Users/alex/Code/labs/packages/memory/memory.ts:72:12)\n at async MemoryProviderSession.invoke (file:///Users/alex/Code/labs/packages/memory/provider.ts:353:24)\n at async Object.write (file:///Users/alex/Code/labs/packages/memory/provider.ts:201:11)","message":"The application/json of did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs in did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs already exists as ba4jcbds3artabbhb2265tu6uf6m6n7skxiq7xa6u4st5ea23ao3bqapr","conflict":{"space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","the":"application/json","of":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","expected":null,"actual":{"the":"application/json","of":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","cause":{"/":"baedreibzvbp22rb3chtii4hpccaaynpbpf3ush43mwepytjlhvhkszrsia"},"since":0,"is":{"value":{"did:key:z6MkfWSm6rNG2ho2RquZXXiT3MbpzJYeW8cThGrHzZ1JfN9j":"OWNER","*":"WRITE"}}},"existsInHistory":false,"history":[]},"transaction":{"cmd":"/memory/transact","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"changes":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{"application/json":{"ba4jcaonil6wuioyr42chb3yqqagdlylzo5er7g3frd6e2kz5j2uwmmsa":{"is":{"value":{"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U":"OWNER","*":"WRITE"}}}}}}},"iss":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","prf":[],"iat":1764721140,"exp":1764724740}}}}	3187	
16:19:03.571
{"invocation":{"cmd":"/memory/graph/query","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"selectSchema":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{"application/commit+json":{"_":{"path":[],"schemaContext":{"schema":false,"rootSchema":false}}}}}},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcbi4qfby2bh5ip2nyvacs2wmdbi24us6ih25ym4grbl6zqfuskn2r":{}},"signature":{"/":{"bytes":"QBo/76ZFWRVqIVaVCH5JzaXnblq9+w1H6iW+EGqGd34HuDiARaRhzviKvY1N5zA9yurxonwIa3H1/Ka0J9uSDQ"}}}}	609	
16:19:03.572
{"invocation":{"cmd":"/memory/query/subscribe","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"selectSchema":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{"application/commit+json":{"_":{"path":[],"schemaContext":{"schema":false,"rootSchema":false}}}}}},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcby4qeu3vpdvsxa34zgu3vbicuiyqdgxwjuqosuhvsxxlon6lu3cp":{}},"signature":{"/":{"bytes":"6nPORq0cEi6QcVAJcw5NJG4KpuvhZ6kckeogyp963ejyixfzrU0XjzOYUOPApKxym9U3hijf7j5H3cGtIPyZBA"}}}}	613	
16:19:03.572
{"the":"task/return","of":"job:ba4jcasw7wsiprhptaco7bu5tcnqtcm5ngiqs4pa7x4xb5tqx6jgur56e","is":{"ok":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{"application/commit+json":{"ba4jca5amxpu6u6i76k2ctgbaydexgmnytoocctebavhcyxbcq7f7llsj":{"is":{"since":19,"transaction":{"cmd":"/memory/transact","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"changes":{"of:baedreib5xelnzvlbfg7li7bjxolzbo7xdcgcq6z5x5ov2hv5w3oc3bltoi":{"application/json":{"ba4jcablmor4ihcmohi32v2ewuuhjm3736q4zqsqrozoxzjcpnu2pjsm6":{"is":{"value":{"$TYPE":"ba4jcak2rajxfkioarmzmjq72avbhbmau74bs7yt5mmzm7fjyfnaoqey2","resultRef":{"/":{"link@1":{"path":[],"id":"of:baedreihmd2h2to24aze6v5xh44dceawamjsha3xnfd2rmwhd7lkhgpv6cm","schema":{"type":"object","properties":{"preferences":{"type":"array","items":{"$ref":"#/$defs/IngredientPreference"}},"history":{"type":"array","items":{"$ref":"#/$defs/HistoricalPizza"}}},"required":["preferences","history"],"$defs":{"HistoricalPizza":{"type":"object","properties":{"date":{"type":"string"},"description":{"type":"string"},"ingredients":{"type":"array","items":{"$ref":"#/$defs/Ingredient"}},"ate":{"enum":["yes","no","unknown"]}},"required":["date","description","ingredients","ate"]},"Ingredient":{"type":"object","properties":{"raw":{"type":"string"},"normalized":{"type":"string"}},"required":["raw","normalized"]},"IngredientPreference":{"type":"object","properties":{"ingredient":{"type":"string"},"status":{"enum":["liked","disliked"]}},"required":["ingredient","status"]}}},"rootSchema":{"type":"object","properties":{"preferences":{"type":"array","items":{"$ref":"#/$defs/IngredientPreference"}},"history":{"type":"array","items":{"$ref":"#/$defs/HistoricalPizza"}}},"required":["preferences","history"],"$defs":{"HistoricalPizza":{"type":"object","properties":{"date":{"type":"string"},"description":{"type":"string"},"ingredients":{"type":"array","items":{"$ref":"#/$defs/Ingredient"}},"ate":{"enum":["yes","no","unknown"]}},"required":["date","description","ingredients","ate"]},"Ingredient":{"type":"object","properties":{"raw":{"type":"string"},"normalized":{"type":"string"}},"required":["raw","normalized"]},"IngredientPreference":{"type":"object","properties":{"ingredient":{"type":"string"},"status":{"enum":["liked","disliked"]}},"required":["ingredient","status"]}}}}}},"internal":{"__#7":[],"__#0":[],"__#5":{"pending":{"/":{"link@1":{"path":[],"id":"of:baedreihuqlhnw34i3xyotub4nvisxff25eidsvyuvwzy6i6gioaoifp2mi","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},"result":{"/":{"link@1":{"path":[],"id":"of:baedreiez7mjibnqvv745qjuxyibzefevlteafnlx5j7pysf54non7dx7mu","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},"error":{"/":{"link@1":{"path":[],"id":"of:baedreifv664ykjvyiqpn326hmke6dm3osrartux3gdbeqsccbpy4h6ispq","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}}},"__#11":0,"__#12":{"type":"vnode","name":"p","props":{"style":{"color":"#666","fontStyle":"italic"}},"children":["No pizzas in history yet. Click \"Add to History\" on current pizzas to track them."]},"__#10":{"/":{"link@1":{"path":[],"id":"of:baedreib7mdzzebocxe5h3pjayntkxf5zfip2cfzwjr6jlloh3t5etigdfi","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},"__#8":true,"__#1":{"/":{"link@1":{"path":[],"id":"of:baedreigubw7xfxxygh4zwo3mtasbrqypm6yvxkcyhlm6zxts4vupbbx3tm","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},"__#2":true,"__#4":[],"__#6":{"/":{"link@1":{"path":[],"id":"of:baedreidonhae774sv2d7k6t7dqu2w56erwl47sd25vts4x7gs5vtrwdqme","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},"__#9":{"/":{"link@1":{"path":[],"id":"of:baedreihbsk4kw35jm2eths7jtbncfdm7zcls3fozark6tz7lc5r6h6icdu","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},"__#3":{"/":{"link@1":{"path":[],"id":"of:baedreifx6s4vunklrp22gnzycsidblug272ff3sdwf3rpjaqvvsqkuw73q","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},"__#13":{"/":{"link@1":{"path":[],"id":"of:baedreieh73aoa3qwbsaezavb3v3qbhdoocw52bdtah4uhhmoj6d7cbiuvi","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}}},"spell":{"/":{"link@1":{"id":"of:baedreiayharv25uhqmsvtrudly553kjg7in63irshyndhq2vqabuj4qtsm"}}},"argument":{"preferences":[],"history":[]}}}}}},"of:baedreieh73aoa3qwbsaezavb3v3qbhdoocw52bdtah4uhhmoj6d7cbiuvi":{"application/json":{"ba4jcacb3i3wa5ut5brxw6lmcb3s5x73y65snoqebjeqnull4wqikuni7":{"is":{"value":[],"source":{"/":"baedreib5xelnzvlbfg7li7bjxolzbo7xdcgcq6z5x5ov2hv5w3oc3bltoi"}}}}}}},"iss":"did:key:z6MkfWSm6rNG2ho2RquZXXiT3MbpzJYeW8cThGrHzZ1JfN9j","prf":[],"iat":1764721130,"exp":1764724730}},"since":19}}},"of:baedreian4rizr7evvwkfaak64oejc6lktp2ctwzqkhves6knkg66unh7fe":{"application/json":{"ba4jcb67yw7lpyfo4k7273qqbkc7tpaopxasqzlgbes4kx2556pfyv3ss":{"is":{"value":{"allCharms":{"/":{"link@1":{"path":[],"id":"of:baedreiahv63wxwgaem4hzjkizl4qncfgvca7pj5cvdon7cukumfon3ioye","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}}}},"since":1}}},"of:baedreiahv63wxwgaem4hzjkizl4qncfgvca7pj5cvdon7cukumfon3ioye":{"application/json":{"ba4jcbjcyx7h7igdxukglsaqhsjv4cit4jrhwse4bq3dcvuevzux2xwyp":{"is":{"value":[{"/":{"link@1":{"path":[],"id":"of:baedreihmd2h2to24aze6v5xh44dceawamjsha3xnfd2rmwhd7lkhgpv6cm","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}}]},"since":4}}},"of:baedreihmd2h2to24aze6v5xh44dceawamjsha3xnfd2rmwhd7lkhgpv6cm":{"application/json":{"ba4jcb5hlurgxlg7h6rj4okikl5re7e5otpphmlzwu3xa24q54dka7kam":{"is":{"source":{"/":"baedreib5xelnzvlbfg7li7bjxolzbo7xdcgcq6z5x5ov2hv5w3oc3bltoi"},"value":{"$NAME":"Cheeseboard Pizza Schedule","$UI":{"type":"vnode","name":"div","props":{"style":{"padding":"1rem","maxWidth":"800px","fontFamily":"system-ui, sans-serif"}},"children":[{"type":"vnode","name":"h2","props":{},"children":["Cheeseboard Pizza Schedule"]},{"type":"vnode","name":"p","props":{},"children":[{"type":"vnode","name":"a","props":{"href":"https://cheeseboardcollective.coop/home/pizza/pizza-schedule/","target":"_blank","rel":"noopener noreferrer","style":{"color":"#007bff"}},"children":["View source website"]}]},{"type":"vnode","name":"div","props":{"style":{"marginTop":"1.5rem"}},"children":[{"$alias":{"path":["internal","__#6"],"cell":{"/":"baedreib5xelnzvlbfg7li7bjxolzbo7xdcgcq6z5x5ov2hv5w3oc3bltoi"}}},{"$alias":{"path":["internal","__#13"],"cell":{"/":"baedreib5xelnzvlbfg7li7bjxolzbo7xdcgcq6z5x5ov2hv5w3oc3bltoi"}}}]},{"type":"vnode","name":"div","props":{"style":{"marginTop":"2rem","padding":"1rem","border":"1px solid #ddd","borderRadius":"8px","backgroundColor":"#f9f9f9"}},"children":[{"type":"vnode","name":"h3","props":{"style":{"margin":"0 0 1rem 0"}},"children":["Your Preferences"]},{"type":"vnode","name":"div","props":{"style":{"marginBottom":"1rem"}},"children":[{"type":"vnode","name":"strong","props":{"style":{"display":"block","marginBottom":"0.5rem","color":"#155724"}},"children":["Liked:"]},{"type":"vnode","name":"div","props":{"style":{"display":"flex","flexWrap":"wrap","gap":"0.5rem"}},"children":[{"$alias":{"path":["internal","__#10"],"cell":{"/":"baedreib5xelnzvlbfg7li7bjxolzbo7xdcgcq6z5x5ov2hv5w3oc3bltoi"}}},{"$alias":{"path":["internal","__#9"],"cell":{"/":"baedreib5xelnzvlbfg7li7bjxolzbo7xdcgcq6z5x5ov2hv5w3oc3bltoi"}}}]}]},{"type":"vnode","name":"div","props":{},"children":[{"type":"vnode","name":"strong","props":{"style":{"display":"block","marginBottom":"0.5rem","color":"#721c24"}},"children":["Disliked:"]},{"type":"vnode","name":"div","props":{"style":{"display":"flex","flexWrap":"wrap","gap":"0.5rem"}},"children":[{"$alias":{"path":["internal","__#1"],"cell":{"/":"baedreib5xelnzvlbfg7li7bjxolzbo7xdcgcq6z5x5ov2hv5w3oc3bltoi"}}},{"$alias":{"path":["internal","__#3"],"cell":{"/":"baedreib5xelnzvlbfg7li7bjxolzbo7xdcgcq6z5x5ov2hv5w3oc3bltoi"}}}]}]}]},{"type":"vnode","name":"details","props":{"style":{"marginTop":"2rem","padding":"1rem","border":"1px solid #ddd","borderRadius":"8px","backgroundColor":"#f9f9f9"}},"children":[{"type":"vnode","name":"summary","props":{"style":{"cursor":"pointer","fontWeight":"600","fontSize":"1.1rem"}},"children":["Pizza History (",{"$alias":{"path":["internal","__#11"],"cell":{"/":"baedreib5xelnzvlbfg7li7bjxolzbo7xdcgcq6z5x5ov2hv5w3oc3bltoi"}}}," pizzas)"]},{"type":"vnode","name":"div","props":{"style":{"marginTop":"1rem"}},"children":[{"$alias":{"path":["internal","__#12"],"cell":{"/":"baedreib5xelnzvlbfg7li7bjxolzbo7xdcgcq6z5x5ov2hv5w3oc3bltoi"}}}]}]}]},"preferences":{"$alias":{"path":["argument","preferences"],"schema":{"type":"array","items":{"$ref":"#/$defs/IngredientPreference"},"default":[]},"rootSchema":{"type":"object","properties":{"preferences":{"type":"array","items":{"$ref":"#/$defs/IngredientPreference"},"default":[]},"history":{"type":"array","items":{"$ref":"#/$defs/HistoricalPizza"},"default":[]}},"required":["preferences","history"],"$defs":{"HistoricalPizza":{"type":"object","properties":{"date":{"type":"string"},"description":{"type":"string"},"ingredients":{"type":"array","items":{"$ref":"#/$defs/Ingredient"}},"ate":{"enum":["yes","no","unknown"]}},"required":["date","description","ingredients","ate"]},"Ingredient":{"type":"object","properties":{"raw":{"type":"string"},"normalized":{"type":"string"}},"required":["raw","normalized"]},"IngredientPreference":{"type":"object","properties":{"ingredient":{"type":"string"},"status":{"enum":["liked","disliked"]}},"required":["ingredient","status"]}}},"cell":{"/":"baedreib5xelnzvlbfg7li7bjxolzbo7xdcgcq6z5x5ov2hv5w3oc3bltoi"}}},"history":{"$alias":{"path":["argument","history"],"schema":{"type":"array","items":{"$ref":"#/$defs/HistoricalPizza"},"default":[]},"rootSchema":{"type":"object","properties":{"preferences":{"type":"array","items":{"$ref":"#/$defs/IngredientPreference"},"default":[]},"history":{"type":"array","items":{"$ref":"#/$defs/HistoricalPizza"},"default":[]}},"required":["preferences","history"],"$defs":{"HistoricalPizza":{"type":"object","properties":{"date":{"type":"string"},"description":{"type":"string"},"ingredients":{"type":"array","items":{"$ref":"#/$defs/Ingredient"}},"ate":{"enum":["yes","no","unknown"]}},"required":["date","description","ingredients","ate"]},"Ingredient":{"type":"object","properties":{"raw":{"type":"string"},"normalized":{"type":"string"}},"required":["raw","normalized"]},"IngredientPreference":{"type":"object","properties":{"ingredient":{"type":"string"},"status":{"enum":["liked","disliked"]}},"required":["ingredient","status"]}}},"cell":{"/":"baedreib5xelnzvlbfg7li7bjxolzbo7xdcgcq6z5x5ov2hv5w3oc3bltoi"}}}}},"since":3}}},"of:baedreib5xelnzvlbfg7li7bjxolzbo7xdcgcq6z5x5ov2hv5w3oc3bltoi":{"application/json":{"ba4jcablmor4ihcmohi32v2ewuuhjm3736q4zqsqrozoxzjcpnu2pjsm6":{"is":{"value":{"$TYPE":"ba4jcak2rajxfkioarmzmjq72avbhbmau74bs7yt5mmzm7fjyfnaoqey2","resultRef":{"/":{"link@1":{"path":[],"id":"of:baedreihmd2h2to24aze6v5xh44dceawamjsha3xnfd2rmwhd7lkhgpv6cm","schema":{"type":"object","properties":{"preferences":{"type":"array","items":{"$ref":"#/$defs/IngredientPreference"}},"history":{"type":"array","items":{"$ref":"#/$defs/HistoricalPizza"}}},"required":["preferences","history"],"$defs":{"HistoricalPizza":{"type":"object","properties":{"date":{"type":"string"},"description":{"type":"string"},"ingredients":{"type":"array","items":{"$ref":"#/$defs/Ingredient"}},"ate":{"enum":["yes","no","unknown"]}},"required":["date","description","ingredients","ate"]},"Ingredient":{"type":"object","properties":{"raw":{"type":"string"},"normalized":{"type":"string"}},"required":["raw","normalized"]},"IngredientPreference":{"type":"object","properties":{"ingredient":{"type":"string"},"status":{"enum":["liked","disliked"]}},"required":["ingredient","status"]}}},"rootSchema":{"type":"object","properties":{"preferences":{"type":"array","items":{"$ref":"#/$defs/IngredientPreference"}},"history":{"type":"array","items":{"$ref":"#/$defs/HistoricalPizza"}}},"required":["preferences","history"],"$defs":{"HistoricalPizza":{"type":"object","properties":{"date":{"type":"string"},"description":{"type":"string"},"ingredients":{"type":"array","items":{"$ref":"#/$defs/Ingredient"}},"ate":{"enum":["yes","no","unknown"]}},"required":["date","description","ingredients","ate"]},"Ingredient":{"type":"object","properties":{"raw":{"type":"string"},"normalized":{"type":"string"}},"required":["raw","normalized"]},"IngredientPreference":{"type":"object","properties":{"ingredient":{"type":"string"},"status":{"enum":["liked","disliked"]}},"required":["ingredient","status"]}}}}}},"internal":{"__#7":[],"__#0":[],"__#5":{"pending":{"/":{"link@1":{"path":[],"id":"of:baedreihuqlhnw34i3xyotub4nvisxff25eidsvyuvwzy6i6gioaoifp2mi","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},"result":{"/":{"link@1":{"path":[],"id":"of:baedreiez7mjibnqvv745qjuxyibzefevlteafnlx5j7pysf54non7dx7mu","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},"error":{"/":{"link@1":{"path":[],"id":"of:baedreifv664ykjvyiqpn326hmke6dm3osrartux3gdbeqsccbpy4h6ispq","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}}},"__#11":0,"__#12":{"type":"vnode","name":"p","props":{"style":{"color":"#666","fontStyle":"italic"}},"children":["No pizzas in history yet. Click \"Add to History\" on current pizzas to track them."]},"__#10":{"/":{"link@1":{"path":[],"id":"of:baedreib7mdzzebocxe5h3pjayntkxf5zfip2cfzwjr6jlloh3t5etigdfi","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},"__#8":true,"__#1":{"/":{"link@1":{"path":[],"id":"of:baedreigubw7xfxxygh4zwo3mtasbrqypm6yvxkcyhlm6zxts4vupbbx3tm","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},"__#2":true,"__#4":[],"__#6":{"/":{"link@1":{"path":[],"id":"of:baedreidonhae774sv2d7k6t7dqu2w56erwl47sd25vts4x7gs5vtrwdqme","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},"__#9":{"/":{"link@1":{"path":[],"id":"of:baedreihbsk4kw35jm2eths7jtbncfdm7zcls3fozark6tz7lc5r6h6icdu","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},"__#3":{"/":{"link@1":{"path":[],"id":"of:baedreifx6s4vunklrp22gnzycsidblug272ff3sdwf3rpjaqvvsqkuw73q","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},"__#13":{"/":{"link@1":{"path":[],"id":"of:baedreieh73aoa3qwbsaezavb3v3qbhdoocw52bdtah4uhhmoj6d7cbiuvi","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}}},"spell":{"/":{"link@1":{"id":"of:baedreiayharv25uhqmsvtrudly553kjg7in63irshyndhq2vqabuj4qtsm"}}},"argument":{"preferences":[],"history":[]}}},"since":19}}},"of:baedreiayharv25uhqmsvtrudly553kjg7in63irshyndhq2vqabuj4qtsm":{"application/json":{"ba4jcbrmzjcxlshorhnaidh74ajxmj5cboeyf42k4k45sursigr7xprtj":{"is":{"value":{"id":"ba4jcak2rajxfkioarmzmjq72avbhbmau74bs7yt5mmzm7fjyfnaoqey2","program":{"main":"/cheeseboard-schedule.tsx","files":[{"/":{"link@1":{"path":[],"id":"of:baedreiedbyvjbejgv3hdeps3t2o5lv5x5dkgknj33uoka2edcwshyn7ltm"}}}]},"spec":"recipe"}},"since":2}}}}}}}	15033	
16:19:03.572
{"invocation":{"cmd":"/memory/graph/query","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"selectSchema":{"of:baedreiahv63wxwgaem4hzjkizl4qncfgvca7pj5cvdon7cukumfon3ioye":{"application/json":{"_":{"path":[],"schemaContext":{"schema":{"type":"array","items":{"not":true,"asCell":true}},"rootSchema":{"type":"array","items":{"not":true,"asCell":true}}}}}}},"subscribe":true,"excludeSent":true},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcbbmhxzw2fhoht2xvyv7smwx3ltla7wt6im3osyvlyzktajwwtqv5":{}},"signature":{"/":{"bytes":"UnZ3lYu9Jr0Rly6+2VX6KbA7YUZuaCTRaBh2jdG2Wjy0k5mRpu9wVUkbjZN8kzpjutS2H9Qm7l6Enz0+5+PsBg"}}}}	736	
16:19:03.580
{"the":"task/return","of":"job:ba4jcabytrt73eediw4kk6vkdg4byu62f6yduq7rsqjsf4ityn35jjfau","is":{"ok":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{}}}}	166	
16:19:03.580
{"the":"task/return","of":"job:ba4jcax3v24akgyzaxwlq57zxbvdamzk5rwanxx3iqemi3mzchsomdq37","is":{"ok":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{}}}}	166	
16:19:03.580
{"the":"task/return","of":"job:ba4jcbudxr4oysb5igejed26be5b37xstyzrrhammjys3ylzktic2phff","is":{"ok":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{}}}}	166	
16:19:03.580
{"the":"task/return","of":"job:ba4jcbi4qfby2bh5ip2nyvacs2wmdbi24us6ih25ym4grbl6zqfuskn2r","is":{"ok":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{"application/commit+json":{"ba4jca5amxpu6u6i76k2ctgbaydexgmnytoocctebavhcyxbcq7f7llsj":{"is":{"since":19,"transaction":{"cmd":"/memory/transact","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"changes":{"of:baedreib5xelnzvlbfg7li7bjxolzbo7xdcgcq6z5x5ov2hv5w3oc3bltoi":{"application/json":{"ba4jcablmor4ihcmohi32v2ewuuhjm3736q4zqsqrozoxzjcpnu2pjsm6":{"is":{"value":{"$TYPE":"ba4jcak2rajxfkioarmzmjq72avbhbmau74bs7yt5mmzm7fjyfnaoqey2","resultRef":{"/":{"link@1":{"path":[],"id":"of:baedreihmd2h2to24aze6v5xh44dceawamjsha3xnfd2rmwhd7lkhgpv6cm","schema":{"type":"object","properties":{"preferences":{"type":"array","items":{"$ref":"#/$defs/IngredientPreference"}},"history":{"type":"array","items":{"$ref":"#/$defs/HistoricalPizza"}}},"required":["preferences","history"],"$defs":{"HistoricalPizza":{"type":"object","properties":{"date":{"type":"string"},"description":{"type":"string"},"ingredients":{"type":"array","items":{"$ref":"#/$defs/Ingredient"}},"ate":{"enum":["yes","no","unknown"]}},"required":["date","description","ingredients","ate"]},"Ingredient":{"type":"object","properties":{"raw":{"type":"string"},"normalized":{"type":"string"}},"required":["raw","normalized"]},"IngredientPreference":{"type":"object","properties":{"ingredient":{"type":"string"},"status":{"enum":["liked","disliked"]}},"required":["ingredient","status"]}}},"rootSchema":{"type":"object","properties":{"preferences":{"type":"array","items":{"$ref":"#/$defs/IngredientPreference"}},"history":{"type":"array","items":{"$ref":"#/$defs/HistoricalPizza"}}},"required":["preferences","history"],"$defs":{"HistoricalPizza":{"type":"object","properties":{"date":{"type":"string"},"description":{"type":"string"},"ingredients":{"type":"array","items":{"$ref":"#/$defs/Ingredient"}},"ate":{"enum":["yes","no","unknown"]}},"required":["date","description","ingredients","ate"]},"Ingredient":{"type":"object","properties":{"raw":{"type":"string"},"normalized":{"type":"string"}},"required":["raw","normalized"]},"IngredientPreference":{"type":"object","properties":{"ingredient":{"type":"string"},"status":{"enum":["liked","disliked"]}},"required":["ingredient","status"]}}}}}},"internal":{"__#7":[],"__#0":[],"__#5":{"pending":{"/":{"link@1":{"path":[],"id":"of:baedreihuqlhnw34i3xyotub4nvisxff25eidsvyuvwzy6i6gioaoifp2mi","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},"result":{"/":{"link@1":{"path":[],"id":"of:baedreiez7mjibnqvv745qjuxyibzefevlteafnlx5j7pysf54non7dx7mu","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},"error":{"/":{"link@1":{"path":[],"id":"of:baedreifv664ykjvyiqpn326hmke6dm3osrartux3gdbeqsccbpy4h6ispq","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}}},"__#11":0,"__#12":{"type":"vnode","name":"p","props":{"style":{"color":"#666","fontStyle":"italic"}},"children":["No pizzas in history yet. Click \"Add to History\" on current pizzas to track them."]},"__#10":{"/":{"link@1":{"path":[],"id":"of:baedreib7mdzzebocxe5h3pjayntkxf5zfip2cfzwjr6jlloh3t5etigdfi","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},"__#8":true,"__#1":{"/":{"link@1":{"path":[],"id":"of:baedreigubw7xfxxygh4zwo3mtasbrqypm6yvxkcyhlm6zxts4vupbbx3tm","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},"__#2":true,"__#4":[],"__#6":{"/":{"link@1":{"path":[],"id":"of:baedreidonhae774sv2d7k6t7dqu2w56erwl47sd25vts4x7gs5vtrwdqme","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},"__#9":{"/":{"link@1":{"path":[],"id":"of:baedreihbsk4kw35jm2eths7jtbncfdm7zcls3fozark6tz7lc5r6h6icdu","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},"__#3":{"/":{"link@1":{"path":[],"id":"of:baedreifx6s4vunklrp22gnzycsidblug272ff3sdwf3rpjaqvvsqkuw73q","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},"__#13":{"/":{"link@1":{"path":[],"id":"of:baedreieh73aoa3qwbsaezavb3v3qbhdoocw52bdtah4uhhmoj6d7cbiuvi","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}}},"spell":{"/":{"link@1":{"id":"of:baedreiayharv25uhqmsvtrudly553kjg7in63irshyndhq2vqabuj4qtsm"}}},"argument":{"preferences":[],"history":[]}}}}}},"of:baedreieh73aoa3qwbsaezavb3v3qbhdoocw52bdtah4uhhmoj6d7cbiuvi":{"application/json":{"ba4jcacb3i3wa5ut5brxw6lmcb3s5x73y65snoqebjeqnull4wqikuni7":{"is":{"value":[],"source":{"/":"baedreib5xelnzvlbfg7li7bjxolzbo7xdcgcq6z5x5ov2hv5w3oc3bltoi"}}}}}}},"iss":"did:key:z6MkfWSm6rNG2ho2RquZXXiT3MbpzJYeW8cThGrHzZ1JfN9j","prf":[],"iat":1764721130,"exp":1764724730}},"since":19}}}}}}}	4759	
16:19:03.611
{"the":"task/return","of":"job:ba4jcbbmhxzw2fhoht2xvyv7smwx3ltla7wt6im3osyvlyzktajwwtqv5","is":{"ok":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{}}}}	166	
16:19:03.612
{"invocation":{"cmd":"/memory/graph/query","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"selectSchema":{"of:baedreihmd2h2to24aze6v5xh44dceawamjsha3xnfd2rmwhd7lkhgpv6cm":{"application/json":{"_":{"path":["$NAME"],"schemaContext":{"schema":false,"rootSchema":false}}}}},"subscribe":true,"excludeSent":true},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcbxjxaeojibgg4vq2n2jadc2rml2kq3aaiwuk26lvxvlrfgrs5qrt":{}},"signature":{"/":{"bytes":"V01JU8ZjqZvJZgwvtluo33Cz0GxXJSM5dYldTDED9pyOMAciBJuxOCP7B5W4fSQNhfQvLXMSBjETFX6tEOdxAA"}}}}	651	
16:19:03.615
{"the":"task/return","of":"job:ba4jcbxjxaeojibgg4vq2n2jadc2rml2kq3aaiwuk26lvxvlrfgrs5qrt","is":{"ok":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{}}}}	166	
16:19:03.663
{"invocation":{"cmd":"/memory/transact","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"changes":{"of:baedreiayeohgxjzmij53y63lgaax5ndolqk5ksdwu6xscel4kx2m2s6c3q":{"application/json":{"ba4jcb3hhqhe4nfpe2r3jcw4pjcg5xj6dshwik532oxtibrg3rlpdpyf6":{"is":{"value":{"id":"ba4jcaodz2xu6wbjq3i54qb4dily77jzm6ofnrimmtbv6lcfgexob2umv","program":{"main":"/default-app.tsx","files":[{"/":{"link@1":{"path":[],"id":"of:baedreibr6gycs6dvh32an73hiiddc54zmousvmu7eknp2k75nj2hprzofy"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiczp2strjgmqqr4y4cdhnfgyxpa2p7jh2clgkahly3d2ctbm52z2i"}}},{"/":{"link@1":{"path":[],"id":"of:baedreibkc7zcxdembp7sxpowfbthuiwev4tyyvciuvwzu7egg6323czmh4"}}},{"/":{"link@1":{"path":[],"id":"of:baedreigmgcvh4yl4bwa5mobdiqln6dtzz62ok6ctgh2gaiijiarqi3utkm"}}},{"/":{"link@1":{"path":[],"id":"of:baedreigo5n6mtjvvxsxkwqnzmvrl6vclp2fam46mx7nzykshmgyjtyivgu"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiam356b7666ueqii5minnknx2nes4rblkbvqnp7ogzjqoislg65du"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiaconf4zx2gafumhuetpthdpy6ncqtjjnlagr2mjfzrtuygwatzju"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiayx6zri6trvdy7qaw5ljqys5fb64tlzmd6pih5afnpdyqcnhau5y"}}},{"/":{"link@1":{"path":[],"id":"of:baedreigayykp34gmnn2ckdu2zfleo6tyu3qqo46p2fifo44yez3htt227i"}}}]},"spec":"recipe"}}}}},"of:baedreibr6gycs6dvh32an73hiiddc54zmousvmu7eknp2k75nj2hprzofy":{"application/json":{"ba4jcbvpt5rfkhehimagciotvn3bpzzhz3uo5p4gmlr7l4jlydp7ixyuz":{"is":{"value":{"name":"/default-app.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n handler,\n NAME,\n navigateTo,\n recipe,\n str,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chatbot from \"./chatbot.tsx\";\nimport ChatbotOutliner from \"./chatbot-outliner.tsx\";\nimport { default as Note } from \"./note.tsx\";\nimport BacklinksIndex, { type MentionableCharm } from \"./backlinks-index.tsx\";\nimport ChatList from \"./chatbot-list-view.tsx\";\nimport OmniboxFAB from \"./omnibox-fab.tsx\";\n\ntype MinimalCharm = {\n [NAME]?: string;\n};\n\ntype CharmsListInput = void;\n\n// Recipe returns only UI, no data outputs (only symbol properties)\ninterface CharmsListOutput {\n [key: string]: unknown;\n backlinksIndex: {\n mentionable: MentionableCharm[];\n };\n sidebarUI: unknown;\n fabUI: unknown;\n}\n\nconst _visit = handler<\n Record<string, never>,\n { charm: Cell<MinimalCharm> }\n>((_, state) => {\n return navigateTo(state.charm);\n}, { proxy: true });\n\nconst removeCharm = handler<\n Record<string, never>,\n {\n charm: Cell<MinimalCharm>;\n allCharms: Cell<MinimalCharm[]>;\n }\n>((_, state) => {\n const allCharmsValue = state.allCharms.get();\n const index = allCharmsValue.findIndex((c: any) => state.charm.equals(c));\n\n if (index !== -1) {\n const charmListCopy = [...allCharmsValue];\n console.log(\"charmListCopy before\", charmListCopy.length);\n charmListCopy.splice(index, 1);\n console.log(\"charmListCopy after\", charmListCopy.length);\n state.allCharms.set(charmListCopy);\n }\n});\n\nconst toggleFab = handler<any, { fabExpanded: Cell<boolean> }>(\n (_, { fabExpanded }) => {\n fabExpanded.set(!fabExpanded.get());\n },\n);\n\nconst spawnChatList = handler<void, void>((_, __) => {\n return navigateTo(ChatList({\n selectedCharm: { charm: undefined },\n charmsList: [],\n }));\n});\n\nconst spawnChatbot = handler<void, void>((_, __) => {\n return navigateTo(Chatbot({\n messages: [],\n tools: undefined,\n }));\n});\n\nconst spawnChatbotOutliner = handler<void, void>((_, __) => {\n return navigateTo(ChatbotOutliner({\n title: \"Chatbot Outliner\",\n expandChat: false,\n messages: [],\n outline: {\n root: { body: \"\", children: [], attachments: [] },\n },\n }));\n});\n\nconst spawnNote = handler<void, void>((_, __) => {\n return navigateTo(Note({\n title: \"New Note\",\n content: \"\",\n }));\n});\n\nexport default recipe<CharmsListInput, CharmsListOutput>(\n \"DefaultCharmList\",\n (_) => {\n const { allCharms } = wish<{ allCharms: MentionableCharm[] }>(\"/\");\n const index = BacklinksIndex({ allCharms });\n\n const fab = OmniboxFAB({\n mentionable: index.mentionable as unknown as Cell<MentionableCharm[]>,\n });\n\n return {\n backlinksIndex: index,\n [NAME]: str`DefaultCharmList (${allCharms.length})`,\n [UI]: (\n <ct-screen>\n <ct-keybind\n code=\"KeyN\"\n alt\n preventDefault\n onct-keybind={spawnChatList()}\n />\n <ct-keybind\n code=\"KeyO\"\n meta\n preventDefault\n onct-keybind={toggleFab({ fabExpanded: fab.fabExpanded })}\n />\n <ct-keybind\n code=\"KeyO\"\n ctrl\n preventDefault\n onct-keybind={toggleFab({ fabExpanded: fab.fabExpanded })}\n />\n\n <ct-toolbar slot=\"header\" sticky>\n <div slot=\"start\">\n <ct-button\n onClick={spawnChatList()}\n >\n üìÇ Chat List\n </ct-button>\n <ct-button\n onClick={spawnChatbot()}\n >\n üí¨ Chatbot\n </ct-button>\n <ct-button\n onClick={spawnChatbotOutliner()}\n >\n üìù Chatbot Outliner\n </ct-button>\n <ct-button\n onClick={spawnNote()}\n >\n üìÑ Note\n </ct-button>\n </div>\n </ct-toolbar>\n\n <ct-vscroll flex showScrollbar>\n <ct-vstack gap=\"4\" padding=\"6\">\n <style>\n {`\n .pattern-link {\n cursor: pointer;\n color: inherit;\n text-decoration: none;\n }\n .pattern-link:hover {\n text-decoration: underline;\n }\n `}\n </style>\n <h2>Pages</h2>\n\n <ct-table full-width hover>\n <tbody>\n {allCharms.map((charm) => (\n <tr>\n <td>\n <ct-cell-context $cell={charm}>\n <ct-cell-link $cell={charm} />\n </ct-cell-context>\n </td>\n <td>\n <ct-button\n size=\"sm\"\n variant=\"ghost\"\n onClick={removeCharm({ charm, allCharms })}\n >\n üóëÔ∏è\n </ct-button>\n </td>\n </tr>\n ))}\n </tbody>\n </ct-table>\n </ct-vstack>\n </ct-vscroll>\n </ct-screen>\n ),\n sidebarUI: undefined,\n fabUI: fab[UI],\n };\n },\n);\n"}}}}},"of:baedreiczp2strjgmqqr4y4cdhnfgyxpa2p7jh2clgkahly3d2ctbm52z2i":{"application/json":{"ba4jcbt6ddwmeffgpkxsqtfzakrhur22vsc4gzalizp2kegda7jxjgdpm":{"is":{"value":{"name":"/chatbot.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n computed,\n Default,\n fetchData,\n generateObject,\n handler,\n llmDialog,\n NAME,\n pattern,\n patternTool,\n Stream,\n UI,\n VNode,\n wish,\n} from \"commontools\";\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\n\nfunction schemaifyWish<T>(path: string) {\n return wish<T>(path);\n}\n\nconst sendMessage = handler<\n {\n detail: {\n text: string;\n attachments: Array<PromptAttachment>;\n mentions: Array<any>;\n message: string; // Backward compatibility\n };\n },\n {\n addMessage: Stream<BuiltInLLMMessage>;\n }\n>((event, { addMessage }) => {\n const { text } = event.detail;\n\n // Send the message as-is. Any markdown links like [name](/of:...)\n // are just text that the LLM can parse and use with addAttachment() tool.\n addMessage.send({\n role: \"user\",\n content: [{ type: \"text\" as const, text }],\n });\n});\n\nconst clearChat = handler(\n (\n _: never,\n { messages, pending }: {\n messages: Cell<Array<BuiltInLLMMessage>>;\n pending: Cell<boolean | undefined>;\n },\n ) => {\n messages.set([]);\n pending.set(false);\n },\n);\n\ntype ChatInput = {\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n tools?: any;\n theme?: any;\n system?: string;\n};\n\ntype PromptAttachment = {\n id: string;\n name: string;\n type: \"file\" | \"clipboard\" | \"mention\";\n data?: any; // File | Blob | string\n charm?: any;\n removable?: boolean; // Whether this attachment can be removed\n};\n\ntype ChatOutput = {\n messages: Array<BuiltInLLMMessage>;\n pending: boolean | undefined;\n addMessage: Stream<BuiltInLLMMessage>;\n clearChat: Stream<void>;\n cancelGeneration: Stream<void>;\n title?: string;\n pinnedCells: Array<PromptAttachment>;\n tools: any;\n ui: {\n chatLog: VNode;\n promptInput: VNode;\n attachmentsAndTools: VNode;\n };\n};\n\nexport const TitleGenerator = pattern<\n { model?: string; messages: Array<BuiltInLLMMessage> }\n>(({ model, messages }) => {\n const previewMessage = computed(() => {\n if (!messages || messages.length === 0) return \"\";\n\n const firstMessage = messages[0];\n\n if (!firstMessage) return \"\";\n\n return JSON.stringify(firstMessage);\n });\n\n const { result } = generateObject({\n system:\n \"Generate at most a 3-word title based on the following content, respond with NOTHING but the literal title text.\",\n prompt: previewMessage,\n model,\n schema: {\n type: \"object\",\n properties: {\n title: {\n type: \"string\",\n description: \"The title of the chat\",\n },\n },\n required: [\"title\"],\n },\n });\n\n const title = computed(() => {\n return result?.title || \"Untitled Chat\";\n });\n\n return title;\n});\n\nconst listMentionable = pattern<\n { mentionable: Array<MentionableCharm> },\n { result: Array<{ label: string; cell: Cell<unknown> }> }\n>(\n ({ mentionable }) => {\n const result = mentionable.map((charm) => ({\n label: charm[NAME]!,\n cell: charm,\n }));\n return { result };\n },\n);\n\nconst listRecent = pattern<\n { recentCharms: Array<MentionableCharm> },\n { result: Array<{ label: string; cell: Cell<unknown> }> }\n>(\n ({ recentCharms }) => {\n const namesList = recentCharms.map((charm) => ({\n label: charm[NAME]!,\n cell: charm,\n }));\n return { result: namesList };\n },\n);\n\nexport default pattern<ChatInput, ChatOutput>(\n ({ messages, tools, theme, system }) => {\n const model = Cell.of<string>(\"anthropic:claude-sonnet-4-5\");\n const mentionable = schemaifyWish<MentionableCharm[]>(\"#mentionable\");\n const recentCharms = schemaifyWish<MentionableCharm[]>(\"#recent\");\n\n const assistantTools = {\n listMentionable: patternTool(listMentionable, { mentionable }),\n listRecent: patternTool(listRecent, { recentCharms }),\n };\n\n // Merge static and assistant tools\n const mergedTools = computed(() => ({\n ...tools,\n ...assistantTools,\n }));\n\n const latest = computed(() => recentCharms[0]);\n const latestName = computed(() => recentCharms[0]?.[NAME]);\n\n const {\n addMessage,\n cancelGeneration,\n pending,\n flattenedTools,\n pinnedCells,\n } = llmDialog(\n {\n system: computed(() => {\n return system ?? \"You are a polite but efficient assistant.\";\n }),\n messages,\n tools: mergedTools,\n model,\n context: computed(() => ({\n [latestName]: latest,\n })),\n },\n );\n\n const { result } = fetchData({\n url: \"/api/ai/llm/models\",\n mode: \"json\",\n });\n\n const items = computed(() => {\n if (!result) return [];\n const items = Object.keys(result as any).map((key) => ({\n label: key,\n value: key,\n }));\n return items;\n });\n\n const title = TitleGenerator({ model, messages });\n\n const promptInput = (\n <ct-prompt-input\n slot=\"footer\"\n placeholder=\"Ask the LLM a question...\"\n pending={pending}\n $mentionable={mentionable}\n modelItems={items}\n $model={model}\n onct-send={sendMessage({ addMessage })}\n onct-stop={cancelGeneration}\n />\n );\n\n const chatLog = (\n <ct-vscroll\n style=\"padding: 1rem;\"\n flex\n showScrollbar\n fadeEdges\n snapToBottom\n >\n <ct-chat\n theme={theme}\n $messages={messages}\n pending={pending}\n tools={flattenedTools}\n />\n </ct-vscroll>\n );\n\n const attachmentsAndTools = (\n <ct-hstack align=\"center\" gap=\"1\">\n <ct-cell-context $cell={pinnedCells}>\n <ct-attachments-bar pinnedCells={pinnedCells} />\n </ct-cell-context>\n <ct-tools-chip tools={flattenedTools} />\n <ct-button\n variant=\"pill\"\n type=\"button\"\n title=\"Clear chat\"\n onClick={clearChat({\n messages,\n pending,\n })}\n >\n Clear\n </ct-button>\n </ct-hstack>\n );\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <ct-vstack slot=\"header\">\n <ct-heading level={4}>{title}</ct-heading>\n {attachmentsAndTools}\n </ct-vstack>\n\n {chatLog}\n\n {promptInput}\n </ct-screen>\n ),\n messages,\n pending,\n addMessage,\n clearChat: clearChat({\n messages,\n pending,\n }),\n cancelGeneration,\n title,\n pinnedCells,\n tools: flattenedTools,\n ui: {\n chatLog,\n promptInput,\n attachmentsAndTools,\n },\n };\n },\n);\n"}}}}},"of:baedreibkc7zcxdembp7sxpowfbthuiwev4tyyvciuvwzu7egg6323czmh4":{"application/json":{"ba4jcb4arsk7c7axovlb2gztmprwn45blyew2apjcv6lgh6r3oiuqdcnv":{"is":{"value":{"name":"/chatbot-outliner.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n Default,\n derive,\n handler,\n ifElse,\n JSONSchema,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot.tsx\";\nimport { MentionableCharm } from \"./backlinks-index.tsx\";\n\ntype Charm = any;\n\ntype OutlinerNode = {\n body: Default<string, \"\">;\n children: Default<OutlinerNode[], []>;\n attachments: Default<OpaqueRef<any>[], []>;\n};\n\ntype Outliner = {\n root: OutlinerNode;\n};\n\ntype PageResult = {\n outline: Default<\n Outliner,\n { root: { body: \"\"; children: []; attachments: [] } }\n >;\n};\n\nexport type PageInput = {\n outline: Outliner;\n};\n\nconst handleCharmLinkClick = handler<\n {\n detail: {\n charm: Cell<Charm>;\n };\n },\n Record<string, never>\n>(({ detail }, _) => {\n return navigateTo(detail.charm);\n});\n\nfunction getMentionable() {\n return derive<MentionableCharm[], MentionableCharm[]>(\n wish<MentionableCharm[]>(\"#mentionable\"),\n (i) => i,\n );\n}\n\nexport const Page = recipe<PageInput>(\n \"Page\",\n ({ outline }) => {\n const mentionable = getMentionable();\n\n return {\n [NAME]: \"Page\",\n [UI]: (\n <ct-outliner\n $value={outline as any}\n $mentionable={mentionable}\n oncharm-link-click={handleCharmLinkClick({})}\n />\n ),\n outline,\n };\n },\n);\n\ntype LLMTestInput = {\n title?: Cell<Default<string, \"LLM Test\">>;\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n expandChat?: Cell<Default<boolean, false>>;\n outline?: Default<\n Outliner,\n { root: { body: \"Untitled Page\"; children: []; attachments: [] } }\n >;\n};\n\ntype LLMTestResult = {\n messages: Default<Array<BuiltInLLMMessage>, []>;\n};\n\n// put a node at the end of the outline (by appending to root.children)\nconst appendOutlinerNode = handler<\n {\n /** The text content/title of the outliner node to be appended */\n body: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { outline: Cell<Outliner> }\n>(\n (args, state) => {\n try {\n (state.outline.key(\"root\").key(\"children\")).push({\n body: args.body,\n children: [],\n attachments: [],\n });\n\n args.result.set(\n `${state.outline.key(\"root\").key(\"children\").get().length} nodes`,\n );\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nexport default recipe<LLMTestInput, LLMTestResult>(\n \"Outliner\",\n ({ title, expandChat, messages, outline }) => {\n const tools = {\n appendOutlinerNode: {\n description: \"Add a new outliner node.\",\n inputSchema: {\n type: \"object\",\n properties: {\n body: {\n type: \"string\",\n description: \"The title of the new node.\",\n },\n },\n required: [\"body\"],\n } as JSONSchema,\n handler: appendOutlinerNode({ outline }),\n },\n };\n\n const chat = Chat({ messages, tools });\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <ct-hstack justify=\"between\" slot=\"header\">\n <div></div>\n <div>\n <ct-checkbox $checked={expandChat}>Show Chat</ct-checkbox>\n </div>\n </ct-hstack>\n\n <ct-autolayout tabNames={[\"Chat\", \"Tools\"]}>\n <ct-screen>\n <div slot=\"header\">\n <ct-input\n $value={title}\n placeholder=\"Enter title...\"\n />\n </div>\n\n <ct-vscroll flex showScrollbar fadeEdges snapToBottom>\n <ct-vstack data-label=\"Tools\">\n <Page outline={outline} />\n </ct-vstack>\n </ct-vscroll>\n </ct-screen>\n\n {ifElse(\n expandChat,\n chat,\n null,\n )}\n </ct-autolayout>\n </ct-screen>\n ),\n messages,\n };\n },\n);\n"}}}}},"of:baedreigmgcvh4yl4bwa5mobdiqln6dtzz62ok6ctgh2gaiijiarqi3utkm":{"application/json":{"ba4jcbwqf32i3chop2umyg6phmnh6uuwcsqxzucot4vckoq3nyuajjyf5":{"is":{"value":{"name":"/note.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n cell,\n type Default,\n derive,\n generateText,\n handler,\n NAME,\n navigateTo,\n patternTool,\n recipe,\n str,\n Stream,\n UI,\n wish,\n} from \"commontools\";\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\ntype Input = {\n title?: Cell<Default<string, \"Untitled Note\">>;\n content?: Cell<Default<string, \"\">>;\n};\n\n/** Represents a small #note a user took to remember some text. */\ntype Output = {\n mentioned: Default<Array<MentionableCharm>, []>;\n backlinks: MentionableCharm[];\n\n content: Default<string, \"\">;\n grep: Stream<{ query: string }>;\n translate: Stream<{ language: string }>;\n editContent: Stream<{ detail: { value: string } }>;\n};\n\nconst _updateTitle = handler<\n { detail: { value: string } },\n { title: Cell<string> }\n>(\n (event, state) => {\n state.title.set(event.detail?.value ?? \"\");\n },\n);\n\nconst _updateContent = handler<\n { detail: { value: string } },\n { content: Cell<string> }\n>(\n (event, state) => {\n state.content.set(event.detail?.value ?? \"\");\n },\n);\n\nconst handleCharmLinkClick = handler<\n {\n detail: {\n charm: Cell<MentionableCharm>;\n };\n },\n Record<string, never>\n>(({ detail }, _) => {\n return navigateTo(detail.charm);\n});\n\nconst handleNewBacklink = handler<\n {\n detail: {\n text: string;\n charmId: any;\n charm: Cell<MentionableCharm>;\n navigate: boolean;\n };\n },\n {\n mentionable: Cell<MentionableCharm[]>;\n }\n>(({ detail }, { mentionable }) => {\n console.log(\"new charm\", detail.text, detail.charmId);\n\n if (detail.navigate) {\n return navigateTo(detail.charm);\n } else {\n mentionable.push(detail.charm as unknown as MentionableCharm);\n }\n});\n\n/** This edits the content */\nconst handleEditContent = handler<\n { detail: { value: string }; result?: Cell<string> },\n { content: Cell<string> }\n>(\n ({ detail, result }, { content }) => {\n content.set(detail.value);\n result?.set(\"test!\");\n },\n);\n\nconst handleCharmLinkClicked = handler<void, { charm: Cell<MentionableCharm> }>(\n (_, { charm }) => {\n return navigateTo(charm);\n },\n);\n\nfunction schemaifyWish<T>(path: string, def: T) {\n return derive(wish<T>(path) as T, (i) => i ?? def);\n}\n\nconst Note = recipe<Input, Output>(\n \"Note\",\n ({ title, content }) => {\n const mentionable = schemaifyWish<MentionableCharm[]>(\n \"#mentionable\",\n [],\n );\n const mentioned = cell<MentionableCharm[]>([]);\n\n // populated in backlinks-index.tsx\n const backlinks = cell<MentionableCharm[]>([]);\n\n // The only way to serialize a pattern, apparently?\n const pattern = derive(undefined, () => JSON.stringify(Note));\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <div slot=\"header\">\n <ct-input\n $value={title}\n placeholder=\"Enter title...\"\n />\n </div>\n\n <ct-code-editor\n $value={content}\n $mentionable={mentionable}\n $mentioned={mentioned}\n $pattern={pattern}\n onbacklink-click={handleCharmLinkClick({})}\n onbacklink-create={handleNewBacklink({ mentionable })}\n language=\"text/markdown\"\n theme=\"light\"\n wordWrap\n tabIndent\n lineNumbers\n />\n\n <ct-hstack slot=\"footer\">\n {backlinks?.map((charm) => (\n <ct-button\n onClick={handleCharmLinkClicked({ charm })}\n >\n {charm?.[NAME]}\n </ct-button>\n ))}\n </ct-hstack>\n </ct-screen>\n ),\n title,\n content,\n mentioned,\n backlinks,\n grep: patternTool(\n ({ query, content }: { query: string; content: string }) => {\n return derive({ query, content }, ({ query, content }) => {\n return content.split(\"\\n\").filter((c) => c.includes(query));\n });\n },\n { content },\n ),\n translate: patternTool(\n (\n { language, content }: {\n language: string;\n content: string;\n },\n ) => {\n const result = generateText({\n system: str`Translate the content to ${language}.`,\n prompt: str`<to_translate>${content}</to_translate>`,\n });\n\n return derive(result, ({ pending, result }) => {\n if (pending) return undefined;\n if (result == null) return \"Error occured\";\n return result;\n });\n },\n { content },\n ),\n editContent: handleEditContent({ content }),\n };\n },\n);\n\nexport default Note;\n"}}}}},"of:baedreigo5n6mtjvvxsxkwqnzmvrl6vclp2fam46mx7nzykshmgyjtyivgu":{"application/json":{"ba4jcbrirsjwxxl3j76wrhuidg2n25fp4rxs7snvygimxuasbpq2axb7f":{"is":{"value":{"name":"/backlinks-index.tsx","contents":"/// <cts-enable />\nimport { Cell, derive, lift, NAME, OpaqueRef, recipe, UI } from \"commontools\";\n\nexport type MentionableCharm = {\n [NAME]?: string;\n mentioned: MentionableCharm[];\n backlinks: MentionableCharm[];\n};\n\nexport type WriteableBacklinks = {\n mentioned: WriteableBacklinks[];\n backlinks: Cell<WriteableBacklinks[]>;\n};\n\ntype Input = {\n allCharms: MentionableCharm[];\n};\n\ntype Output = {\n mentionable: MentionableCharm[];\n};\n\nconst computeIndex = lift<\n { allCharms: WriteableBacklinks[] },\n void\n>(\n ({ allCharms }) => {\n const cs = allCharms ?? [];\n\n for (const c of cs) {\n c.backlinks?.set([]);\n }\n\n for (const c of cs) {\n const mentions = c.mentioned ?? [];\n for (const m of mentions) {\n m?.backlinks?.push(c);\n }\n }\n },\n);\n\n/**\n * BacklinksIndex builds a map of backlinks across all charms and exposes a\n * unified mentionable list for consumers like editors.\n *\n * Behavior:\n * - Backlinks are computed by scanning each charm's `mentioned` list and\n * mapping mention target -> list of source charms.\n * - Mentionable list is a union of:\n * - every charm in `allCharms`\n * - any items a charm exports via a `mentionable` property\n * (either an array of charms or a Cell of such an array)\n *\n * The backlinks map is keyed by a charm's `content` value (falling back to\n * its `[NAME]`). This mirrors how existing note patterns identify notes when\n * computing backlinks locally.\n */\nconst BacklinksIndex = recipe<Input, Output>(\n \"BacklinksIndex\",\n ({ allCharms }) => {\n computeIndex({\n allCharms: allCharms as unknown as OpaqueRef<WriteableBacklinks[]>,\n });\n\n // Compute mentionable list from allCharms reactively\n const mentionable = derive(allCharms, (charmList) => {\n const cs = charmList ?? [];\n const out: MentionableCharm[] = [];\n for (const c of cs) {\n out.push(c);\n const exported = (c as unknown as {\n mentionable?: MentionableCharm[] | { get?: () => MentionableCharm[] };\n }).mentionable;\n if (Array.isArray(exported)) {\n for (const m of exported) if (m) out.push(m);\n } else if (exported && typeof (exported as any).get === \"function\") {\n const arr = (exported as { get: () => MentionableCharm[] }).get() ??\n [];\n for (const m of arr) if (m) out.push(m);\n }\n }\n return out;\n });\n\n return {\n [NAME]: \"BacklinksIndex\",\n [UI]: undefined,\n mentionable,\n };\n },\n);\n\nexport default BacklinksIndex;\n"}}}}},"of:baedreiam356b7666ueqii5minnknx2nes4rblkbvqnp7ogzjqoislg65du":{"application/json":{"ba4jcbfoua2vmphnb46podjhdafqebq4lcekcmr5qgxyyfzpdbgibof6r":{"is":{"value":{"name":"/chatbot-list-view.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n Default,\n derive,\n handler,\n ID,\n ifElse,\n lift,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n toSchema,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot-note-composed.tsx\";\nimport { ListItem } from \"./common-tools.tsx\";\n\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\ntype CharmEntry = {\n [ID]: string; // randomId is a string\n local_id: string; // same as ID but easier to access\n charm: any;\n};\n\ntype Input = {\n selectedCharm: Default<{ charm: any }, { charm: undefined }>;\n charmsList: Default<CharmEntry[], []>;\n theme?: {\n accentColor: Cell<Default<string, \"#3b82f6\">>;\n fontFace: Cell<Default<string, \"system-ui, -apple-system, sans-serif\">>;\n borderRadius: Cell<Default<string, \"0.5rem\">>;\n };\n};\n\ntype Output = {\n selectedCharm: Default<{ charm: any }, { charm: undefined }>;\n // Expose a mentionable list aggregated from local chat entries\n // Returned as an opaque ref to an array (not a Cell), suitable for\n // upstream aggregators that read exported mentionables.\n mentionable?: MentionableCharm[];\n};\n\nconst removeChat = handler<\n unknown,\n {\n charmsList: Cell<CharmEntry[]>;\n id: string;\n selectedCharm: Cell<Default<{ charm: any }, { charm: undefined }>>;\n }\n>(\n (\n _,\n { charmsList, id, selectedCharm },\n ) => {\n const list = charmsList.get();\n const index = list.findIndex((entry) => entry.local_id === id);\n if (index === -1) return;\n\n const removed = list[index];\n const next = [...list];\n next.splice(index, 1);\n charmsList.set(next);\n\n // If we removed the currently selected charm, choose a new selection.\n const current = selectedCharm.get();\n if (current?.charm === removed.charm) {\n const replacement = next[index] ?? next[index - 1];\n if (replacement) {\n selectedCharm.set({ charm: replacement.charm });\n } else {\n selectedCharm.set({ charm: undefined as unknown as any });\n }\n }\n },\n);\n\n// this will be called whenever charm or selectedCharm changes\n// pass isInitialized to make sure we dont call this each time\n// we change selectedCharm, otherwise creates a loop\nconst storeCharm = lift(\n toSchema<{\n charm: any;\n selectedCharm: Cell<Default<{ charm: any }, { charm: undefined }>>;\n charmsList: Cell<CharmEntry[]>;\n allCharms: Cell<MentionableCharm[]>;\n theme?: {\n accentColor: Default<string, \"#3b82f6\">;\n fontFace: Default<string, \"system-ui, -apple-system, sans-serif\">;\n borderRadius: Default<string, \"0.5rem\">;\n };\n isInitialized: Cell<boolean>;\n }>(),\n undefined,\n ({ charm, selectedCharm, charmsList, isInitialized, allCharms: _ }) => { // Not including `allCharms` is a compile error...\n if (!isInitialized.get()) {\n console.log(\n \"storeCharm storing charm:\",\n charm,\n );\n selectedCharm.set({ charm });\n\n // create the chat charm with a custom name including a random suffix\n const randomId = Math.random().toString(36).substring(2, 10); // Random 8-char string\n charmsList.push({ [ID]: randomId, local_id: randomId, charm });\n\n isInitialized.set(true);\n return charm;\n } else {\n console.log(\"storeCharm: already initialized\");\n }\n return undefined;\n },\n);\n\nconst populateChatList = lift(\n toSchema<{\n charmsList: CharmEntry[];\n allCharms: Cell<any[]>;\n selectedCharm: Cell<{ charm: any }>;\n }>(),\n undefined,\n (\n { charmsList, allCharms, selectedCharm },\n ) => {\n if (charmsList.length === 0) {\n const isInitialized = Cell.of(false);\n return storeCharm({\n charm: Chat({\n title: \"New Chat\",\n messages: [],\n }),\n selectedCharm,\n charmsList,\n allCharms,\n isInitialized: isInitialized as unknown as Cell<boolean>,\n });\n }\n\n return charmsList;\n },\n);\n\nconst createChatRecipe = handler<\n unknown,\n {\n selectedCharm: Cell<{ charm: any }>;\n charmsList: Cell<CharmEntry[]>;\n allCharms: Cell<MentionableCharm[]>;\n }\n>(\n (_, { selectedCharm, charmsList, allCharms }) => {\n const isInitialized = Cell.of(false);\n\n const charm = Chat({\n title: \"New Chat\",\n messages: [],\n });\n // store the charm ref in a cell (pass isInitialized to prevent recursive calls)\n return storeCharm({\n charm,\n selectedCharm,\n charmsList: charmsList as unknown as OpaqueRef<CharmEntry[]>,\n allCharms,\n isInitialized: isInitialized as unknown as Cell<boolean>,\n });\n },\n);\n\nconst selectCharm = handler<\n unknown,\n { selectedCharm: Cell<{ charm: any }>; charm: any }\n>(\n (_, { selectedCharm, charm }) => {\n console.log(\"selectCharm: updating selectedCharm to \", charm);\n selectedCharm.set({ charm });\n return selectedCharm;\n },\n);\n\nconst logCharmsList = lift<\n { charmsList: Cell<CharmEntry[]> },\n Cell<CharmEntry[]>\n>(\n ({ charmsList }) => {\n console.log(\"logCharmsList: \", charmsList.get());\n return charmsList;\n },\n);\n\nconst _handleCharmLinkClicked = handler(\n (_: any, { charm }: { charm: Cell<MentionableCharm> }) => {\n return navigateTo(charm);\n },\n);\n\nconst _merge = lift(\n (\n { allCharms, charmsList }: { allCharms: any[]; charmsList: CharmEntry[] },\n ) => {\n return [...charmsList.map((c) => c.charm), ...allCharms];\n },\n);\n\nconst getSelectedCharm = lift<\n { entry: { charm: any | undefined } },\n {\n chat: unknown;\n list: ListItem[];\n } | undefined\n>(\n ({ entry }) => {\n return entry?.charm;\n },\n);\n\nconst getCharmName = lift(({ charm }: { charm: any }) => {\n return charm?.[NAME] || \"Unknown\";\n});\n\nconst extractLocalMentionable = lift<\n { list: CharmEntry[] },\n MentionableCharm[]\n>(({ list }) => {\n const out: MentionableCharm[] = [];\n for (const entry of list) {\n const c = entry.charm;\n out.push(c.chat);\n }\n return out;\n});\n\n// create the named cell inside the recipe body, so we do it just once\nexport default recipe<Input, Output>(\n \"Launcher\",\n ({ selectedCharm, charmsList, theme }) => {\n const allCharms = derive<MentionableCharm[], MentionableCharm[]>(\n wish<MentionableCharm[]>(\"#allCharms\"),\n (c) => c ?? [],\n );\n logCharmsList({ charmsList: charmsList as unknown as Cell<CharmEntry[]> });\n\n populateChatList({\n selectedCharm: selectedCharm as unknown as Cell<\n Pick<CharmEntry, \"charm\">\n >,\n charmsList,\n allCharms,\n });\n\n const selected = getSelectedCharm({ entry: selectedCharm });\n\n // Aggregate mentionables from the local charms list so that this\n // container exposes its child chat charms as mention targets.\n const localMentionable = extractLocalMentionable({ list: charmsList });\n\n const localTheme = theme ?? {\n accentColor: Cell.of(\"#3b82f6\"),\n fontFace: Cell.of(\"system-ui, -apple-system, sans-serif\"),\n borderRadius: Cell.of(\"0.5rem\"),\n };\n\n return {\n [NAME]: \"Launcher\",\n [UI]: (\n <ct-theme theme={localTheme as any}>\n <ct-screen>\n <div slot=\"header\">\n <ct-toolbar dense sticky>\n <div slot=\"start\">\n <ct-button\n id=\"new-chat-btn\"\n onClick={createChatRecipe({\n selectedCharm,\n charmsList,\n allCharms,\n })}\n >\n Create New Chat\n <ct-kbd>alt+N</ct-kbd>\n </ct-button>\n </div>\n </ct-toolbar>\n\n {/* Keyboard shortcuts */}\n <ct-keybind\n code=\"KeyN\"\n alt\n preventDefault\n onct-keybind={createChatRecipe({\n selectedCharm,\n charmsList,\n allCharms,\n })}\n />\n </div>\n <ct-autolayout\n leftOpen\n rightOpen={false}\n >\n {/* workaround: this seems to correctly start the sub-recipes on a refresh while directly rendering does not */}\n {/* this should be fixed after the builder-refactor (DX1) */}\n <ct-screen>\n <ct-render $cell={selected.chat} />\n </ct-screen>\n\n <aside slot=\"left\">\n <div>\n <ct-heading level={3}>Chat List</ct-heading>\n </div>\n <div role=\"list\">\n {charmsList.map((charmEntry) => (\n <ct-list-item\n onct-activate={selectCharm({\n selectedCharm,\n charm: charmEntry.charm,\n })}\n >\n <span>{getCharmName({ charm: charmEntry.charm })}</span>\n <span slot=\"meta\">{charmEntry.local_id}</span>\n <ct-button\n slot=\"actions\"\n size=\"sm\"\n title=\"Delete Chat\"\n variant=\"destructive\"\n onClick={removeChat({\n charmsList: charmsList as unknown as OpaqueRef<\n CharmEntry[]\n >,\n id: charmEntry.local_id,\n selectedCharm: selectedCharm as unknown as OpaqueRef<\n Default<{ charm: any }, { charm: undefined }>\n >,\n })}\n >\n üóëÔ∏è\n </ct-button>\n </ct-list-item>\n ))}\n </div>\n </aside>\n\n <aside slot=\"right\">\n {ifElse(\n selected,\n <>\n <ct-ct-collapsible>\n <ct-heading slot=\"trigger\" level={5} no-margin>\n List\n </ct-heading>\n <ct-list $value={selected.list} />\n </ct-ct-collapsible>\n </>,\n null,\n )}\n <ct-collapsible>\n <ct-heading slot=\"trigger\" level={5} no-margin>\n Theme\n </ct-heading>\n <ct-vstack style=\"padding: 0.5rem 0; gap: 0.5rem;\">\n <ct-vstack>\n <ct-text>Font Family</ct-text>\n <ct-select\n items={[\n {\n label: \"System\",\n value: \"system-ui, -apple-system, sans-serif\",\n },\n {\n label: \"Monospace\",\n value: \"ui-monospace, Consolas, monospace\",\n },\n {\n label: \"Serif\",\n value: \"Georgia, Times, serif\",\n },\n {\n label: \"Sans Serif\",\n value: \"Arial, Helvetica, sans-serif\",\n },\n ]}\n $value={localTheme.fontFace}\n />\n </ct-vstack>\n\n <ct-vstack>\n <ct-text>Accent Color</ct-text>\n <ct-select\n items={[\n { label: \"Blue\", value: \"#3b82f6\" },\n { label: \"Purple\", value: \"#8b5cf6\" },\n { label: \"Green\", value: \"#10b981\" },\n { label: \"Red\", value: \"#ef4444\" },\n { label: \"Orange\", value: \"#f97316\" },\n { label: \"Pink\", value: \"#ec4899\" },\n { label: \"Indigo\", value: \"#6366f1\" },\n { label: \"Teal\", value: \"#14b8a6\" },\n ]}\n $value={localTheme.accentColor}\n />\n </ct-vstack>\n\n <ct-vstack>\n <ct-text>Border Radius</ct-text>\n <ct-select\n items={[\n { label: \"None\", value: \"0px\" },\n { label: \"Small\", value: \"0.25rem\" },\n { label: \"Medium\", value: \"0.5rem\" },\n { label: \"Large\", value: \"0.75rem\" },\n { label: \"Extra Large\", value: \"1rem\" },\n { label: \"Rounded\", value: \"1.5rem\" },\n ]}\n $value={localTheme.borderRadius}\n />\n </ct-vstack>\n </ct-vstack>\n </ct-collapsible>\n </aside>\n </ct-autolayout>\n </ct-screen>\n </ct-theme>\n ),\n selectedCharm,\n charmsList,\n // Expose the aggregated mentionables for parent-level indexing.\n mentionable: localMentionable,\n };\n },\n);\n"}}}}},"of:baedreiaconf4zx2gafumhuetpthdpy6ncqtjjnlagr2mjfzrtuygwatzju":{"application/json":{"ba4jcbr2plisj6q563jgf3recfb534r7dzbq3p54wcylyo42ywjs6ewn4":{"is":{"value":{"name":"/omnibox-fab.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n computed,\n handler,\n ifElse,\n NAME,\n pattern,\n patternTool,\n UI,\n} from \"commontools\";\nimport Chatbot from \"./chatbot.tsx\";\nimport {\n calculator,\n fetchAndRunPattern,\n listPatternIndex,\n navigateToPattern,\n readWebpage,\n searchWeb,\n} from \"./common-tools.tsx\";\nimport { MentionableCharm } from \"./backlinks-index.tsx\";\n\ninterface OmniboxFABInput {\n mentionable: Cell<MentionableCharm[]>;\n}\n\nconst toggle = handler<any, { value: Cell<boolean> }>((_, { value }) => {\n value.set(!value.get());\n});\n\nconst closeFab = handler<any, { fabExpanded: Cell<boolean> }>(\n (_, { fabExpanded }) => {\n fabExpanded.set(false);\n },\n);\n\nconst dismissPeek = handler<\n any,\n { peekDismissedIndex: Cell<number>; assistantMessageCount: number }\n>((_, { peekDismissedIndex, assistantMessageCount }) => {\n // Store the current assistant message count so we know which message was dismissed\n peekDismissedIndex.set(assistantMessageCount);\n});\n\nexport default pattern<OmniboxFABInput>(\n (_) => {\n const omnibot = Chatbot({\n system:\n \"You are a polite but efficient assistant. Think Star Trek computer - helpful and professional without unnecessary conversation. Let your actions speak for themselves.\\n\\nTool usage priority:\\n- For patterns: listPatternIndex first\\n- For existing pages/notes/content: listRecent or listMentionable to identify what they're referencing\\n- Attach relevant items to conversation after instantiation/retrieval if they support ongoing tasks\\n- Remove attachments when no longer relevant\\n- Search web only as last resort when nothing exists in the space\\n\\nBe matter-of-fact. Prefer action to explanation.\",\n tools: {\n searchWeb: {\n pattern: searchWeb,\n },\n readWebpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n fetchAndRunPattern: patternTool(fetchAndRunPattern),\n listPatternIndex: patternTool(listPatternIndex),\n navigateTo: patternTool(navigateToPattern),\n },\n });\n\n const fabExpanded = Cell.of(false);\n const showHistory = Cell.of(false);\n const peekDismissedIndex = Cell.of(-1); // Track which message index was dismissed\n\n // Derive assistant message count for dismiss tracking\n const assistantMessageCount = computed(() => {\n return omnibot.messages.filter((m) => m.role === \"assistant\").length;\n });\n\n // Derive latest assistant message for peek\n const latestAssistantMessage = computed(() => {\n if (!omnibot.messages || omnibot.messages.length === 0) return null;\n\n for (let i = omnibot.messages.length - 1; i >= 0; i--) {\n const msg = omnibot.messages[i];\n if (msg.role === \"assistant\") {\n const content = typeof msg.content === \"string\"\n ? msg.content\n : msg.content.map((part: any) => {\n if (part.type === \"text\") return part.text;\n return \"\";\n }).join(\"\");\n\n return content;\n }\n }\n return null;\n });\n\n return {\n [NAME]: \"OmniboxFAB\",\n messages: omnibot.messages,\n [UI]: (\n <ct-fab\n expanded={computed(() => fabExpanded.get())}\n variant=\"primary\"\n position=\"bottom-right\"\n pending={omnibot.pending}\n $previewMessage={latestAssistantMessage}\n onct-fab-backdrop-click={closeFab({ fabExpanded })}\n onct-fab-escape={closeFab({ fabExpanded })}\n onClick={toggle({ value: fabExpanded })}\n >\n <div style=\"width: 100%; display: flex; flex-direction: column; max-height: 580px;\">\n {/* Chevron at top - the \"handle\" for the drawer */}\n <div style=\"border-bottom: 1px solid #e5e5e5; flex-shrink: 0;\">\n <ct-chevron-button\n expanded={computed(() => showHistory.get())}\n loading={omnibot.pending}\n onct-toggle={toggle({ value: showHistory })}\n />\n </div>\n\n <div\n style={computed(() => {\n const show = showHistory.get();\n return `flex: ${\n show ? \"1\" : \"0\"\n }; min-height: 0; display: flex; flex-direction: column; opacity: ${\n show ? \"1\" : \"0\"\n }; max-height: ${\n show ? \"480px\" : \"0\"\n }; overflow: hidden; transition: opacity 300ms ease, max-height 400ms cubic-bezier(0.34, 1.56, 0.64, 1), flex 400ms cubic-bezier(0.34, 1.56, 0.64, 1); pointer-events: ${\n show ? \"auto\" : \"none\"\n };`;\n })}\n >\n <div style=\"padding: .25rem; flex-shrink: 0;\">\n {omnibot.ui.attachmentsAndTools}\n </div>\n <div style=\"flex: 1; overflow-y: auto; min-height: 0;\">\n <ct-cell-context $cell={omnibot}>\n {omnibot.ui.chatLog}\n </ct-cell-context>\n </div>\n </div>\n\n {ifElse(\n computed(() => {\n const show = showHistory.get();\n const dismissedIdx = peekDismissedIndex.get();\n return !show && latestAssistantMessage &&\n assistantMessageCount !== dismissedIdx;\n }),\n <div style=\"margin: .5rem; margin-bottom: 0; padding: 0; flex-shrink: 0; position: relative;\">\n <ct-button\n variant=\"ghost\"\n size=\"icon\"\n onClick={dismissPeek({\n peekDismissedIndex,\n assistantMessageCount,\n })}\n style=\"position: absolute; top: 0px; right: 0px; z-index: 1; font-size: 16px;\"\n title=\"Dismiss\"\n >\n √ó\n </ct-button>\n <div\n onClick={toggle({ value: showHistory })}\n style=\"cursor: pointer;\"\n >\n <ct-cell-context $cell={latestAssistantMessage}>\n <ct-chat-message\n role=\"assistant\"\n compact\n content={latestAssistantMessage}\n pending={omnibot.pending}\n />\n </ct-cell-context>\n </div>\n </div>,\n null,\n )}\n\n {/* Prompt input - always at bottom */}\n <div style=\"padding: 0.5rem; flex-shrink: 0;\">\n {omnibot.ui.promptInput}\n </div>\n </div>\n </ct-fab>\n ),\n fabExpanded,\n };\n },\n);\n"}}}}},"of:baedreiayx6zri6trvdy7qaw5ljqys5fb64tlzmd6pih5afnpdyqcnhau5y":{"application/json":{"ba4jcbh6cwld4jbyaablnjvoxyng7o6zltqfvv2yybv6wy5i5ajsielq6":{"is":{"value":{"name":"/chatbot-note-composed.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n cell,\n Default,\n derive,\n handler,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot.tsx\";\nimport Note from \"./note.tsx\";\nimport {\n addListItem,\n calculator,\n ListItem,\n readListItems,\n readWebpage,\n searchWeb,\n} from \"./common-tools.tsx\";\n\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\n\nfunction schemaifyWish<T>(path: string, def: T) {\n return derive(wish<T>(path), (i) => i ?? def);\n}\n\ntype ChatbotNoteInput = {\n title?: Cell<Default<string, \"LLM Test\">>;\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n};\n\ntype ChatbotNoteResult = {\n messages: Default<Array<BuiltInLLMMessage>, []>;\n chat: any;\n list: Default<ListItem[], []>;\n // Optional: expose sub-charms as mentionable targets\n mentionable?: MentionableCharm[];\n};\n\nconst newNote = handler<\n {\n /** The text content of the note */\n title: string;\n content?: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allCharms: Cell<MentionableCharm[]>; index: any }\n>(\n (args, _) => {\n try {\n const n = Note({\n title: args.title,\n content: args.content ?? \"\",\n });\n\n args.result.set(\n `Created note ${args.title}`,\n );\n\n // TODO(bf): we have to navigate here until DX1 lands\n // then we go back to pushing to allCharms\n return navigateTo(n);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst listMentionable = handler<\n {\n /** A cell to store the result text */\n result: Cell<string>;\n },\n { mentionable: MentionableCharm[] }\n>(\n (args, state) => {\n try {\n const namesList = state.mentionable.map((charm) => charm[NAME]);\n args.result.set(JSON.stringify(namesList));\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst readContentByIndex = handler<\n {\n /** A cell to store the result text */\n index: number;\n result: Cell<string>;\n },\n { allNotes: Note[] }\n>(\n (args, state) => {\n try {\n args.result.set(\n state.allNotes[args.index]?.content || \"No content found\",\n );\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\ntype Note = MentionableCharm & { content: string };\nconst editContentByIndex = handler<\n {\n /** The index of the note to edit */\n index: number;\n /** The new text content of the note */\n body: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allNotes: Cell<Note[]> }\n>(\n (args, state) => {\n try {\n const charms = state.allNotes.get();\n if (args.index < 0 || args.index >= charms.length) {\n args.result.set(`Error: Invalid index ${args.index}`);\n return;\n }\n\n state.allNotes.key(args.index).key(\"content\").set(args.body);\n args.result.set(`Updated note at index ${args.index}!`);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst navigateToNote = handler<\n {\n /** The index of the note to navigate to */\n index: number;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allCharms: Cell<MentionableCharm[]> }\n>(\n (args, state) => {\n try {\n const charms = state.allCharms.get();\n if (args.index < 0 || args.index >= charms.length) {\n args.result.set(`Error: Invalid index ${args.index}`);\n return;\n }\n\n const targetCharm = charms[args.index];\n args.result.set(`Navigating to note: ${targetCharm[NAME]}`);\n\n return navigateTo(state.allCharms.key(args.index));\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\ntype BacklinksIndex = {\n mentionable: MentionableCharm[];\n};\n\nexport default recipe<ChatbotNoteInput, ChatbotNoteResult>(\n \"Chatbot + Note\",\n ({ title, messages }) => {\n const allCharms = schemaifyWish<MentionableCharm[]>(\"#allCharms\", []);\n const index = schemaifyWish<BacklinksIndex>(\"#default/backlinksIndex\", {\n mentionable: [],\n });\n const mentionable = schemaifyWish<MentionableCharm[]>(\n \"#mentionable\",\n [],\n );\n\n const list = cell<ListItem[]>([]);\n\n const tools = {\n searchWeb: {\n pattern: searchWeb,\n },\n readWebpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n addListItem: {\n handler: addListItem({ list }),\n },\n readListItems: {\n handler: readListItems({ list }),\n },\n listMentionable: {\n description:\n \"List all mentionable items titles (read the body with readNoteByIndex).\",\n handler: listMentionable({ mentionable }),\n },\n readContentByIndex: {\n description:\n \"Read the content of a mentionable by its index in the listMentionable() list (if possible)\",\n handler: readContentByIndex({\n allNotes: mentionable as unknown as OpaqueRef<Note[]>,\n }),\n },\n editContentByIndex: {\n description:\n \"Edit the content of a mentionable by its index in the listMentionable() list (if possible)\",\n handler: editContentByIndex({\n allNotes: mentionable as unknown as OpaqueRef<Note[]>,\n }),\n },\n navigateToNote: {\n description:\n \"Navigate to a mentionable by its index in the listMentionable() list.\",\n handler: navigateToNote({\n allCharms: allCharms as unknown as OpaqueRef<MentionableCharm[]>,\n }),\n },\n newNote: {\n description: \"Create a new note instance\",\n handler: newNote({\n allCharms: allCharms as unknown as OpaqueRef<MentionableCharm[]>,\n index: index as unknown as OpaqueRef<any>,\n }),\n },\n };\n\n const chat = Chat({ messages, tools });\n\n return {\n [NAME]: title,\n chat,\n messages,\n list,\n // Expose sub-charms as mentionable targets\n mentionable: [chat as unknown as MentionableCharm],\n };\n },\n);\n"}}}}},"of:baedreigayykp34gmnn2ckdu2zfleo6tyu3qqo46p2fifo44yez3htt227i":{"application/json":{"ba4jcbaoftoa3n7imawbtj4kexj4z4mizwaebrix47gtckoqhokb7z36g":{"is":{"value":{"name":"/common-tools.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMTool,\n Cell,\n compileAndRun,\n computed,\n derive,\n fetchData,\n fetchProgram,\n handler,\n ifElse,\n navigateTo,\n recipe,\n} from \"commontools\";\n\n///// COMMON TOOLS (get it?) ////\n\n/**\n * Calculate the result of a mathematical expression.\n * Supports +, -, *, /, and parentheses.\n */\ntype CalculatorRequest = {\n /** The mathematical expression to evaluate. */\n expression: string;\n /** The base to use for the calculation. */\n base?: number;\n};\n\nexport const calculator = recipe<\n CalculatorRequest,\n string | { error: string }\n>(({ expression, base }) => {\n return derive({ expression, base }, ({ expression, base }) => {\n const sanitized = expression.replace(/[^0-9+\\-*/().\\s]/g, \"\");\n let sanitizedBase = Number(base);\n if (\n Number.isNaN(sanitizedBase) || sanitizedBase < 2 || sanitizedBase > 36\n ) {\n sanitizedBase = 10;\n }\n let result;\n try {\n result = Function(\n `\"use strict\"; return Number(${sanitized}).toString(${sanitizedBase})`,\n )();\n } catch (error) {\n result = { error: (error as any)?.message || \"<error>\" };\n }\n return result;\n });\n});\n\n/** Add an item to the list. */\ntype AddListItemRequest = {\n /** The item to add to the list. */\n item: string;\n result: Cell<string>;\n};\n\n/** Read all items from the list. */\ntype ReadListItemsRequest = {\n result: Cell<string>;\n};\n\nexport type ListItem = {\n title: string;\n};\n\nexport const addListItem = handler<\n AddListItemRequest,\n { list: Cell<ListItem[]> }\n>(\n (args, state) => {\n try {\n state.list.push({ title: args.item });\n args.result.set(`${state.list.get().length} items`);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nexport const readListItems = handler<\n ReadListItemsRequest,\n { list: ListItem[] }\n>(\n (args, state) => {\n try {\n const items = state.list;\n if (items.length === 0) {\n args.result.set(\"The list is empty\");\n } else {\n const itemList = items.map((item, index) =>\n `${index + 1}. ${item.title}`\n ).join(\"\\n\");\n args.result.set(`List items (${items.length} total):\\n${itemList}`);\n }\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\n/** Search the web for information. */\ntype SearchQuery = {\n /** The query to search the web for. */\n query: string;\n};\n\ntype SearchWebResult = {\n results: {\n title: string;\n url: string;\n description: string;\n }[];\n};\n\nexport const searchWeb = recipe<\n SearchQuery,\n SearchWebResult | { error: string }\n>(({ query }) => {\n const { result, error } = fetchData<SearchWebResult>({\n url: \"/api/agent-tools/web-search\",\n mode: \"json\",\n options: {\n method: \"POST\",\n headers: {\n \"Content-Type\": \"application/json\",\n },\n body: {\n query,\n max_results: 5,\n },\n },\n });\n\n // TODO(seefeld): Should we instead return { result, error }? Or allocate a\n // special [ERROR] for errors? Ideally this isn't specific to using recipes as\n // tools but a general pattern.\n return ifElse(error, { error }, result);\n});\n\n/** Read and extract content from a specific webpage URL. */\ntype ReadWebRequest = {\n /** The URL of the webpage to read and extract content from. */\n url: string;\n};\n\ntype ReadWebResult = {\n content: string;\n metadata: {\n title?: string;\n author?: string;\n date?: string;\n word_count: number;\n };\n};\n\nexport const readWebpage = recipe<\n ReadWebRequest,\n ReadWebResult | { error: string }\n>(({ url }) => {\n const { result, error } = fetchData<ReadWebResult>({\n url: \"/api/agent-tools/web-read\",\n mode: \"json\",\n options: {\n method: \"POST\",\n headers: {\n \"Content-Type\": \"application/json\",\n },\n body: {\n url,\n max_tokens: 4000,\n include_code: true,\n },\n },\n });\n\n return ifElse(error, { error }, result);\n});\n\ntype ToolsInput = {\n list: ListItem[];\n};\n\nexport default recipe<ToolsInput>(({ list }) => {\n const tools: Record<string, BuiltInLLMTool> = {\n search_web: {\n pattern: searchWeb,\n },\n read_webpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n addListItem: {\n handler: addListItem({ list }),\n },\n };\n\n return { tools, list };\n});\n\n/**\n * `fetchAndRunPattern({ url: \"https://...\", args: {} })`\n *\n * Instantiates patterns (e.g. from listPatternIndex) and returns the cell that\n * contains the results. The instantiated pattern will keep running and updating\n * the cell. Pass the resulting cell to `navigateTo` to show the pattern's UI.\n *\n * Pass in arguments to initialize the pattern. It's especially useful to pass\n * in links to other cells as `{ \"@link\": \"/of:bafe.../path/to/data\" }`.\n */\ntype FetchAndRunPatternInput = {\n url: string;\n args: Cell<any>;\n};\nexport const fetchAndRunPattern = recipe<FetchAndRunPatternInput>(\n ({ url, args }) => {\n const { pending: _fetchPending, result: program, error: _fetchError } =\n fetchProgram({ url });\n\n // Use derive to safely handle when program is undefined/pending\n const compileParams = derive(program, (p) => ({\n files: p?.files ?? [],\n main: p?.main ?? \"\",\n input: args,\n }));\n\n const { pending, result, error } = compileAndRun(compileParams);\n\n return ifElse(\n computed(() => pending || (!result && !error)),\n undefined,\n {\n cell: result,\n error,\n },\n );\n },\n);\n\n/**\n * `navigateTo({ cell: { \"@link\": \"/of:xyz\" } })` - Navigates to that cell's UI\n *\n * Especially useful after instantiating a pattern with fetchAndRunPattern:\n * Pass the \"@link\" you get at `cell` to navigate to the pattern's view.\n */\ntype NavigateToPatternInput = { cell: Cell<any> }; // Hack to steer LLM\nexport const navigateToPattern = recipe<NavigateToPatternInput>(\n ({ cell }) => {\n const success = navigateTo(cell);\n\n return ifElse(success, { success }, undefined);\n },\n);\n\n/**\n * `listPatternIndex()` - Returns the index of patterns.\n *\n * Useful as input to fetchAndRun.\n */\ntype ListPatternIndexInput = Record<string, never>;\n\nexport const listPatternIndex = recipe<ListPatternIndexInput>(\n ({ _ }) => {\n const { pending, result } = fetchData({\n url: \"/api/patterns/index.md\",\n mode: \"text\",\n });\n return ifElse(computed(() => pending || !result), undefined, { result });\n },\n);\n"}}}}}}},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcb5wyzv3hf3hcmim4jsbumrrcrp74q6hcwc2v2wjpv3hif4iv4oa3":{}},"signature":{"/":{"bytes":"XTK5wsmNOc8BtsZDMaoqePBgaQiQWfJfBOaOEq/LlxkREyTDJVruEh+Etn/wk0dTGmteHZe/7mVY/Z5+RMQUAQ"}}}}	61967	
16:19:04.493
{"invocation":{"cmd":"/memory/graph/query","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"selectSchema":{"of:baedreiayeohgxjzmij53y63lgaax5ndolqk5ksdwu6xscel4kx2m2s6c3q":{"application/json":{"_":{"path":[],"schemaContext":{"schema":{"type":"object","properties":{"id":{"type":"string"},"src":{"type":"string"},"spec":{"type":"string"},"parents":{"type":"array","items":{"type":"string"}},"recipeName":{"type":"string"},"program":{"type":"object","properties":{"main":{"type":"string"},"mainExport":{"type":"string"},"files":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"contents":{"type":"string"}},"required":["name","contents"]}}},"required":["main","files"]}},"required":["id"]},"rootSchema":{"type":"object","properties":{"id":{"type":"string"},"src":{"type":"string"},"spec":{"type":"string"},"parents":{"type":"array","items":{"type":"string"}},"recipeName":{"type":"string"},"program":{"type":"object","properties":{"main":{"type":"string"},"mainExport":{"type":"string"},"files":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"contents":{"type":"string"}},"required":["name","contents"]}}},"required":["main","files"]}},"required":["id"]}}}}}},"subscribe":true,"excludeSent":true},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcbmi7dxrmzxfatl7v5qzminqcgjnwsrkhwec5un462m4ssvaeaeze":{}},"signature":{"/":{"bytes":"MVLnJtiS2S9cZKd6BSL5rCsRRdMC3InYXpFEGX9oXZZIll0xKzUOrdSoeBH+lFPxYzcgzEFT699RLUOHKqu8Cg"}}}}	1602	
16:19:04.494
{"the":"task/effect","of":"job:ba4jcby4qeu3vpdvsxa34zgu3vbicuiyqdgxwjuqosuhvsxxlon6lu3cp","is":{"commit":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{"application/commit+json":{"ba4jcavntb4u2adfkq3ho426vsgu22kvq45wzldkialwlku7hlltl7a7o":{"is":{"since":20,"transaction":{"cmd":"/memory/transact","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"changes":{"of:baedreiayeohgxjzmij53y63lgaax5ndolqk5ksdwu6xscel4kx2m2s6c3q":{"application/json":{"ba4jcb3hhqhe4nfpe2r3jcw4pjcg5xj6dshwik532oxtibrg3rlpdpyf6":{"is":{"value":{"id":"ba4jcaodz2xu6wbjq3i54qb4dily77jzm6ofnrimmtbv6lcfgexob2umv","program":{"main":"/default-app.tsx","files":[{"/":{"link@1":{"path":[],"id":"of:baedreibr6gycs6dvh32an73hiiddc54zmousvmu7eknp2k75nj2hprzofy"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiczp2strjgmqqr4y4cdhnfgyxpa2p7jh2clgkahly3d2ctbm52z2i"}}},{"/":{"link@1":{"path":[],"id":"of:baedreibkc7zcxdembp7sxpowfbthuiwev4tyyvciuvwzu7egg6323czmh4"}}},{"/":{"link@1":{"path":[],"id":"of:baedreigmgcvh4yl4bwa5mobdiqln6dtzz62ok6ctgh2gaiijiarqi3utkm"}}},{"/":{"link@1":{"path":[],"id":"of:baedreigo5n6mtjvvxsxkwqnzmvrl6vclp2fam46mx7nzykshmgyjtyivgu"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiam356b7666ueqii5minnknx2nes4rblkbvqnp7ogzjqoislg65du"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiaconf4zx2gafumhuetpthdpy6ncqtjjnlagr2mjfzrtuygwatzju"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiayx6zri6trvdy7qaw5ljqys5fb64tlzmd6pih5afnpdyqcnhau5y"}}},{"/":{"link@1":{"path":[],"id":"of:baedreigayykp34gmnn2ckdu2zfleo6tyu3qqo46p2fifo44yez3htt227i"}}}]},"spec":"recipe"}}}}},"of:baedreibr6gycs6dvh32an73hiiddc54zmousvmu7eknp2k75nj2hprzofy":{"application/json":{"ba4jcbvpt5rfkhehimagciotvn3bpzzhz3uo5p4gmlr7l4jlydp7ixyuz":{"is":{"value":{"name":"/default-app.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n handler,\n NAME,\n navigateTo,\n recipe,\n str,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chatbot from \"./chatbot.tsx\";\nimport ChatbotOutliner from \"./chatbot-outliner.tsx\";\nimport { default as Note } from \"./note.tsx\";\nimport BacklinksIndex, { type MentionableCharm } from \"./backlinks-index.tsx\";\nimport ChatList from \"./chatbot-list-view.tsx\";\nimport OmniboxFAB from \"./omnibox-fab.tsx\";\n\ntype MinimalCharm = {\n [NAME]?: string;\n};\n\ntype CharmsListInput = void;\n\n// Recipe returns only UI, no data outputs (only symbol properties)\ninterface CharmsListOutput {\n [key: string]: unknown;\n backlinksIndex: {\n mentionable: MentionableCharm[];\n };\n sidebarUI: unknown;\n fabUI: unknown;\n}\n\nconst _visit = handler<\n Record<string, never>,\n { charm: Cell<MinimalCharm> }\n>((_, state) => {\n return navigateTo(state.charm);\n}, { proxy: true });\n\nconst removeCharm = handler<\n Record<string, never>,\n {\n charm: Cell<MinimalCharm>;\n allCharms: Cell<MinimalCharm[]>;\n }\n>((_, state) => {\n const allCharmsValue = state.allCharms.get();\n const index = allCharmsValue.findIndex((c: any) => state.charm.equals(c));\n\n if (index !== -1) {\n const charmListCopy = [...allCharmsValue];\n console.log(\"charmListCopy before\", charmListCopy.length);\n charmListCopy.splice(index, 1);\n console.log(\"charmListCopy after\", charmListCopy.length);\n state.allCharms.set(charmListCopy);\n }\n});\n\nconst toggleFab = handler<any, { fabExpanded: Cell<boolean> }>(\n (_, { fabExpanded }) => {\n fabExpanded.set(!fabExpanded.get());\n },\n);\n\nconst spawnChatList = handler<void, void>((_, __) => {\n return navigateTo(ChatList({\n selectedCharm: { charm: undefined },\n charmsList: [],\n }));\n});\n\nconst spawnChatbot = handler<void, void>((_, __) => {\n return navigateTo(Chatbot({\n messages: [],\n tools: undefined,\n }));\n});\n\nconst spawnChatbotOutliner = handler<void, void>((_, __) => {\n return navigateTo(ChatbotOutliner({\n title: \"Chatbot Outliner\",\n expandChat: false,\n messages: [],\n outline: {\n root: { body: \"\", children: [], attachments: [] },\n },\n }));\n});\n\nconst spawnNote = handler<void, void>((_, __) => {\n return navigateTo(Note({\n title: \"New Note\",\n content: \"\",\n }));\n});\n\nexport default recipe<CharmsListInput, CharmsListOutput>(\n \"DefaultCharmList\",\n (_) => {\n const { allCharms } = wish<{ allCharms: MentionableCharm[] }>(\"/\");\n const index = BacklinksIndex({ allCharms });\n\n const fab = OmniboxFAB({\n mentionable: index.mentionable as unknown as Cell<MentionableCharm[]>,\n });\n\n return {\n backlinksIndex: index,\n [NAME]: str`DefaultCharmList (${allCharms.length})`,\n [UI]: (\n <ct-screen>\n <ct-keybind\n code=\"KeyN\"\n alt\n preventDefault\n onct-keybind={spawnChatList()}\n />\n <ct-keybind\n code=\"KeyO\"\n meta\n preventDefault\n onct-keybind={toggleFab({ fabExpanded: fab.fabExpanded })}\n />\n <ct-keybind\n code=\"KeyO\"\n ctrl\n preventDefault\n onct-keybind={toggleFab({ fabExpanded: fab.fabExpanded })}\n />\n\n <ct-toolbar slot=\"header\" sticky>\n <div slot=\"start\">\n <ct-button\n onClick={spawnChatList()}\n >\n üìÇ Chat List\n </ct-button>\n <ct-button\n onClick={spawnChatbot()}\n >\n üí¨ Chatbot\n </ct-button>\n <ct-button\n onClick={spawnChatbotOutliner()}\n >\n üìù Chatbot Outliner\n </ct-button>\n <ct-button\n onClick={spawnNote()}\n >\n üìÑ Note\n </ct-button>\n </div>\n </ct-toolbar>\n\n <ct-vscroll flex showScrollbar>\n <ct-vstack gap=\"4\" padding=\"6\">\n <style>\n {`\n .pattern-link {\n cursor: pointer;\n color: inherit;\n text-decoration: none;\n }\n .pattern-link:hover {\n text-decoration: underline;\n }\n `}\n </style>\n <h2>Pages</h2>\n\n <ct-table full-width hover>\n <tbody>\n {allCharms.map((charm) => (\n <tr>\n <td>\n <ct-cell-context $cell={charm}>\n <ct-cell-link $cell={charm} />\n </ct-cell-context>\n </td>\n <td>\n <ct-button\n size=\"sm\"\n variant=\"ghost\"\n onClick={removeCharm({ charm, allCharms })}\n >\n üóëÔ∏è\n </ct-button>\n </td>\n </tr>\n ))}\n </tbody>\n </ct-table>\n </ct-vstack>\n </ct-vscroll>\n </ct-screen>\n ),\n sidebarUI: undefined,\n fabUI: fab[UI],\n };\n },\n);\n"}}}}},"of:baedreiczp2strjgmqqr4y4cdhnfgyxpa2p7jh2clgkahly3d2ctbm52z2i":{"application/json":{"ba4jcbt6ddwmeffgpkxsqtfzakrhur22vsc4gzalizp2kegda7jxjgdpm":{"is":{"value":{"name":"/chatbot.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n computed,\n Default,\n fetchData,\n generateObject,\n handler,\n llmDialog,\n NAME,\n pattern,\n patternTool,\n Stream,\n UI,\n VNode,\n wish,\n} from \"commontools\";\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\n\nfunction schemaifyWish<T>(path: string) {\n return wish<T>(path);\n}\n\nconst sendMessage = handler<\n {\n detail: {\n text: string;\n attachments: Array<PromptAttachment>;\n mentions: Array<any>;\n message: string; // Backward compatibility\n };\n },\n {\n addMessage: Stream<BuiltInLLMMessage>;\n }\n>((event, { addMessage }) => {\n const { text } = event.detail;\n\n // Send the message as-is. Any markdown links like [name](/of:...)\n // are just text that the LLM can parse and use with addAttachment() tool.\n addMessage.send({\n role: \"user\",\n content: [{ type: \"text\" as const, text }],\n });\n});\n\nconst clearChat = handler(\n (\n _: never,\n { messages, pending }: {\n messages: Cell<Array<BuiltInLLMMessage>>;\n pending: Cell<boolean | undefined>;\n },\n ) => {\n messages.set([]);\n pending.set(false);\n },\n);\n\ntype ChatInput = {\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n tools?: any;\n theme?: any;\n system?: string;\n};\n\ntype PromptAttachment = {\n id: string;\n name: string;\n type: \"file\" | \"clipboard\" | \"mention\";\n data?: any; // File | Blob | string\n charm?: any;\n removable?: boolean; // Whether this attachment can be removed\n};\n\ntype ChatOutput = {\n messages: Array<BuiltInLLMMessage>;\n pending: boolean | undefined;\n addMessage: Stream<BuiltInLLMMessage>;\n clearChat: Stream<void>;\n cancelGeneration: Stream<void>;\n title?: string;\n pinnedCells: Array<PromptAttachment>;\n tools: any;\n ui: {\n chatLog: VNode;\n promptInput: VNode;\n attachmentsAndTools: VNode;\n };\n};\n\nexport const TitleGenerator = pattern<\n { model?: string; messages: Array<BuiltInLLMMessage> }\n>(({ model, messages }) => {\n const previewMessage = computed(() => {\n if (!messages || messages.length === 0) return \"\";\n\n const firstMessage = messages[0];\n\n if (!firstMessage) return \"\";\n\n return JSON.stringify(firstMessage);\n });\n\n const { result } = generateObject({\n system:\n \"Generate at most a 3-word title based on the following content, respond with NOTHING but the literal title text.\",\n prompt: previewMessage,\n model,\n schema: {\n type: \"object\",\n properties: {\n title: {\n type: \"string\",\n description: \"The title of the chat\",\n },\n },\n required: [\"title\"],\n },\n });\n\n const title = computed(() => {\n return result?.title || \"Untitled Chat\";\n });\n\n return title;\n});\n\nconst listMentionable = pattern<\n { mentionable: Array<MentionableCharm> },\n { result: Array<{ label: string; cell: Cell<unknown> }> }\n>(\n ({ mentionable }) => {\n const result = mentionable.map((charm) => ({\n label: charm[NAME]!,\n cell: charm,\n }));\n return { result };\n },\n);\n\nconst listRecent = pattern<\n { recentCharms: Array<MentionableCharm> },\n { result: Array<{ label: string; cell: Cell<unknown> }> }\n>(\n ({ recentCharms }) => {\n const namesList = recentCharms.map((charm) => ({\n label: charm[NAME]!,\n cell: charm,\n }));\n return { result: namesList };\n },\n);\n\nexport default pattern<ChatInput, ChatOutput>(\n ({ messages, tools, theme, system }) => {\n const model = Cell.of<string>(\"anthropic:claude-sonnet-4-5\");\n const mentionable = schemaifyWish<MentionableCharm[]>(\"#mentionable\");\n const recentCharms = schemaifyWish<MentionableCharm[]>(\"#recent\");\n\n const assistantTools = {\n listMentionable: patternTool(listMentionable, { mentionable }),\n listRecent: patternTool(listRecent, { recentCharms }),\n };\n\n // Merge static and assistant tools\n const mergedTools = computed(() => ({\n ...tools,\n ...assistantTools,\n }));\n\n const latest = computed(() => recentCharms[0]);\n const latestName = computed(() => recentCharms[0]?.[NAME]);\n\n const {\n addMessage,\n cancelGeneration,\n pending,\n flattenedTools,\n pinnedCells,\n } = llmDialog(\n {\n system: computed(() => {\n return system ?? \"You are a polite but efficient assistant.\";\n }),\n messages,\n tools: mergedTools,\n model,\n context: computed(() => ({\n [latestName]: latest,\n })),\n },\n );\n\n const { result } = fetchData({\n url: \"/api/ai/llm/models\",\n mode: \"json\",\n });\n\n const items = computed(() => {\n if (!result) return [];\n const items = Object.keys(result as any).map((key) => ({\n label: key,\n value: key,\n }));\n return items;\n });\n\n const title = TitleGenerator({ model, messages });\n\n const promptInput = (\n <ct-prompt-input\n slot=\"footer\"\n placeholder=\"Ask the LLM a question...\"\n pending={pending}\n $mentionable={mentionable}\n modelItems={items}\n $model={model}\n onct-send={sendMessage({ addMessage })}\n onct-stop={cancelGeneration}\n />\n );\n\n const chatLog = (\n <ct-vscroll\n style=\"padding: 1rem;\"\n flex\n showScrollbar\n fadeEdges\n snapToBottom\n >\n <ct-chat\n theme={theme}\n $messages={messages}\n pending={pending}\n tools={flattenedTools}\n />\n </ct-vscroll>\n );\n\n const attachmentsAndTools = (\n <ct-hstack align=\"center\" gap=\"1\">\n <ct-cell-context $cell={pinnedCells}>\n <ct-attachments-bar pinnedCells={pinnedCells} />\n </ct-cell-context>\n <ct-tools-chip tools={flattenedTools} />\n <ct-button\n variant=\"pill\"\n type=\"button\"\n title=\"Clear chat\"\n onClick={clearChat({\n messages,\n pending,\n })}\n >\n Clear\n </ct-button>\n </ct-hstack>\n );\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <ct-vstack slot=\"header\">\n <ct-heading level={4}>{title}</ct-heading>\n {attachmentsAndTools}\n </ct-vstack>\n\n {chatLog}\n\n {promptInput}\n </ct-screen>\n ),\n messages,\n pending,\n addMessage,\n clearChat: clearChat({\n messages,\n pending,\n }),\n cancelGeneration,\n title,\n pinnedCells,\n tools: flattenedTools,\n ui: {\n chatLog,\n promptInput,\n attachmentsAndTools,\n },\n };\n },\n);\n"}}}}},"of:baedreibkc7zcxdembp7sxpowfbthuiwev4tyyvciuvwzu7egg6323czmh4":{"application/json":{"ba4jcb4arsk7c7axovlb2gztmprwn45blyew2apjcv6lgh6r3oiuqdcnv":{"is":{"value":{"name":"/chatbot-outliner.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n Default,\n derive,\n handler,\n ifElse,\n JSONSchema,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot.tsx\";\nimport { MentionableCharm } from \"./backlinks-index.tsx\";\n\ntype Charm = any;\n\ntype OutlinerNode = {\n body: Default<string, \"\">;\n children: Default<OutlinerNode[], []>;\n attachments: Default<OpaqueRef<any>[], []>;\n};\n\ntype Outliner = {\n root: OutlinerNode;\n};\n\ntype PageResult = {\n outline: Default<\n Outliner,\n { root: { body: \"\"; children: []; attachments: [] } }\n >;\n};\n\nexport type PageInput = {\n outline: Outliner;\n};\n\nconst handleCharmLinkClick = handler<\n {\n detail: {\n charm: Cell<Charm>;\n };\n },\n Record<string, never>\n>(({ detail }, _) => {\n return navigateTo(detail.charm);\n});\n\nfunction getMentionable() {\n return derive<MentionableCharm[], MentionableCharm[]>(\n wish<MentionableCharm[]>(\"#mentionable\"),\n (i) => i,\n );\n}\n\nexport const Page = recipe<PageInput>(\n \"Page\",\n ({ outline }) => {\n const mentionable = getMentionable();\n\n return {\n [NAME]: \"Page\",\n [UI]: (\n <ct-outliner\n $value={outline as any}\n $mentionable={mentionable}\n oncharm-link-click={handleCharmLinkClick({})}\n />\n ),\n outline,\n };\n },\n);\n\ntype LLMTestInput = {\n title?: Cell<Default<string, \"LLM Test\">>;\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n expandChat?: Cell<Default<boolean, false>>;\n outline?: Default<\n Outliner,\n { root: { body: \"Untitled Page\"; children: []; attachments: [] } }\n >;\n};\n\ntype LLMTestResult = {\n messages: Default<Array<BuiltInLLMMessage>, []>;\n};\n\n// put a node at the end of the outline (by appending to root.children)\nconst appendOutlinerNode = handler<\n {\n /** The text content/title of the outliner node to be appended */\n body: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { outline: Cell<Outliner> }\n>(\n (args, state) => {\n try {\n (state.outline.key(\"root\").key(\"children\")).push({\n body: args.body,\n children: [],\n attachments: [],\n });\n\n args.result.set(\n `${state.outline.key(\"root\").key(\"children\").get().length} nodes`,\n );\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nexport default recipe<LLMTestInput, LLMTestResult>(\n \"Outliner\",\n ({ title, expandChat, messages, outline }) => {\n const tools = {\n appendOutlinerNode: {\n description: \"Add a new outliner node.\",\n inputSchema: {\n type: \"object\",\n properties: {\n body: {\n type: \"string\",\n description: \"The title of the new node.\",\n },\n },\n required: [\"body\"],\n } as JSONSchema,\n handler: appendOutlinerNode({ outline }),\n },\n };\n\n const chat = Chat({ messages, tools });\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <ct-hstack justify=\"between\" slot=\"header\">\n <div></div>\n <div>\n <ct-checkbox $checked={expandChat}>Show Chat</ct-checkbox>\n </div>\n </ct-hstack>\n\n <ct-autolayout tabNames={[\"Chat\", \"Tools\"]}>\n <ct-screen>\n <div slot=\"header\">\n <ct-input\n $value={title}\n placeholder=\"Enter title...\"\n />\n </div>\n\n <ct-vscroll flex showScrollbar fadeEdges snapToBottom>\n <ct-vstack data-label=\"Tools\">\n <Page outline={outline} />\n </ct-vstack>\n </ct-vscroll>\n </ct-screen>\n\n {ifElse(\n expandChat,\n chat,\n null,\n )}\n </ct-autolayout>\n </ct-screen>\n ),\n messages,\n };\n },\n);\n"}}}}},"of:baedreigmgcvh4yl4bwa5mobdiqln6dtzz62ok6ctgh2gaiijiarqi3utkm":{"application/json":{"ba4jcbwqf32i3chop2umyg6phmnh6uuwcsqxzucot4vckoq3nyuajjyf5":{"is":{"value":{"name":"/note.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n cell,\n type Default,\n derive,\n generateText,\n handler,\n NAME,\n navigateTo,\n patternTool,\n recipe,\n str,\n Stream,\n UI,\n wish,\n} from \"commontools\";\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\ntype Input = {\n title?: Cell<Default<string, \"Untitled Note\">>;\n content?: Cell<Default<string, \"\">>;\n};\n\n/** Represents a small #note a user took to remember some text. */\ntype Output = {\n mentioned: Default<Array<MentionableCharm>, []>;\n backlinks: MentionableCharm[];\n\n content: Default<string, \"\">;\n grep: Stream<{ query: string }>;\n translate: Stream<{ language: string }>;\n editContent: Stream<{ detail: { value: string } }>;\n};\n\nconst _updateTitle = handler<\n { detail: { value: string } },\n { title: Cell<string> }\n>(\n (event, state) => {\n state.title.set(event.detail?.value ?? \"\");\n },\n);\n\nconst _updateContent = handler<\n { detail: { value: string } },\n { content: Cell<string> }\n>(\n (event, state) => {\n state.content.set(event.detail?.value ?? \"\");\n },\n);\n\nconst handleCharmLinkClick = handler<\n {\n detail: {\n charm: Cell<MentionableCharm>;\n };\n },\n Record<string, never>\n>(({ detail }, _) => {\n return navigateTo(detail.charm);\n});\n\nconst handleNewBacklink = handler<\n {\n detail: {\n text: string;\n charmId: any;\n charm: Cell<MentionableCharm>;\n navigate: boolean;\n };\n },\n {\n mentionable: Cell<MentionableCharm[]>;\n }\n>(({ detail }, { mentionable }) => {\n console.log(\"new charm\", detail.text, detail.charmId);\n\n if (detail.navigate) {\n return navigateTo(detail.charm);\n } else {\n mentionable.push(detail.charm as unknown as MentionableCharm);\n }\n});\n\n/** This edits the content */\nconst handleEditContent = handler<\n { detail: { value: string }; result?: Cell<string> },\n { content: Cell<string> }\n>(\n ({ detail, result }, { content }) => {\n content.set(detail.value);\n result?.set(\"test!\");\n },\n);\n\nconst handleCharmLinkClicked = handler<void, { charm: Cell<MentionableCharm> }>(\n (_, { charm }) => {\n return navigateTo(charm);\n },\n);\n\nfunction schemaifyWish<T>(path: string, def: T) {\n return derive(wish<T>(path) as T, (i) => i ?? def);\n}\n\nconst Note = recipe<Input, Output>(\n \"Note\",\n ({ title, content }) => {\n const mentionable = schemaifyWish<MentionableCharm[]>(\n \"#mentionable\",\n [],\n );\n const mentioned = cell<MentionableCharm[]>([]);\n\n // populated in backlinks-index.tsx\n const backlinks = cell<MentionableCharm[]>([]);\n\n // The only way to serialize a pattern, apparently?\n const pattern = derive(undefined, () => JSON.stringify(Note));\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <div slot=\"header\">\n <ct-input\n $value={title}\n placeholder=\"Enter title...\"\n />\n </div>\n\n <ct-code-editor\n $value={content}\n $mentionable={mentionable}\n $mentioned={mentioned}\n $pattern={pattern}\n onbacklink-click={handleCharmLinkClick({})}\n onbacklink-create={handleNewBacklink({ mentionable })}\n language=\"text/markdown\"\n theme=\"light\"\n wordWrap\n tabIndent\n lineNumbers\n />\n\n <ct-hstack slot=\"footer\">\n {backlinks?.map((charm) => (\n <ct-button\n onClick={handleCharmLinkClicked({ charm })}\n >\n {charm?.[NAME]}\n </ct-button>\n ))}\n </ct-hstack>\n </ct-screen>\n ),\n title,\n content,\n mentioned,\n backlinks,\n grep: patternTool(\n ({ query, content }: { query: string; content: string }) => {\n return derive({ query, content }, ({ query, content }) => {\n return content.split(\"\\n\").filter((c) => c.includes(query));\n });\n },\n { content },\n ),\n translate: patternTool(\n (\n { language, content }: {\n language: string;\n content: string;\n },\n ) => {\n const result = generateText({\n system: str`Translate the content to ${language}.`,\n prompt: str`<to_translate>${content}</to_translate>`,\n });\n\n return derive(result, ({ pending, result }) => {\n if (pending) return undefined;\n if (result == null) return \"Error occured\";\n return result;\n });\n },\n { content },\n ),\n editContent: handleEditContent({ content }),\n };\n },\n);\n\nexport default Note;\n"}}}}},"of:baedreigo5n6mtjvvxsxkwqnzmvrl6vclp2fam46mx7nzykshmgyjtyivgu":{"application/json":{"ba4jcbrirsjwxxl3j76wrhuidg2n25fp4rxs7snvygimxuasbpq2axb7f":{"is":{"value":{"name":"/backlinks-index.tsx","contents":"/// <cts-enable />\nimport { Cell, derive, lift, NAME, OpaqueRef, recipe, UI } from \"commontools\";\n\nexport type MentionableCharm = {\n [NAME]?: string;\n mentioned: MentionableCharm[];\n backlinks: MentionableCharm[];\n};\n\nexport type WriteableBacklinks = {\n mentioned: WriteableBacklinks[];\n backlinks: Cell<WriteableBacklinks[]>;\n};\n\ntype Input = {\n allCharms: MentionableCharm[];\n};\n\ntype Output = {\n mentionable: MentionableCharm[];\n};\n\nconst computeIndex = lift<\n { allCharms: WriteableBacklinks[] },\n void\n>(\n ({ allCharms }) => {\n const cs = allCharms ?? [];\n\n for (const c of cs) {\n c.backlinks?.set([]);\n }\n\n for (const c of cs) {\n const mentions = c.mentioned ?? [];\n for (const m of mentions) {\n m?.backlinks?.push(c);\n }\n }\n },\n);\n\n/**\n * BacklinksIndex builds a map of backlinks across all charms and exposes a\n * unified mentionable list for consumers like editors.\n *\n * Behavior:\n * - Backlinks are computed by scanning each charm's `mentioned` list and\n * mapping mention target -> list of source charms.\n * - Mentionable list is a union of:\n * - every charm in `allCharms`\n * - any items a charm exports via a `mentionable` property\n * (either an array of charms or a Cell of such an array)\n *\n * The backlinks map is keyed by a charm's `content` value (falling back to\n * its `[NAME]`). This mirrors how existing note patterns identify notes when\n * computing backlinks locally.\n */\nconst BacklinksIndex = recipe<Input, Output>(\n \"BacklinksIndex\",\n ({ allCharms }) => {\n computeIndex({\n allCharms: allCharms as unknown as OpaqueRef<WriteableBacklinks[]>,\n });\n\n // Compute mentionable list from allCharms reactively\n const mentionable = derive(allCharms, (charmList) => {\n const cs = charmList ?? [];\n const out: MentionableCharm[] = [];\n for (const c of cs) {\n out.push(c);\n const exported = (c as unknown as {\n mentionable?: MentionableCharm[] | { get?: () => MentionableCharm[] };\n }).mentionable;\n if (Array.isArray(exported)) {\n for (const m of exported) if (m) out.push(m);\n } else if (exported && typeof (exported as any).get === \"function\") {\n const arr = (exported as { get: () => MentionableCharm[] }).get() ??\n [];\n for (const m of arr) if (m) out.push(m);\n }\n }\n return out;\n });\n\n return {\n [NAME]: \"BacklinksIndex\",\n [UI]: undefined,\n mentionable,\n };\n },\n);\n\nexport default BacklinksIndex;\n"}}}}},"of:baedreiam356b7666ueqii5minnknx2nes4rblkbvqnp7ogzjqoislg65du":{"application/json":{"ba4jcbfoua2vmphnb46podjhdafqebq4lcekcmr5qgxyyfzpdbgibof6r":{"is":{"value":{"name":"/chatbot-list-view.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n Default,\n derive,\n handler,\n ID,\n ifElse,\n lift,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n toSchema,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot-note-composed.tsx\";\nimport { ListItem } from \"./common-tools.tsx\";\n\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\ntype CharmEntry = {\n [ID]: string; // randomId is a string\n local_id: string; // same as ID but easier to access\n charm: any;\n};\n\ntype Input = {\n selectedCharm: Default<{ charm: any }, { charm: undefined }>;\n charmsList: Default<CharmEntry[], []>;\n theme?: {\n accentColor: Cell<Default<string, \"#3b82f6\">>;\n fontFace: Cell<Default<string, \"system-ui, -apple-system, sans-serif\">>;\n borderRadius: Cell<Default<string, \"0.5rem\">>;\n };\n};\n\ntype Output = {\n selectedCharm: Default<{ charm: any }, { charm: undefined }>;\n // Expose a mentionable list aggregated from local chat entries\n // Returned as an opaque ref to an array (not a Cell), suitable for\n // upstream aggregators that read exported mentionables.\n mentionable?: MentionableCharm[];\n};\n\nconst removeChat = handler<\n unknown,\n {\n charmsList: Cell<CharmEntry[]>;\n id: string;\n selectedCharm: Cell<Default<{ charm: any }, { charm: undefined }>>;\n }\n>(\n (\n _,\n { charmsList, id, selectedCharm },\n ) => {\n const list = charmsList.get();\n const index = list.findIndex((entry) => entry.local_id === id);\n if (index === -1) return;\n\n const removed = list[index];\n const next = [...list];\n next.splice(index, 1);\n charmsList.set(next);\n\n // If we removed the currently selected charm, choose a new selection.\n const current = selectedCharm.get();\n if (current?.charm === removed.charm) {\n const replacement = next[index] ?? next[index - 1];\n if (replacement) {\n selectedCharm.set({ charm: replacement.charm });\n } else {\n selectedCharm.set({ charm: undefined as unknown as any });\n }\n }\n },\n);\n\n// this will be called whenever charm or selectedCharm changes\n// pass isInitialized to make sure we dont call this each time\n// we change selectedCharm, otherwise creates a loop\nconst storeCharm = lift(\n toSchema<{\n charm: any;\n selectedCharm: Cell<Default<{ charm: any }, { charm: undefined }>>;\n charmsList: Cell<CharmEntry[]>;\n allCharms: Cell<MentionableCharm[]>;\n theme?: {\n accentColor: Default<string, \"#3b82f6\">;\n fontFace: Default<string, \"system-ui, -apple-system, sans-serif\">;\n borderRadius: Default<string, \"0.5rem\">;\n };\n isInitialized: Cell<boolean>;\n }>(),\n undefined,\n ({ charm, selectedCharm, charmsList, isInitialized, allCharms: _ }) => { // Not including `allCharms` is a compile error...\n if (!isInitialized.get()) {\n console.log(\n \"storeCharm storing charm:\",\n charm,\n );\n selectedCharm.set({ charm });\n\n // create the chat charm with a custom name including a random suffix\n const randomId = Math.random().toString(36).substring(2, 10); // Random 8-char string\n charmsList.push({ [ID]: randomId, local_id: randomId, charm });\n\n isInitialized.set(true);\n return charm;\n } else {\n console.log(\"storeCharm: already initialized\");\n }\n return undefined;\n },\n);\n\nconst populateChatList = lift(\n toSchema<{\n charmsList: CharmEntry[];\n allCharms: Cell<any[]>;\n selectedCharm: Cell<{ charm: any }>;\n }>(),\n undefined,\n (\n { charmsList, allCharms, selectedCharm },\n ) => {\n if (charmsList.length === 0) {\n const isInitialized = Cell.of(false);\n return storeCharm({\n charm: Chat({\n title: \"New Chat\",\n messages: [],\n }),\n selectedCharm,\n charmsList,\n allCharms,\n isInitialized: isInitialized as unknown as Cell<boolean>,\n });\n }\n\n return charmsList;\n },\n);\n\nconst createChatRecipe = handler<\n unknown,\n {\n selectedCharm: Cell<{ charm: any }>;\n charmsList: Cell<CharmEntry[]>;\n allCharms: Cell<MentionableCharm[]>;\n }\n>(\n (_, { selectedCharm, charmsList, allCharms }) => {\n const isInitialized = Cell.of(false);\n\n const charm = Chat({\n title: \"New Chat\",\n messages: [],\n });\n // store the charm ref in a cell (pass isInitialized to prevent recursive calls)\n return storeCharm({\n charm,\n selectedCharm,\n charmsList: charmsList as unknown as OpaqueRef<CharmEntry[]>,\n allCharms,\n isInitialized: isInitialized as unknown as Cell<boolean>,\n });\n },\n);\n\nconst selectCharm = handler<\n unknown,\n { selectedCharm: Cell<{ charm: any }>; charm: any }\n>(\n (_, { selectedCharm, charm }) => {\n console.log(\"selectCharm: updating selectedCharm to \", charm);\n selectedCharm.set({ charm });\n return selectedCharm;\n },\n);\n\nconst logCharmsList = lift<\n { charmsList: Cell<CharmEntry[]> },\n Cell<CharmEntry[]>\n>(\n ({ charmsList }) => {\n console.log(\"logCharmsList: \", charmsList.get());\n return charmsList;\n },\n);\n\nconst _handleCharmLinkClicked = handler(\n (_: any, { charm }: { charm: Cell<MentionableCharm> }) => {\n return navigateTo(charm);\n },\n);\n\nconst _merge = lift(\n (\n { allCharms, charmsList }: { allCharms: any[]; charmsList: CharmEntry[] },\n ) => {\n return [...charmsList.map((c) => c.charm), ...allCharms];\n },\n);\n\nconst getSelectedCharm = lift<\n { entry: { charm: any | undefined } },\n {\n chat: unknown;\n list: ListItem[];\n } | undefined\n>(\n ({ entry }) => {\n return entry?.charm;\n },\n);\n\nconst getCharmName = lift(({ charm }: { charm: any }) => {\n return charm?.[NAME] || \"Unknown\";\n});\n\nconst extractLocalMentionable = lift<\n { list: CharmEntry[] },\n MentionableCharm[]\n>(({ list }) => {\n const out: MentionableCharm[] = [];\n for (const entry of list) {\n const c = entry.charm;\n out.push(c.chat);\n }\n return out;\n});\n\n// create the named cell inside the recipe body, so we do it just once\nexport default recipe<Input, Output>(\n \"Launcher\",\n ({ selectedCharm, charmsList, theme }) => {\n const allCharms = derive<MentionableCharm[], MentionableCharm[]>(\n wish<MentionableCharm[]>(\"#allCharms\"),\n (c) => c ?? [],\n );\n logCharmsList({ charmsList: charmsList as unknown as Cell<CharmEntry[]> });\n\n populateChatList({\n selectedCharm: selectedCharm as unknown as Cell<\n Pick<CharmEntry, \"charm\">\n >,\n charmsList,\n allCharms,\n });\n\n const selected = getSelectedCharm({ entry: selectedCharm });\n\n // Aggregate mentionables from the local charms list so that this\n // container exposes its child chat charms as mention targets.\n const localMentionable = extractLocalMentionable({ list: charmsList });\n\n const localTheme = theme ?? {\n accentColor: Cell.of(\"#3b82f6\"),\n fontFace: Cell.of(\"system-ui, -apple-system, sans-serif\"),\n borderRadius: Cell.of(\"0.5rem\"),\n };\n\n return {\n [NAME]: \"Launcher\",\n [UI]: (\n <ct-theme theme={localTheme as any}>\n <ct-screen>\n <div slot=\"header\">\n <ct-toolbar dense sticky>\n <div slot=\"start\">\n <ct-button\n id=\"new-chat-btn\"\n onClick={createChatRecipe({\n selectedCharm,\n charmsList,\n allCharms,\n })}\n >\n Create New Chat\n <ct-kbd>alt+N</ct-kbd>\n </ct-button>\n </div>\n </ct-toolbar>\n\n {/* Keyboard shortcuts */}\n <ct-keybind\n code=\"KeyN\"\n alt\n preventDefault\n onct-keybind={createChatRecipe({\n selectedCharm,\n charmsList,\n allCharms,\n })}\n />\n </div>\n <ct-autolayout\n leftOpen\n rightOpen={false}\n >\n {/* workaround: this seems to correctly start the sub-recipes on a refresh while directly rendering does not */}\n {/* this should be fixed after the builder-refactor (DX1) */}\n <ct-screen>\n <ct-render $cell={selected.chat} />\n </ct-screen>\n\n <aside slot=\"left\">\n <div>\n <ct-heading level={3}>Chat List</ct-heading>\n </div>\n <div role=\"list\">\n {charmsList.map((charmEntry) => (\n <ct-list-item\n onct-activate={selectCharm({\n selectedCharm,\n charm: charmEntry.charm,\n })}\n >\n <span>{getCharmName({ charm: charmEntry.charm })}</span>\n <span slot=\"meta\">{charmEntry.local_id}</span>\n <ct-button\n slot=\"actions\"\n size=\"sm\"\n title=\"Delete Chat\"\n variant=\"destructive\"\n onClick={removeChat({\n charmsList: charmsList as unknown as OpaqueRef<\n CharmEntry[]\n >,\n id: charmEntry.local_id,\n selectedCharm: selectedCharm as unknown as OpaqueRef<\n Default<{ charm: any }, { charm: undefined }>\n >,\n })}\n >\n üóëÔ∏è\n </ct-button>\n </ct-list-item>\n ))}\n </div>\n </aside>\n\n <aside slot=\"right\">\n {ifElse(\n selected,\n <>\n <ct-ct-collapsible>\n <ct-heading slot=\"trigger\" level={5} no-margin>\n List\n </ct-heading>\n <ct-list $value={selected.list} />\n </ct-ct-collapsible>\n </>,\n null,\n )}\n <ct-collapsible>\n <ct-heading slot=\"trigger\" level={5} no-margin>\n Theme\n </ct-heading>\n <ct-vstack style=\"padding: 0.5rem 0; gap: 0.5rem;\">\n <ct-vstack>\n <ct-text>Font Family</ct-text>\n <ct-select\n items={[\n {\n label: \"System\",\n value: \"system-ui, -apple-system, sans-serif\",\n },\n {\n label: \"Monospace\",\n value: \"ui-monospace, Consolas, monospace\",\n },\n {\n label: \"Serif\",\n value: \"Georgia, Times, serif\",\n },\n {\n label: \"Sans Serif\",\n value: \"Arial, Helvetica, sans-serif\",\n },\n ]}\n $value={localTheme.fontFace}\n />\n </ct-vstack>\n\n <ct-vstack>\n <ct-text>Accent Color</ct-text>\n <ct-select\n items={[\n { label: \"Blue\", value: \"#3b82f6\" },\n { label: \"Purple\", value: \"#8b5cf6\" },\n { label: \"Green\", value: \"#10b981\" },\n { label: \"Red\", value: \"#ef4444\" },\n { label: \"Orange\", value: \"#f97316\" },\n { label: \"Pink\", value: \"#ec4899\" },\n { label: \"Indigo\", value: \"#6366f1\" },\n { label: \"Teal\", value: \"#14b8a6\" },\n ]}\n $value={localTheme.accentColor}\n />\n </ct-vstack>\n\n <ct-vstack>\n <ct-text>Border Radius</ct-text>\n <ct-select\n items={[\n { label: \"None\", value: \"0px\" },\n { label: \"Small\", value: \"0.25rem\" },\n { label: \"Medium\", value: \"0.5rem\" },\n { label: \"Large\", value: \"0.75rem\" },\n { label: \"Extra Large\", value: \"1rem\" },\n { label: \"Rounded\", value: \"1.5rem\" },\n ]}\n $value={localTheme.borderRadius}\n />\n </ct-vstack>\n </ct-vstack>\n </ct-collapsible>\n </aside>\n </ct-autolayout>\n </ct-screen>\n </ct-theme>\n ),\n selectedCharm,\n charmsList,\n // Expose the aggregated mentionables for parent-level indexing.\n mentionable: localMentionable,\n };\n },\n);\n"}}}}},"of:baedreiaconf4zx2gafumhuetpthdpy6ncqtjjnlagr2mjfzrtuygwatzju":{"application/json":{"ba4jcbr2plisj6q563jgf3recfb534r7dzbq3p54wcylyo42ywjs6ewn4":{"is":{"value":{"name":"/omnibox-fab.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n computed,\n handler,\n ifElse,\n NAME,\n pattern,\n patternTool,\n UI,\n} from \"commontools\";\nimport Chatbot from \"./chatbot.tsx\";\nimport {\n calculator,\n fetchAndRunPattern,\n listPatternIndex,\n navigateToPattern,\n readWebpage,\n searchWeb,\n} from \"./common-tools.tsx\";\nimport { MentionableCharm } from \"./backlinks-index.tsx\";\n\ninterface OmniboxFABInput {\n mentionable: Cell<MentionableCharm[]>;\n}\n\nconst toggle = handler<any, { value: Cell<boolean> }>((_, { value }) => {\n value.set(!value.get());\n});\n\nconst closeFab = handler<any, { fabExpanded: Cell<boolean> }>(\n (_, { fabExpanded }) => {\n fabExpanded.set(false);\n },\n);\n\nconst dismissPeek = handler<\n any,\n { peekDismissedIndex: Cell<number>; assistantMessageCount: number }\n>((_, { peekDismissedIndex, assistantMessageCount }) => {\n // Store the current assistant message count so we know which message was dismissed\n peekDismissedIndex.set(assistantMessageCount);\n});\n\nexport default pattern<OmniboxFABInput>(\n (_) => {\n const omnibot = Chatbot({\n system:\n \"You are a polite but efficient assistant. Think Star Trek computer - helpful and professional without unnecessary conversation. Let your actions speak for themselves.\\n\\nTool usage priority:\\n- For patterns: listPatternIndex first\\n- For existing pages/notes/content: listRecent or listMentionable to identify what they're referencing\\n- Attach relevant items to conversation after instantiation/retrieval if they support ongoing tasks\\n- Remove attachments when no longer relevant\\n- Search web only as last resort when nothing exists in the space\\n\\nBe matter-of-fact. Prefer action to explanation.\",\n tools: {\n searchWeb: {\n pattern: searchWeb,\n },\n readWebpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n fetchAndRunPattern: patternTool(fetchAndRunPattern),\n listPatternIndex: patternTool(listPatternIndex),\n navigateTo: patternTool(navigateToPattern),\n },\n });\n\n const fabExpanded = Cell.of(false);\n const showHistory = Cell.of(false);\n const peekDismissedIndex = Cell.of(-1); // Track which message index was dismissed\n\n // Derive assistant message count for dismiss tracking\n const assistantMessageCount = computed(() => {\n return omnibot.messages.filter((m) => m.role === \"assistant\").length;\n });\n\n // Derive latest assistant message for peek\n const latestAssistantMessage = computed(() => {\n if (!omnibot.messages || omnibot.messages.length === 0) return null;\n\n for (let i = omnibot.messages.length - 1; i >= 0; i--) {\n const msg = omnibot.messages[i];\n if (msg.role === \"assistant\") {\n const content = typeof msg.content === \"string\"\n ? msg.content\n : msg.content.map((part: any) => {\n if (part.type === \"text\") return part.text;\n return \"\";\n }).join(\"\");\n\n return content;\n }\n }\n return null;\n });\n\n return {\n [NAME]: \"OmniboxFAB\",\n messages: omnibot.messages,\n [UI]: (\n <ct-fab\n expanded={computed(() => fabExpanded.get())}\n variant=\"primary\"\n position=\"bottom-right\"\n pending={omnibot.pending}\n $previewMessage={latestAssistantMessage}\n onct-fab-backdrop-click={closeFab({ fabExpanded })}\n onct-fab-escape={closeFab({ fabExpanded })}\n onClick={toggle({ value: fabExpanded })}\n >\n <div style=\"width: 100%; display: flex; flex-direction: column; max-height: 580px;\">\n {/* Chevron at top - the \"handle\" for the drawer */}\n <div style=\"border-bottom: 1px solid #e5e5e5; flex-shrink: 0;\">\n <ct-chevron-button\n expanded={computed(() => showHistory.get())}\n loading={omnibot.pending}\n onct-toggle={toggle({ value: showHistory })}\n />\n </div>\n\n <div\n style={computed(() => {\n const show = showHistory.get();\n return `flex: ${\n show ? \"1\" : \"0\"\n }; min-height: 0; display: flex; flex-direction: column; opacity: ${\n show ? \"1\" : \"0\"\n }; max-height: ${\n show ? \"480px\" : \"0\"\n }; overflow: hidden; transition: opacity 300ms ease, max-height 400ms cubic-bezier(0.34, 1.56, 0.64, 1), flex 400ms cubic-bezier(0.34, 1.56, 0.64, 1); pointer-events: ${\n show ? \"auto\" : \"none\"\n };`;\n })}\n >\n <div style=\"padding: .25rem; flex-shrink: 0;\">\n {omnibot.ui.attachmentsAndTools}\n </div>\n <div style=\"flex: 1; overflow-y: auto; min-height: 0;\">\n <ct-cell-context $cell={omnibot}>\n {omnibot.ui.chatLog}\n </ct-cell-context>\n </div>\n </div>\n\n {ifElse(\n computed(() => {\n const show = showHistory.get();\n const dismissedIdx = peekDismissedIndex.get();\n return !show && latestAssistantMessage &&\n assistantMessageCount !== dismissedIdx;\n }),\n <div style=\"margin: .5rem; margin-bottom: 0; padding: 0; flex-shrink: 0; position: relative;\">\n <ct-button\n variant=\"ghost\"\n size=\"icon\"\n onClick={dismissPeek({\n peekDismissedIndex,\n assistantMessageCount,\n })}\n style=\"position: absolute; top: 0px; right: 0px; z-index: 1; font-size: 16px;\"\n title=\"Dismiss\"\n >\n √ó\n </ct-button>\n <div\n onClick={toggle({ value: showHistory })}\n style=\"cursor: pointer;\"\n >\n <ct-cell-context $cell={latestAssistantMessage}>\n <ct-chat-message\n role=\"assistant\"\n compact\n content={latestAssistantMessage}\n pending={omnibot.pending}\n />\n </ct-cell-context>\n </div>\n </div>,\n null,\n )}\n\n {/* Prompt input - always at bottom */}\n <div style=\"padding: 0.5rem; flex-shrink: 0;\">\n {omnibot.ui.promptInput}\n </div>\n </div>\n </ct-fab>\n ),\n fabExpanded,\n };\n },\n);\n"}}}}},"of:baedreiayx6zri6trvdy7qaw5ljqys5fb64tlzmd6pih5afnpdyqcnhau5y":{"application/json":{"ba4jcbh6cwld4jbyaablnjvoxyng7o6zltqfvv2yybv6wy5i5ajsielq6":{"is":{"value":{"name":"/chatbot-note-composed.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n cell,\n Default,\n derive,\n handler,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot.tsx\";\nimport Note from \"./note.tsx\";\nimport {\n addListItem,\n calculator,\n ListItem,\n readListItems,\n readWebpage,\n searchWeb,\n} from \"./common-tools.tsx\";\n\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\n\nfunction schemaifyWish<T>(path: string, def: T) {\n return derive(wish<T>(path), (i) => i ?? def);\n}\n\ntype ChatbotNoteInput = {\n title?: Cell<Default<string, \"LLM Test\">>;\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n};\n\ntype ChatbotNoteResult = {\n messages: Default<Array<BuiltInLLMMessage>, []>;\n chat: any;\n list: Default<ListItem[], []>;\n // Optional: expose sub-charms as mentionable targets\n mentionable?: MentionableCharm[];\n};\n\nconst newNote = handler<\n {\n /** The text content of the note */\n title: string;\n content?: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allCharms: Cell<MentionableCharm[]>; index: any }\n>(\n (args, _) => {\n try {\n const n = Note({\n title: args.title,\n content: args.content ?? \"\",\n });\n\n args.result.set(\n `Created note ${args.title}`,\n );\n\n // TODO(bf): we have to navigate here until DX1 lands\n // then we go back to pushing to allCharms\n return navigateTo(n);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst listMentionable = handler<\n {\n /** A cell to store the result text */\n result: Cell<string>;\n },\n { mentionable: MentionableCharm[] }\n>(\n (args, state) => {\n try {\n const namesList = state.mentionable.map((charm) => charm[NAME]);\n args.result.set(JSON.stringify(namesList));\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst readContentByIndex = handler<\n {\n /** A cell to store the result text */\n index: number;\n result: Cell<string>;\n },\n { allNotes: Note[] }\n>(\n (args, state) => {\n try {\n args.result.set(\n state.allNotes[args.index]?.content || \"No content found\",\n );\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\ntype Note = MentionableCharm & { content: string };\nconst editContentByIndex = handler<\n {\n /** The index of the note to edit */\n index: number;\n /** The new text content of the note */\n body: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allNotes: Cell<Note[]> }\n>(\n (args, state) => {\n try {\n const charms = state.allNotes.get();\n if (args.index < 0 || args.index >= charms.length) {\n args.result.set(`Error: Invalid index ${args.index}`);\n return;\n }\n\n state.allNotes.key(args.index).key(\"content\").set(args.body);\n args.result.set(`Updated note at index ${args.index}!`);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst navigateToNote = handler<\n {\n /** The index of the note to navigate to */\n index: number;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allCharms: Cell<MentionableCharm[]> }\n>(\n (args, state) => {\n try {\n const charms = state.allCharms.get();\n if (args.index < 0 || args.index >= charms.length) {\n args.result.set(`Error: Invalid index ${args.index}`);\n return;\n }\n\n const targetCharm = charms[args.index];\n args.result.set(`Navigating to note: ${targetCharm[NAME]}`);\n\n return navigateTo(state.allCharms.key(args.index));\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\ntype BacklinksIndex = {\n mentionable: MentionableCharm[];\n};\n\nexport default recipe<ChatbotNoteInput, ChatbotNoteResult>(\n \"Chatbot + Note\",\n ({ title, messages }) => {\n const allCharms = schemaifyWish<MentionableCharm[]>(\"#allCharms\", []);\n const index = schemaifyWish<BacklinksIndex>(\"#default/backlinksIndex\", {\n mentionable: [],\n });\n const mentionable = schemaifyWish<MentionableCharm[]>(\n \"#mentionable\",\n [],\n );\n\n const list = cell<ListItem[]>([]);\n\n const tools = {\n searchWeb: {\n pattern: searchWeb,\n },\n readWebpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n addListItem: {\n handler: addListItem({ list }),\n },\n readListItems: {\n handler: readListItems({ list }),\n },\n listMentionable: {\n description:\n \"List all mentionable items titles (read the body with readNoteByIndex).\",\n handler: listMentionable({ mentionable }),\n },\n readContentByIndex: {\n description:\n \"Read the content of a mentionable by its index in the listMentionable() list (if possible)\",\n handler: readContentByIndex({\n allNotes: mentionable as unknown as OpaqueRef<Note[]>,\n }),\n },\n editContentByIndex: {\n description:\n \"Edit the content of a mentionable by its index in the listMentionable() list (if possible)\",\n handler: editContentByIndex({\n allNotes: mentionable as unknown as OpaqueRef<Note[]>,\n }),\n },\n navigateToNote: {\n description:\n \"Navigate to a mentionable by its index in the listMentionable() list.\",\n handler: navigateToNote({\n allCharms: allCharms as unknown as OpaqueRef<MentionableCharm[]>,\n }),\n },\n newNote: {\n description: \"Create a new note instance\",\n handler: newNote({\n allCharms: allCharms as unknown as OpaqueRef<MentionableCharm[]>,\n index: index as unknown as OpaqueRef<any>,\n }),\n },\n };\n\n const chat = Chat({ messages, tools });\n\n return {\n [NAME]: title,\n chat,\n messages,\n list,\n // Expose sub-charms as mentionable targets\n mentionable: [chat as unknown as MentionableCharm],\n };\n },\n);\n"}}}}},"of:baedreigayykp34gmnn2ckdu2zfleo6tyu3qqo46p2fifo44yez3htt227i":{"application/json":{"ba4jcbaoftoa3n7imawbtj4kexj4z4mizwaebrix47gtckoqhokb7z36g":{"is":{"value":{"name":"/common-tools.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMTool,\n Cell,\n compileAndRun,\n computed,\n derive,\n fetchData,\n fetchProgram,\n handler,\n ifElse,\n navigateTo,\n recipe,\n} from \"commontools\";\n\n///// COMMON TOOLS (get it?) ////\n\n/**\n * Calculate the result of a mathematical expression.\n * Supports +, -, *, /, and parentheses.\n */\ntype CalculatorRequest = {\n /** The mathematical expression to evaluate. */\n expression: string;\n /** The base to use for the calculation. */\n base?: number;\n};\n\nexport const calculator = recipe<\n CalculatorRequest,\n string | { error: string }\n>(({ expression, base }) => {\n return derive({ expression, base }, ({ expression, base }) => {\n const sanitized = expression.replace(/[^0-9+\\-*/().\\s]/g, \"\");\n let sanitizedBase = Number(base);\n if (\n Number.isNaN(sanitizedBase) || sanitizedBase < 2 || sanitizedBase > 36\n ) {\n sanitizedBase = 10;\n }\n let result;\n try {\n result = Function(\n `\"use strict\"; return Number(${sanitized}).toString(${sanitizedBase})`,\n )();\n } catch (error) {\n result = { error: (error as any)?.message || \"<error>\" };\n }\n return result;\n });\n});\n\n/** Add an item to the list. */\ntype AddListItemRequest = {\n /** The item to add to the list. */\n item: string;\n result: Cell<string>;\n};\n\n/** Read all items from the list. */\ntype ReadListItemsRequest = {\n result: Cell<string>;\n};\n\nexport type ListItem = {\n title: string;\n};\n\nexport const addListItem = handler<\n AddListItemRequest,\n { list: Cell<ListItem[]> }\n>(\n (args, state) => {\n try {\n state.list.push({ title: args.item });\n args.result.set(`${state.list.get().length} items`);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nexport const readListItems = handler<\n ReadListItemsRequest,\n { list: ListItem[] }\n>(\n (args, state) => {\n try {\n const items = state.list;\n if (items.length === 0) {\n args.result.set(\"The list is empty\");\n } else {\n const itemList = items.map((item, index) =>\n `${index + 1}. ${item.title}`\n ).join(\"\\n\");\n args.result.set(`List items (${items.length} total):\\n${itemList}`);\n }\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\n/** Search the web for information. */\ntype SearchQuery = {\n /** The query to search the web for. */\n query: string;\n};\n\ntype SearchWebResult = {\n results: {\n title: string;\n url: string;\n description: string;\n }[];\n};\n\nexport const searchWeb = recipe<\n SearchQuery,\n SearchWebResult | { error: string }\n>(({ query }) => {\n const { result, error } = fetchData<SearchWebResult>({\n url: \"/api/agent-tools/web-search\",\n mode: \"json\",\n options: {\n method: \"POST\",\n headers: {\n \"Content-Type\": \"application/json\",\n },\n body: {\n query,\n max_results: 5,\n },\n },\n });\n\n // TODO(seefeld): Should we instead return { result, error }? Or allocate a\n // special [ERROR] for errors? Ideally this isn't specific to using recipes as\n // tools but a general pattern.\n return ifElse(error, { error }, result);\n});\n\n/** Read and extract content from a specific webpage URL. */\ntype ReadWebRequest = {\n /** The URL of the webpage to read and extract content from. */\n url: string;\n};\n\ntype ReadWebResult = {\n content: string;\n metadata: {\n title?: string;\n author?: string;\n date?: string;\n word_count: number;\n };\n};\n\nexport const readWebpage = recipe<\n ReadWebRequest,\n ReadWebResult | { error: string }\n>(({ url }) => {\n const { result, error } = fetchData<ReadWebResult>({\n url: \"/api/agent-tools/web-read\",\n mode: \"json\",\n options: {\n method: \"POST\",\n headers: {\n \"Content-Type\": \"application/json\",\n },\n body: {\n url,\n max_tokens: 4000,\n include_code: true,\n },\n },\n });\n\n return ifElse(error, { error }, result);\n});\n\ntype ToolsInput = {\n list: ListItem[];\n};\n\nexport default recipe<ToolsInput>(({ list }) => {\n const tools: Record<string, BuiltInLLMTool> = {\n search_web: {\n pattern: searchWeb,\n },\n read_webpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n addListItem: {\n handler: addListItem({ list }),\n },\n };\n\n return { tools, list };\n});\n\n/**\n * `fetchAndRunPattern({ url: \"https://...\", args: {} })`\n *\n * Instantiates patterns (e.g. from listPatternIndex) and returns the cell that\n * contains the results. The instantiated pattern will keep running and updating\n * the cell. Pass the resulting cell to `navigateTo` to show the pattern's UI.\n *\n * Pass in arguments to initialize the pattern. It's especially useful to pass\n * in links to other cells as `{ \"@link\": \"/of:bafe.../path/to/data\" }`.\n */\ntype FetchAndRunPatternInput = {\n url: string;\n args: Cell<any>;\n};\nexport const fetchAndRunPattern = recipe<FetchAndRunPatternInput>(\n ({ url, args }) => {\n const { pending: _fetchPending, result: program, error: _fetchError } =\n fetchProgram({ url });\n\n // Use derive to safely handle when program is undefined/pending\n const compileParams = derive(program, (p) => ({\n files: p?.files ?? [],\n main: p?.main ?? \"\",\n input: args,\n }));\n\n const { pending, result, error } = compileAndRun(compileParams);\n\n return ifElse(\n computed(() => pending || (!result && !error)),\n undefined,\n {\n cell: result,\n error,\n },\n );\n },\n);\n\n/**\n * `navigateTo({ cell: { \"@link\": \"/of:xyz\" } })` - Navigates to that cell's UI\n *\n * Especially useful after instantiating a pattern with fetchAndRunPattern:\n * Pass the \"@link\" you get at `cell` to navigate to the pattern's view.\n */\ntype NavigateToPatternInput = { cell: Cell<any> }; // Hack to steer LLM\nexport const navigateToPattern = recipe<NavigateToPatternInput>(\n ({ cell }) => {\n const success = navigateTo(cell);\n\n return ifElse(success, { success }, undefined);\n },\n);\n\n/**\n * `listPatternIndex()` - Returns the index of patterns.\n *\n * Useful as input to fetchAndRun.\n */\ntype ListPatternIndexInput = Record<string, never>;\n\nexport const listPatternIndex = recipe<ListPatternIndexInput>(\n ({ _ }) => {\n const { pending, result } = fetchData({\n url: \"/api/patterns/index.md\",\n mode: \"text\",\n });\n return ifElse(computed(() => pending || !result), undefined, { result });\n },\n);\n"}}}}}}},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740}}}}}},"revisions":[{"the":"application/commit+json","of":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","cause":{"/":"baedreicvwmhstiamvkdm53tl2wi2tljkwdtw3fmnjaboznkt45nonp4d5y"},"since":20,"is":{"since":20,"transaction":{"cmd":"/memory/transact","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"changes":{"of:baedreiayeohgxjzmij53y63lgaax5ndolqk5ksdwu6xscel4kx2m2s6c3q":{"application/json":{"ba4jcb3hhqhe4nfpe2r3jcw4pjcg5xj6dshwik532oxtibrg3rlpdpyf6":{"is":{"value":{"id":"ba4jcaodz2xu6wbjq3i54qb4dily77jzm6ofnrimmtbv6lcfgexob2umv","program":{"main":"/default-app.tsx","files":[{"/":{"link@1":{"path":[],"id":"of:baedreibr6gycs6dvh32an73hiiddc54zmousvmu7eknp2k75nj2hprzofy"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiczp2strjgmqqr4y4cdhnfgyxpa2p7jh2clgkahly3d2ctbm52z2i"}}},{"/":{"link@1":{"path":[],"id":"of:baedreibkc7zcxdembp7sxpowfbthuiwev4tyyvciuvwzu7egg6323czmh4"}}},{"/":{"link@1":{"path":[],"id":"of:baedreigmgcvh4yl4bwa5mobdiqln6dtzz62ok6ctgh2gaiijiarqi3utkm"}}},{"/":{"link@1":{"path":[],"id":"of:baedreigo5n6mtjvvxsxkwqnzmvrl6vclp2fam46mx7nzykshmgyjtyivgu"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiam356b7666ueqii5minnknx2nes4rblkbvqnp7ogzjqoislg65du"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiaconf4zx2gafumhuetpthdpy6ncqtjjnlagr2mjfzrtuygwatzju"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiayx6zri6trvdy7qaw5ljqys5fb64tlzmd6pih5afnpdyqcnhau5y"}}},{"/":{"link@1":{"path":[],"id":"of:baedreigayykp34gmnn2ckdu2zfleo6tyu3qqo46p2fifo44yez3htt227i"}}}]},"spec":"recipe"}}}}},"of:baedreibr6gycs6dvh32an73hiiddc54zmousvmu7eknp2k75nj2hprzofy":{"application/json":{"ba4jcbvpt5rfkhehimagciotvn3bpzzhz3uo5p4gmlr7l4jlydp7ixyuz":{"is":{"value":{"name":"/default-app.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n handler,\n NAME,\n navigateTo,\n recipe,\n str,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chatbot from \"./chatbot.tsx\";\nimport ChatbotOutliner from \"./chatbot-outliner.tsx\";\nimport { default as Note } from \"./note.tsx\";\nimport BacklinksIndex, { type MentionableCharm } from \"./backlinks-index.tsx\";\nimport ChatList from \"./chatbot-list-view.tsx\";\nimport OmniboxFAB from \"./omnibox-fab.tsx\";\n\ntype MinimalCharm = {\n [NAME]?: string;\n};\n\ntype CharmsListInput = void;\n\n// Recipe returns only UI, no data outputs (only symbol properties)\ninterface CharmsListOutput {\n [key: string]: unknown;\n backlinksIndex: {\n mentionable: MentionableCharm[];\n };\n sidebarUI: unknown;\n fabUI: unknown;\n}\n\nconst _visit = handler<\n Record<string, never>,\n { charm: Cell<MinimalCharm> }\n>((_, state) => {\n return navigateTo(state.charm);\n}, { proxy: true });\n\nconst removeCharm = handler<\n Record<string, never>,\n {\n charm: Cell<MinimalCharm>;\n allCharms: Cell<MinimalCharm[]>;\n }\n>((_, state) => {\n const allCharmsValue = state.allCharms.get();\n const index = allCharmsValue.findIndex((c: any) => state.charm.equals(c));\n\n if (index !== -1) {\n const charmListCopy = [...allCharmsValue];\n console.log(\"charmListCopy before\", charmListCopy.length);\n charmListCopy.splice(index, 1);\n console.log(\"charmListCopy after\", charmListCopy.length);\n state.allCharms.set(charmListCopy);\n }\n});\n\nconst toggleFab = handler<any, { fabExpanded: Cell<boolean> }>(\n (_, { fabExpanded }) => {\n fabExpanded.set(!fabExpanded.get());\n },\n);\n\nconst spawnChatList = handler<void, void>((_, __) => {\n return navigateTo(ChatList({\n selectedCharm: { charm: undefined },\n charmsList: [],\n }));\n});\n\nconst spawnChatbot = handler<void, void>((_, __) => {\n return navigateTo(Chatbot({\n messages: [],\n tools: undefined,\n }));\n});\n\nconst spawnChatbotOutliner = handler<void, void>((_, __) => {\n return navigateTo(ChatbotOutliner({\n title: \"Chatbot Outliner\",\n expandChat: false,\n messages: [],\n outline: {\n root: { body: \"\", children: [], attachments: [] },\n },\n }));\n});\n\nconst spawnNote = handler<void, void>((_, __) => {\n return navigateTo(Note({\n title: \"New Note\",\n content: \"\",\n }));\n});\n\nexport default recipe<CharmsListInput, CharmsListOutput>(\n \"DefaultCharmList\",\n (_) => {\n const { allCharms } = wish<{ allCharms: MentionableCharm[] }>(\"/\");\n const index = BacklinksIndex({ allCharms });\n\n const fab = OmniboxFAB({\n mentionable: index.mentionable as unknown as Cell<MentionableCharm[]>,\n });\n\n return {\n backlinksIndex: index,\n [NAME]: str`DefaultCharmList (${allCharms.length})`,\n [UI]: (\n <ct-screen>\n <ct-keybind\n code=\"KeyN\"\n alt\n preventDefault\n onct-keybind={spawnChatList()}\n />\n <ct-keybind\n code=\"KeyO\"\n meta\n preventDefault\n onct-keybind={toggleFab({ fabExpanded: fab.fabExpanded })}\n />\n <ct-keybind\n code=\"KeyO\"\n ctrl\n preventDefault\n onct-keybind={toggleFab({ fabExpanded: fab.fabExpanded })}\n />\n\n <ct-toolbar slot=\"header\" sticky>\n <div slot=\"start\">\n <ct-button\n onClick={spawnChatList()}\n >\n üìÇ Chat List\n </ct-button>\n <ct-button\n onClick={spawnChatbot()}\n >\n üí¨ Chatbot\n </ct-button>\n <ct-button\n onClick={spawnChatbotOutliner()}\n >\n üìù Chatbot Outliner\n </ct-button>\n <ct-button\n onClick={spawnNote()}\n >\n üìÑ Note\n </ct-button>\n </div>\n </ct-toolbar>\n\n <ct-vscroll flex showScrollbar>\n <ct-vstack gap=\"4\" padding=\"6\">\n <style>\n {`\n .pattern-link {\n cursor: pointer;\n color: inherit;\n text-decoration: none;\n }\n .pattern-link:hover {\n text-decoration: underline;\n }\n `}\n </style>\n <h2>Pages</h2>\n\n <ct-table full-width hover>\n <tbody>\n {allCharms.map((charm) => (\n <tr>\n <td>\n <ct-cell-context $cell={charm}>\n <ct-cell-link $cell={charm} />\n </ct-cell-context>\n </td>\n <td>\n <ct-button\n size=\"sm\"\n variant=\"ghost\"\n onClick={removeCharm({ charm, allCharms })}\n >\n üóëÔ∏è\n </ct-button>\n </td>\n </tr>\n ))}\n </tbody>\n </ct-table>\n </ct-vstack>\n </ct-vscroll>\n </ct-screen>\n ),\n sidebarUI: undefined,\n fabUI: fab[UI],\n };\n },\n);\n"}}}}},"of:baedreiczp2strjgmqqr4y4cdhnfgyxpa2p7jh2clgkahly3d2ctbm52z2i":{"application/json":{"ba4jcbt6ddwmeffgpkxsqtfzakrhur22vsc4gzalizp2kegda7jxjgdpm":{"is":{"value":{"name":"/chatbot.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n computed,\n Default,\n fetchData,\n generateObject,\n handler,\n llmDialog,\n NAME,\n pattern,\n patternTool,\n Stream,\n UI,\n VNode,\n wish,\n} from \"commontools\";\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\n\nfunction schemaifyWish<T>(path: string) {\n return wish<T>(path);\n}\n\nconst sendMessage = handler<\n {\n detail: {\n text: string;\n attachments: Array<PromptAttachment>;\n mentions: Array<any>;\n message: string; // Backward compatibility\n };\n },\n {\n addMessage: Stream<BuiltInLLMMessage>;\n }\n>((event, { addMessage }) => {\n const { text } = event.detail;\n\n // Send the message as-is. Any markdown links like [name](/of:...)\n // are just text that the LLM can parse and use with addAttachment() tool.\n addMessage.send({\n role: \"user\",\n content: [{ type: \"text\" as const, text }],\n });\n});\n\nconst clearChat = handler(\n (\n _: never,\n { messages, pending }: {\n messages: Cell<Array<BuiltInLLMMessage>>;\n pending: Cell<boolean | undefined>;\n },\n ) => {\n messages.set([]);\n pending.set(false);\n },\n);\n\ntype ChatInput = {\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n tools?: any;\n theme?: any;\n system?: string;\n};\n\ntype PromptAttachment = {\n id: string;\n name: string;\n type: \"file\" | \"clipboard\" | \"mention\";\n data?: any; // File | Blob | string\n charm?: any;\n removable?: boolean; // Whether this attachment can be removed\n};\n\ntype ChatOutput = {\n messages: Array<BuiltInLLMMessage>;\n pending: boolean | undefined;\n addMessage: Stream<BuiltInLLMMessage>;\n clearChat: Stream<void>;\n cancelGeneration: Stream<void>;\n title?: string;\n pinnedCells: Array<PromptAttachment>;\n tools: any;\n ui: {\n chatLog: VNode;\n promptInput: VNode;\n attachmentsAndTools: VNode;\n };\n};\n\nexport const TitleGenerator = pattern<\n { model?: string; messages: Array<BuiltInLLMMessage> }\n>(({ model, messages }) => {\n const previewMessage = computed(() => {\n if (!messages || messages.length === 0) return \"\";\n\n const firstMessage = messages[0];\n\n if (!firstMessage) return \"\";\n\n return JSON.stringify(firstMessage);\n });\n\n const { result } = generateObject({\n system:\n \"Generate at most a 3-word title based on the following content, respond with NOTHING but the literal title text.\",\n prompt: previewMessage,\n model,\n schema: {\n type: \"object\",\n properties: {\n title: {\n type: \"string\",\n description: \"The title of the chat\",\n },\n },\n required: [\"title\"],\n },\n });\n\n const title = computed(() => {\n return result?.title || \"Untitled Chat\";\n });\n\n return title;\n});\n\nconst listMentionable = pattern<\n { mentionable: Array<MentionableCharm> },\n { result: Array<{ label: string; cell: Cell<unknown> }> }\n>(\n ({ mentionable }) => {\n const result = mentionable.map((charm) => ({\n label: charm[NAME]!,\n cell: charm,\n }));\n return { result };\n },\n);\n\nconst listRecent = pattern<\n { recentCharms: Array<MentionableCharm> },\n { result: Array<{ label: string; cell: Cell<unknown> }> }\n>(\n ({ recentCharms }) => {\n const namesList = recentCharms.map((charm) => ({\n label: charm[NAME]!,\n cell: charm,\n }));\n return { result: namesList };\n },\n);\n\nexport default pattern<ChatInput, ChatOutput>(\n ({ messages, tools, theme, system }) => {\n const model = Cell.of<string>(\"anthropic:claude-sonnet-4-5\");\n const mentionable = schemaifyWish<MentionableCharm[]>(\"#mentionable\");\n const recentCharms = schemaifyWish<MentionableCharm[]>(\"#recent\");\n\n const assistantTools = {\n listMentionable: patternTool(listMentionable, { mentionable }),\n listRecent: patternTool(listRecent, { recentCharms }),\n };\n\n // Merge static and assistant tools\n const mergedTools = computed(() => ({\n ...tools,\n ...assistantTools,\n }));\n\n const latest = computed(() => recentCharms[0]);\n const latestName = computed(() => recentCharms[0]?.[NAME]);\n\n const {\n addMessage,\n cancelGeneration,\n pending,\n flattenedTools,\n pinnedCells,\n } = llmDialog(\n {\n system: computed(() => {\n return system ?? \"You are a polite but efficient assistant.\";\n }),\n messages,\n tools: mergedTools,\n model,\n context: computed(() => ({\n [latestName]: latest,\n })),\n },\n );\n\n const { result } = fetchData({\n url: \"/api/ai/llm/models\",\n mode: \"json\",\n });\n\n const items = computed(() => {\n if (!result) return [];\n const items = Object.keys(result as any).map((key) => ({\n label: key,\n value: key,\n }));\n return items;\n });\n\n const title = TitleGenerator({ model, messages });\n\n const promptInput = (\n <ct-prompt-input\n slot=\"footer\"\n placeholder=\"Ask the LLM a question...\"\n pending={pending}\n $mentionable={mentionable}\n modelItems={items}\n $model={model}\n onct-send={sendMessage({ addMessage })}\n onct-stop={cancelGeneration}\n />\n );\n\n const chatLog = (\n <ct-vscroll\n style=\"padding: 1rem;\"\n flex\n showScrollbar\n fadeEdges\n snapToBottom\n >\n <ct-chat\n theme={theme}\n $messages={messages}\n pending={pending}\n tools={flattenedTools}\n />\n </ct-vscroll>\n );\n\n const attachmentsAndTools = (\n <ct-hstack align=\"center\" gap=\"1\">\n <ct-cell-context $cell={pinnedCells}>\n <ct-attachments-bar pinnedCells={pinnedCells} />\n </ct-cell-context>\n <ct-tools-chip tools={flattenedTools} />\n <ct-button\n variant=\"pill\"\n type=\"button\"\n title=\"Clear chat\"\n onClick={clearChat({\n messages,\n pending,\n })}\n >\n Clear\n </ct-button>\n </ct-hstack>\n );\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <ct-vstack slot=\"header\">\n <ct-heading level={4}>{title}</ct-heading>\n {attachmentsAndTools}\n </ct-vstack>\n\n {chatLog}\n\n {promptInput}\n </ct-screen>\n ),\n messages,\n pending,\n addMessage,\n clearChat: clearChat({\n messages,\n pending,\n }),\n cancelGeneration,\n title,\n pinnedCells,\n tools: flattenedTools,\n ui: {\n chatLog,\n promptInput,\n attachmentsAndTools,\n },\n };\n },\n);\n"}}}}},"of:baedreibkc7zcxdembp7sxpowfbthuiwev4tyyvciuvwzu7egg6323czmh4":{"application/json":{"ba4jcb4arsk7c7axovlb2gztmprwn45blyew2apjcv6lgh6r3oiuqdcnv":{"is":{"value":{"name":"/chatbot-outliner.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n Default,\n derive,\n handler,\n ifElse,\n JSONSchema,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot.tsx\";\nimport { MentionableCharm } from \"./backlinks-index.tsx\";\n\ntype Charm = any;\n\ntype OutlinerNode = {\n body: Default<string, \"\">;\n children: Default<OutlinerNode[], []>;\n attachments: Default<OpaqueRef<any>[], []>;\n};\n\ntype Outliner = {\n root: OutlinerNode;\n};\n\ntype PageResult = {\n outline: Default<\n Outliner,\n { root: { body: \"\"; children: []; attachments: [] } }\n >;\n};\n\nexport type PageInput = {\n outline: Outliner;\n};\n\nconst handleCharmLinkClick = handler<\n {\n detail: {\n charm: Cell<Charm>;\n };\n },\n Record<string, never>\n>(({ detail }, _) => {\n return navigateTo(detail.charm);\n});\n\nfunction getMentionable() {\n return derive<MentionableCharm[], MentionableCharm[]>(\n wish<MentionableCharm[]>(\"#mentionable\"),\n (i) => i,\n );\n}\n\nexport const Page = recipe<PageInput>(\n \"Page\",\n ({ outline }) => {\n const mentionable = getMentionable();\n\n return {\n [NAME]: \"Page\",\n [UI]: (\n <ct-outliner\n $value={outline as any}\n $mentionable={mentionable}\n oncharm-link-click={handleCharmLinkClick({})}\n />\n ),\n outline,\n };\n },\n);\n\ntype LLMTestInput = {\n title?: Cell<Default<string, \"LLM Test\">>;\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n expandChat?: Cell<Default<boolean, false>>;\n outline?: Default<\n Outliner,\n { root: { body: \"Untitled Page\"; children: []; attachments: [] } }\n >;\n};\n\ntype LLMTestResult = {\n messages: Default<Array<BuiltInLLMMessage>, []>;\n};\n\n// put a node at the end of the outline (by appending to root.children)\nconst appendOutlinerNode = handler<\n {\n /** The text content/title of the outliner node to be appended */\n body: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { outline: Cell<Outliner> }\n>(\n (args, state) => {\n try {\n (state.outline.key(\"root\").key(\"children\")).push({\n body: args.body,\n children: [],\n attachments: [],\n });\n\n args.result.set(\n `${state.outline.key(\"root\").key(\"children\").get().length} nodes`,\n );\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nexport default recipe<LLMTestInput, LLMTestResult>(\n \"Outliner\",\n ({ title, expandChat, messages, outline }) => {\n const tools = {\n appendOutlinerNode: {\n description: \"Add a new outliner node.\",\n inputSchema: {\n type: \"object\",\n properties: {\n body: {\n type: \"string\",\n description: \"The title of the new node.\",\n },\n },\n required: [\"body\"],\n } as JSONSchema,\n handler: appendOutlinerNode({ outline }),\n },\n };\n\n const chat = Chat({ messages, tools });\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <ct-hstack justify=\"between\" slot=\"header\">\n <div></div>\n <div>\n <ct-checkbox $checked={expandChat}>Show Chat</ct-checkbox>\n </div>\n </ct-hstack>\n\n <ct-autolayout tabNames={[\"Chat\", \"Tools\"]}>\n <ct-screen>\n <div slot=\"header\">\n <ct-input\n $value={title}\n placeholder=\"Enter title...\"\n />\n </div>\n\n <ct-vscroll flex showScrollbar fadeEdges snapToBottom>\n <ct-vstack data-label=\"Tools\">\n <Page outline={outline} />\n </ct-vstack>\n </ct-vscroll>\n </ct-screen>\n\n {ifElse(\n expandChat,\n chat,\n null,\n )}\n </ct-autolayout>\n </ct-screen>\n ),\n messages,\n };\n },\n);\n"}}}}},"of:baedreigmgcvh4yl4bwa5mobdiqln6dtzz62ok6ctgh2gaiijiarqi3utkm":{"application/json":{"ba4jcbwqf32i3chop2umyg6phmnh6uuwcsqxzucot4vckoq3nyuajjyf5":{"is":{"value":{"name":"/note.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n cell,\n type Default,\n derive,\n generateText,\n handler,\n NAME,\n navigateTo,\n patternTool,\n recipe,\n str,\n Stream,\n UI,\n wish,\n} from \"commontools\";\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\ntype Input = {\n title?: Cell<Default<string, \"Untitled Note\">>;\n content?: Cell<Default<string, \"\">>;\n};\n\n/** Represents a small #note a user took to remember some text. */\ntype Output = {\n mentioned: Default<Array<MentionableCharm>, []>;\n backlinks: MentionableCharm[];\n\n content: Default<string, \"\">;\n grep: Stream<{ query: string }>;\n translate: Stream<{ language: string }>;\n editContent: Stream<{ detail: { value: string } }>;\n};\n\nconst _updateTitle = handler<\n { detail: { value: string } },\n { title: Cell<string> }\n>(\n (event, state) => {\n state.title.set(event.detail?.value ?? \"\");\n },\n);\n\nconst _updateContent = handler<\n { detail: { value: string } },\n { content: Cell<string> }\n>(\n (event, state) => {\n state.content.set(event.detail?.value ?? \"\");\n },\n);\n\nconst handleCharmLinkClick = handler<\n {\n detail: {\n charm: Cell<MentionableCharm>;\n };\n },\n Record<string, never>\n>(({ detail }, _) => {\n return navigateTo(detail.charm);\n});\n\nconst handleNewBacklink = handler<\n {\n detail: {\n text: string;\n charmId: any;\n charm: Cell<MentionableCharm>;\n navigate: boolean;\n };\n },\n {\n mentionable: Cell<MentionableCharm[]>;\n }\n>(({ detail }, { mentionable }) => {\n console.log(\"new charm\", detail.text, detail.charmId);\n\n if (detail.navigate) {\n return navigateTo(detail.charm);\n } else {\n mentionable.push(detail.charm as unknown as MentionableCharm);\n }\n});\n\n/** This edits the content */\nconst handleEditContent = handler<\n { detail: { value: string }; result?: Cell<string> },\n { content: Cell<string> }\n>(\n ({ detail, result }, { content }) => {\n content.set(detail.value);\n result?.set(\"test!\");\n },\n);\n\nconst handleCharmLinkClicked = handler<void, { charm: Cell<MentionableCharm> }>(\n (_, { charm }) => {\n return navigateTo(charm);\n },\n);\n\nfunction schemaifyWish<T>(path: string, def: T) {\n return derive(wish<T>(path) as T, (i) => i ?? def);\n}\n\nconst Note = recipe<Input, Output>(\n \"Note\",\n ({ title, content }) => {\n const mentionable = schemaifyWish<MentionableCharm[]>(\n \"#mentionable\",\n [],\n );\n const mentioned = cell<MentionableCharm[]>([]);\n\n // populated in backlinks-index.tsx\n const backlinks = cell<MentionableCharm[]>([]);\n\n // The only way to serialize a pattern, apparently?\n const pattern = derive(undefined, () => JSON.stringify(Note));\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <div slot=\"header\">\n <ct-input\n $value={title}\n placeholder=\"Enter title...\"\n />\n </div>\n\n <ct-code-editor\n $value={content}\n $mentionable={mentionable}\n $mentioned={mentioned}\n $pattern={pattern}\n onbacklink-click={handleCharmLinkClick({})}\n onbacklink-create={handleNewBacklink({ mentionable })}\n language=\"text/markdown\"\n theme=\"light\"\n wordWrap\n tabIndent\n lineNumbers\n />\n\n <ct-hstack slot=\"footer\">\n {backlinks?.map((charm) => (\n <ct-button\n onClick={handleCharmLinkClicked({ charm })}\n >\n {charm?.[NAME]}\n </ct-button>\n ))}\n </ct-hstack>\n </ct-screen>\n ),\n title,\n content,\n mentioned,\n backlinks,\n grep: patternTool(\n ({ query, content }: { query: string; content: string }) => {\n return derive({ query, content }, ({ query, content }) => {\n return content.split(\"\\n\").filter((c) => c.includes(query));\n });\n },\n { content },\n ),\n translate: patternTool(\n (\n { language, content }: {\n language: string;\n content: string;\n },\n ) => {\n const result = generateText({\n system: str`Translate the content to ${language}.`,\n prompt: str`<to_translate>${content}</to_translate>`,\n });\n\n return derive(result, ({ pending, result }) => {\n if (pending) return undefined;\n if (result == null) return \"Error occured\";\n return result;\n });\n },\n { content },\n ),\n editContent: handleEditContent({ content }),\n };\n },\n);\n\nexport default Note;\n"}}}}},"of:baedreigo5n6mtjvvxsxkwqnzmvrl6vclp2fam46mx7nzykshmgyjtyivgu":{"application/json":{"ba4jcbrirsjwxxl3j76wrhuidg2n25fp4rxs7snvygimxuasbpq2axb7f":{"is":{"value":{"name":"/backlinks-index.tsx","contents":"/// <cts-enable />\nimport { Cell, derive, lift, NAME, OpaqueRef, recipe, UI } from \"commontools\";\n\nexport type MentionableCharm = {\n [NAME]?: string;\n mentioned: MentionableCharm[];\n backlinks: MentionableCharm[];\n};\n\nexport type WriteableBacklinks = {\n mentioned: WriteableBacklinks[];\n backlinks: Cell<WriteableBacklinks[]>;\n};\n\ntype Input = {\n allCharms: MentionableCharm[];\n};\n\ntype Output = {\n mentionable: MentionableCharm[];\n};\n\nconst computeIndex = lift<\n { allCharms: WriteableBacklinks[] },\n void\n>(\n ({ allCharms }) => {\n const cs = allCharms ?? [];\n\n for (const c of cs) {\n c.backlinks?.set([]);\n }\n\n for (const c of cs) {\n const mentions = c.mentioned ?? [];\n for (const m of mentions) {\n m?.backlinks?.push(c);\n }\n }\n },\n);\n\n/**\n * BacklinksIndex builds a map of backlinks across all charms and exposes a\n * unified mentionable list for consumers like editors.\n *\n * Behavior:\n * - Backlinks are computed by scanning each charm's `mentioned` list and\n * mapping mention target -> list of source charms.\n * - Mentionable list is a union of:\n * - every charm in `allCharms`\n * - any items a charm exports via a `mentionable` property\n * (either an array of charms or a Cell of such an array)\n *\n * The backlinks map is keyed by a charm's `content` value (falling back to\n * its `[NAME]`). This mirrors how existing note patterns identify notes when\n * computing backlinks locally.\n */\nconst BacklinksIndex = recipe<Input, Output>(\n \"BacklinksIndex\",\n ({ allCharms }) => {\n computeIndex({\n allCharms: allCharms as unknown as OpaqueRef<WriteableBacklinks[]>,\n });\n\n // Compute mentionable list from allCharms reactively\n const mentionable = derive(allCharms, (charmList) => {\n const cs = charmList ?? [];\n const out: MentionableCharm[] = [];\n for (const c of cs) {\n out.push(c);\n const exported = (c as unknown as {\n mentionable?: MentionableCharm[] | { get?: () => MentionableCharm[] };\n }).mentionable;\n if (Array.isArray(exported)) {\n for (const m of exported) if (m) out.push(m);\n } else if (exported && typeof (exported as any).get === \"function\") {\n const arr = (exported as { get: () => MentionableCharm[] }).get() ??\n [];\n for (const m of arr) if (m) out.push(m);\n }\n }\n return out;\n });\n\n return {\n [NAME]: \"BacklinksIndex\",\n [UI]: undefined,\n mentionable,\n };\n },\n);\n\nexport default BacklinksIndex;\n"}}}}},"of:baedreiam356b7666ueqii5minnknx2nes4rblkbvqnp7ogzjqoislg65du":{"application/json":{"ba4jcbfoua2vmphnb46podjhdafqebq4lcekcmr5qgxyyfzpdbgibof6r":{"is":{"value":{"name":"/chatbot-list-view.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n Default,\n derive,\n handler,\n ID,\n ifElse,\n lift,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n toSchema,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot-note-composed.tsx\";\nimport { ListItem } from \"./common-tools.tsx\";\n\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\ntype CharmEntry = {\n [ID]: string; // randomId is a string\n local_id: string; // same as ID but easier to access\n charm: any;\n};\n\ntype Input = {\n selectedCharm: Default<{ charm: any }, { charm: undefined }>;\n charmsList: Default<CharmEntry[], []>;\n theme?: {\n accentColor: Cell<Default<string, \"#3b82f6\">>;\n fontFace: Cell<Default<string, \"system-ui, -apple-system, sans-serif\">>;\n borderRadius: Cell<Default<string, \"0.5rem\">>;\n };\n};\n\ntype Output = {\n selectedCharm: Default<{ charm: any }, { charm: undefined }>;\n // Expose a mentionable list aggregated from local chat entries\n // Returned as an opaque ref to an array (not a Cell), suitable for\n // upstream aggregators that read exported mentionables.\n mentionable?: MentionableCharm[];\n};\n\nconst removeChat = handler<\n unknown,\n {\n charmsList: Cell<CharmEntry[]>;\n id: string;\n selectedCharm: Cell<Default<{ charm: any }, { charm: undefined }>>;\n }\n>(\n (\n _,\n { charmsList, id, selectedCharm },\n ) => {\n const list = charmsList.get();\n const index = list.findIndex((entry) => entry.local_id === id);\n if (index === -1) return;\n\n const removed = list[index];\n const next = [...list];\n next.splice(index, 1);\n charmsList.set(next);\n\n // If we removed the currently selected charm, choose a new selection.\n const current = selectedCharm.get();\n if (current?.charm === removed.charm) {\n const replacement = next[index] ?? next[index - 1];\n if (replacement) {\n selectedCharm.set({ charm: replacement.charm });\n } else {\n selectedCharm.set({ charm: undefined as unknown as any });\n }\n }\n },\n);\n\n// this will be called whenever charm or selectedCharm changes\n// pass isInitialized to make sure we dont call this each time\n// we change selectedCharm, otherwise creates a loop\nconst storeCharm = lift(\n toSchema<{\n charm: any;\n selectedCharm: Cell<Default<{ charm: any }, { charm: undefined }>>;\n charmsList: Cell<CharmEntry[]>;\n allCharms: Cell<MentionableCharm[]>;\n theme?: {\n accentColor: Default<string, \"#3b82f6\">;\n fontFace: Default<string, \"system-ui, -apple-system, sans-serif\">;\n borderRadius: Default<string, \"0.5rem\">;\n };\n isInitialized: Cell<boolean>;\n }>(),\n undefined,\n ({ charm, selectedCharm, charmsList, isInitialized, allCharms: _ }) => { // Not including `allCharms` is a compile error...\n if (!isInitialized.get()) {\n console.log(\n \"storeCharm storing charm:\",\n charm,\n );\n selectedCharm.set({ charm });\n\n // create the chat charm with a custom name including a random suffix\n const randomId = Math.random().toString(36).substring(2, 10); // Random 8-char string\n charmsList.push({ [ID]: randomId, local_id: randomId, charm });\n\n isInitialized.set(true);\n return charm;\n } else {\n console.log(\"storeCharm: already initialized\");\n }\n return undefined;\n },\n);\n\nconst populateChatList = lift(\n toSchema<{\n charmsList: CharmEntry[];\n allCharms: Cell<any[]>;\n selectedCharm: Cell<{ charm: any }>;\n }>(),\n undefined,\n (\n { charmsList, allCharms, selectedCharm },\n ) => {\n if (charmsList.length === 0) {\n const isInitialized = Cell.of(false);\n return storeCharm({\n charm: Chat({\n title: \"New Chat\",\n messages: [],\n }),\n selectedCharm,\n charmsList,\n allCharms,\n isInitialized: isInitialized as unknown as Cell<boolean>,\n });\n }\n\n return charmsList;\n },\n);\n\nconst createChatRecipe = handler<\n unknown,\n {\n selectedCharm: Cell<{ charm: any }>;\n charmsList: Cell<CharmEntry[]>;\n allCharms: Cell<MentionableCharm[]>;\n }\n>(\n (_, { selectedCharm, charmsList, allCharms }) => {\n const isInitialized = Cell.of(false);\n\n const charm = Chat({\n title: \"New Chat\",\n messages: [],\n });\n // store the charm ref in a cell (pass isInitialized to prevent recursive calls)\n return storeCharm({\n charm,\n selectedCharm,\n charmsList: charmsList as unknown as OpaqueRef<CharmEntry[]>,\n allCharms,\n isInitialized: isInitialized as unknown as Cell<boolean>,\n });\n },\n);\n\nconst selectCharm = handler<\n unknown,\n { selectedCharm: Cell<{ charm: any }>; charm: any }\n>(\n (_, { selectedCharm, charm }) => {\n console.log(\"selectCharm: updating selectedCharm to \", charm);\n selectedCharm.set({ charm });\n return selectedCharm;\n },\n);\n\nconst logCharmsList = lift<\n { charmsList: Cell<CharmEntry[]> },\n Cell<CharmEntry[]>\n>(\n ({ charmsList }) => {\n console.log(\"logCharmsList: \", charmsList.get());\n return charmsList;\n },\n);\n\nconst _handleCharmLinkClicked = handler(\n (_: any, { charm }: { charm: Cell<MentionableCharm> }) => {\n return navigateTo(charm);\n },\n);\n\nconst _merge = lift(\n (\n { allCharms, charmsList }: { allCharms: any[]; charmsList: CharmEntry[] },\n ) => {\n return [...charmsList.map((c) => c.charm), ...allCharms];\n },\n);\n\nconst getSelectedCharm = lift<\n { entry: { charm: any | undefined } },\n {\n chat: unknown;\n list: ListItem[];\n } | undefined\n>(\n ({ entry }) => {\n return entry?.charm;\n },\n);\n\nconst getCharmName = lift(({ charm }: { charm: any }) => {\n return charm?.[NAME] || \"Unknown\";\n});\n\nconst extractLocalMentionable = lift<\n { list: CharmEntry[] },\n MentionableCharm[]\n>(({ list }) => {\n const out: MentionableCharm[] = [];\n for (const entry of list) {\n const c = entry.charm;\n out.push(c.chat);\n }\n return out;\n});\n\n// create the named cell inside the recipe body, so we do it just once\nexport default recipe<Input, Output>(\n \"Launcher\",\n ({ selectedCharm, charmsList, theme }) => {\n const allCharms = derive<MentionableCharm[], MentionableCharm[]>(\n wish<MentionableCharm[]>(\"#allCharms\"),\n (c) => c ?? [],\n );\n logCharmsList({ charmsList: charmsList as unknown as Cell<CharmEntry[]> });\n\n populateChatList({\n selectedCharm: selectedCharm as unknown as Cell<\n Pick<CharmEntry, \"charm\">\n >,\n charmsList,\n allCharms,\n });\n\n const selected = getSelectedCharm({ entry: selectedCharm });\n\n // Aggregate mentionables from the local charms list so that this\n // container exposes its child chat charms as mention targets.\n const localMentionable = extractLocalMentionable({ list: charmsList });\n\n const localTheme = theme ?? {\n accentColor: Cell.of(\"#3b82f6\"),\n fontFace: Cell.of(\"system-ui, -apple-system, sans-serif\"),\n borderRadius: Cell.of(\"0.5rem\"),\n };\n\n return {\n [NAME]: \"Launcher\",\n [UI]: (\n <ct-theme theme={localTheme as any}>\n <ct-screen>\n <div slot=\"header\">\n <ct-toolbar dense sticky>\n <div slot=\"start\">\n <ct-button\n id=\"new-chat-btn\"\n onClick={createChatRecipe({\n selectedCharm,\n charmsList,\n allCharms,\n })}\n >\n Create New Chat\n <ct-kbd>alt+N</ct-kbd>\n </ct-button>\n </div>\n </ct-toolbar>\n\n {/* Keyboard shortcuts */}\n <ct-keybind\n code=\"KeyN\"\n alt\n preventDefault\n onct-keybind={createChatRecipe({\n selectedCharm,\n charmsList,\n allCharms,\n })}\n />\n </div>\n <ct-autolayout\n leftOpen\n rightOpen={false}\n >\n {/* workaround: this seems to correctly start the sub-recipes on a refresh while directly rendering does not */}\n {/* this should be fixed after the builder-refactor (DX1) */}\n <ct-screen>\n <ct-render $cell={selected.chat} />\n </ct-screen>\n\n <aside slot=\"left\">\n <div>\n <ct-heading level={3}>Chat List</ct-heading>\n </div>\n <div role=\"list\">\n {charmsList.map((charmEntry) => (\n <ct-list-item\n onct-activate={selectCharm({\n selectedCharm,\n charm: charmEntry.charm,\n })}\n >\n <span>{getCharmName({ charm: charmEntry.charm })}</span>\n <span slot=\"meta\">{charmEntry.local_id}</span>\n <ct-button\n slot=\"actions\"\n size=\"sm\"\n title=\"Delete Chat\"\n variant=\"destructive\"\n onClick={removeChat({\n charmsList: charmsList as unknown as OpaqueRef<\n CharmEntry[]\n >,\n id: charmEntry.local_id,\n selectedCharm: selectedCharm as unknown as OpaqueRef<\n Default<{ charm: any }, { charm: undefined }>\n >,\n })}\n >\n üóëÔ∏è\n </ct-button>\n </ct-list-item>\n ))}\n </div>\n </aside>\n\n <aside slot=\"right\">\n {ifElse(\n selected,\n <>\n <ct-ct-collapsible>\n <ct-heading slot=\"trigger\" level={5} no-margin>\n List\n </ct-heading>\n <ct-list $value={selected.list} />\n </ct-ct-collapsible>\n </>,\n null,\n )}\n <ct-collapsible>\n <ct-heading slot=\"trigger\" level={5} no-margin>\n Theme\n </ct-heading>\n <ct-vstack style=\"padding: 0.5rem 0; gap: 0.5rem;\">\n <ct-vstack>\n <ct-text>Font Family</ct-text>\n <ct-select\n items={[\n {\n label: \"System\",\n value: \"system-ui, -apple-system, sans-serif\",\n },\n {\n label: \"Monospace\",\n value: \"ui-monospace, Consolas, monospace\",\n },\n {\n label: \"Serif\",\n value: \"Georgia, Times, serif\",\n },\n {\n label: \"Sans Serif\",\n value: \"Arial, Helvetica, sans-serif\",\n },\n ]}\n $value={localTheme.fontFace}\n />\n </ct-vstack>\n\n <ct-vstack>\n <ct-text>Accent Color</ct-text>\n <ct-select\n items={[\n { label: \"Blue\", value: \"#3b82f6\" },\n { label: \"Purple\", value: \"#8b5cf6\" },\n { label: \"Green\", value: \"#10b981\" },\n { label: \"Red\", value: \"#ef4444\" },\n { label: \"Orange\", value: \"#f97316\" },\n { label: \"Pink\", value: \"#ec4899\" },\n { label: \"Indigo\", value: \"#6366f1\" },\n { label: \"Teal\", value: \"#14b8a6\" },\n ]}\n $value={localTheme.accentColor}\n />\n </ct-vstack>\n\n <ct-vstack>\n <ct-text>Border Radius</ct-text>\n <ct-select\n items={[\n { label: \"None\", value: \"0px\" },\n { label: \"Small\", value: \"0.25rem\" },\n { label: \"Medium\", value: \"0.5rem\" },\n { label: \"Large\", value: \"0.75rem\" },\n { label: \"Extra Large\", value: \"1rem\" },\n { label: \"Rounded\", value: \"1.5rem\" },\n ]}\n $value={localTheme.borderRadius}\n />\n </ct-vstack>\n </ct-vstack>\n </ct-collapsible>\n </aside>\n </ct-autolayout>\n </ct-screen>\n </ct-theme>\n ),\n selectedCharm,\n charmsList,\n // Expose the aggregated mentionables for parent-level indexing.\n mentionable: localMentionable,\n };\n },\n);\n"}}}}},"of:baedreiaconf4zx2gafumhuetpthdpy6ncqtjjnlagr2mjfzrtuygwatzju":{"application/json":{"ba4jcbr2plisj6q563jgf3recfb534r7dzbq3p54wcylyo42ywjs6ewn4":{"is":{"value":{"name":"/omnibox-fab.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n computed,\n handler,\n ifElse,\n NAME,\n pattern,\n patternTool,\n UI,\n} from \"commontools\";\nimport Chatbot from \"./chatbot.tsx\";\nimport {\n calculator,\n fetchAndRunPattern,\n listPatternIndex,\n navigateToPattern,\n readWebpage,\n searchWeb,\n} from \"./common-tools.tsx\";\nimport { MentionableCharm } from \"./backlinks-index.tsx\";\n\ninterface OmniboxFABInput {\n mentionable: Cell<MentionableCharm[]>;\n}\n\nconst toggle = handler<any, { value: Cell<boolean> }>((_, { value }) => {\n value.set(!value.get());\n});\n\nconst closeFab = handler<any, { fabExpanded: Cell<boolean> }>(\n (_, { fabExpanded }) => {\n fabExpanded.set(false);\n },\n);\n\nconst dismissPeek = handler<\n any,\n { peekDismissedIndex: Cell<number>; assistantMessageCount: number }\n>((_, { peekDismissedIndex, assistantMessageCount }) => {\n // Store the current assistant message count so we know which message was dismissed\n peekDismissedIndex.set(assistantMessageCount);\n});\n\nexport default pattern<OmniboxFABInput>(\n (_) => {\n const omnibot = Chatbot({\n system:\n \"You are a polite but efficient assistant. Think Star Trek computer - helpful and professional without unnecessary conversation. Let your actions speak for themselves.\\n\\nTool usage priority:\\n- For patterns: listPatternIndex first\\n- For existing pages/notes/content: listRecent or listMentionable to identify what they're referencing\\n- Attach relevant items to conversation after instantiation/retrieval if they support ongoing tasks\\n- Remove attachments when no longer relevant\\n- Search web only as last resort when nothing exists in the space\\n\\nBe matter-of-fact. Prefer action to explanation.\",\n tools: {\n searchWeb: {\n pattern: searchWeb,\n },\n readWebpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n fetchAndRunPattern: patternTool(fetchAndRunPattern),\n listPatternIndex: patternTool(listPatternIndex),\n navigateTo: patternTool(navigateToPattern),\n },\n });\n\n const fabExpanded = Cell.of(false);\n const showHistory = Cell.of(false);\n const peekDismissedIndex = Cell.of(-1); // Track which message index was dismissed\n\n // Derive assistant message count for dismiss tracking\n const assistantMessageCount = computed(() => {\n return omnibot.messages.filter((m) => m.role === \"assistant\").length;\n });\n\n // Derive latest assistant message for peek\n const latestAssistantMessage = computed(() => {\n if (!omnibot.messages || omnibot.messages.length === 0) return null;\n\n for (let i = omnibot.messages.length - 1; i >= 0; i--) {\n const msg = omnibot.messages[i];\n if (msg.role === \"assistant\") {\n const content = typeof msg.content === \"string\"\n ? msg.content\n : msg.content.map((part: any) => {\n if (part.type === \"text\") return part.text;\n return \"\";\n }).join(\"\");\n\n return content;\n }\n }\n return null;\n });\n\n return {\n [NAME]: \"OmniboxFAB\",\n messages: omnibot.messages,\n [UI]: (\n <ct-fab\n expanded={computed(() => fabExpanded.get())}\n variant=\"primary\"\n position=\"bottom-right\"\n pending={omnibot.pending}\n $previewMessage={latestAssistantMessage}\n onct-fab-backdrop-click={closeFab({ fabExpanded })}\n onct-fab-escape={closeFab({ fabExpanded })}\n onClick={toggle({ value: fabExpanded })}\n >\n <div style=\"width: 100%; display: flex; flex-direction: column; max-height: 580px;\">\n {/* Chevron at top - the \"handle\" for the drawer */}\n <div style=\"border-bottom: 1px solid #e5e5e5; flex-shrink: 0;\">\n <ct-chevron-button\n expanded={computed(() => showHistory.get())}\n loading={omnibot.pending}\n onct-toggle={toggle({ value: showHistory })}\n />\n </div>\n\n <div\n style={computed(() => {\n const show = showHistory.get();\n return `flex: ${\n show ? \"1\" : \"0\"\n }; min-height: 0; display: flex; flex-direction: column; opacity: ${\n show ? \"1\" : \"0\"\n }; max-height: ${\n show ? \"480px\" : \"0\"\n }; overflow: hidden; transition: opacity 300ms ease, max-height 400ms cubic-bezier(0.34, 1.56, 0.64, 1), flex 400ms cubic-bezier(0.34, 1.56, 0.64, 1); pointer-events: ${\n show ? \"auto\" : \"none\"\n };`;\n })}\n >\n <div style=\"padding: .25rem; flex-shrink: 0;\">\n {omnibot.ui.attachmentsAndTools}\n </div>\n <div style=\"flex: 1; overflow-y: auto; min-height: 0;\">\n <ct-cell-context $cell={omnibot}>\n {omnibot.ui.chatLog}\n </ct-cell-context>\n </div>\n </div>\n\n {ifElse(\n computed(() => {\n const show = showHistory.get();\n const dismissedIdx = peekDismissedIndex.get();\n return !show && latestAssistantMessage &&\n assistantMessageCount !== dismissedIdx;\n }),\n <div style=\"margin: .5rem; margin-bottom: 0; padding: 0; flex-shrink: 0; position: relative;\">\n <ct-button\n variant=\"ghost\"\n size=\"icon\"\n onClick={dismissPeek({\n peekDismissedIndex,\n assistantMessageCount,\n })}\n style=\"position: absolute; top: 0px; right: 0px; z-index: 1; font-size: 16px;\"\n title=\"Dismiss\"\n >\n √ó\n </ct-button>\n <div\n onClick={toggle({ value: showHistory })}\n style=\"cursor: pointer;\"\n >\n <ct-cell-context $cell={latestAssistantMessage}>\n <ct-chat-message\n role=\"assistant\"\n compact\n content={latestAssistantMessage}\n pending={omnibot.pending}\n />\n </ct-cell-context>\n </div>\n </div>,\n null,\n )}\n\n {/* Prompt input - always at bottom */}\n <div style=\"padding: 0.5rem; flex-shrink: 0;\">\n {omnibot.ui.promptInput}\n </div>\n </div>\n </ct-fab>\n ),\n fabExpanded,\n };\n },\n);\n"}}}}},"of:baedreiayx6zri6trvdy7qaw5ljqys5fb64tlzmd6pih5afnpdyqcnhau5y":{"application/json":{"ba4jcbh6cwld4jbyaablnjvoxyng7o6zltqfvv2yybv6wy5i5ajsielq6":{"is":{"value":{"name":"/chatbot-note-composed.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n cell,\n Default,\n derive,\n handler,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot.tsx\";\nimport Note from \"./note.tsx\";\nimport {\n addListItem,\n calculator,\n ListItem,\n readListItems,\n readWebpage,\n searchWeb,\n} from \"./common-tools.tsx\";\n\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\n\nfunction schemaifyWish<T>(path: string, def: T) {\n return derive(wish<T>(path), (i) => i ?? def);\n}\n\ntype ChatbotNoteInput = {\n title?: Cell<Default<string, \"LLM Test\">>;\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n};\n\ntype ChatbotNoteResult = {\n messages: Default<Array<BuiltInLLMMessage>, []>;\n chat: any;\n list: Default<ListItem[], []>;\n // Optional: expose sub-charms as mentionable targets\n mentionable?: MentionableCharm[];\n};\n\nconst newNote = handler<\n {\n /** The text content of the note */\n title: string;\n content?: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allCharms: Cell<MentionableCharm[]>; index: any }\n>(\n (args, _) => {\n try {\n const n = Note({\n title: args.title,\n content: args.content ?? \"\",\n });\n\n args.result.set(\n `Created note ${args.title}`,\n );\n\n // TODO(bf): we have to navigate here until DX1 lands\n // then we go back to pushing to allCharms\n return navigateTo(n);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst listMentionable = handler<\n {\n /** A cell to store the result text */\n result: Cell<string>;\n },\n { mentionable: MentionableCharm[] }\n>(\n (args, state) => {\n try {\n const namesList = state.mentionable.map((charm) => charm[NAME]);\n args.result.set(JSON.stringify(namesList));\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst readContentByIndex = handler<\n {\n /** A cell to store the result text */\n index: number;\n result: Cell<string>;\n },\n { allNotes: Note[] }\n>(\n (args, state) => {\n try {\n args.result.set(\n state.allNotes[args.index]?.content || \"No content found\",\n );\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\ntype Note = MentionableCharm & { content: string };\nconst editContentByIndex = handler<\n {\n /** The index of the note to edit */\n index: number;\n /** The new text content of the note */\n body: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allNotes: Cell<Note[]> }\n>(\n (args, state) => {\n try {\n const charms = state.allNotes.get();\n if (args.index < 0 || args.index >= charms.length) {\n args.result.set(`Error: Invalid index ${args.index}`);\n return;\n }\n\n state.allNotes.key(args.index).key(\"content\").set(args.body);\n args.result.set(`Updated note at index ${args.index}!`);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst navigateToNote = handler<\n {\n /** The index of the note to navigate to */\n index: number;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allCharms: Cell<MentionableCharm[]> }\n>(\n (args, state) => {\n try {\n const charms = state.allCharms.get();\n if (args.index < 0 || args.index >= charms.length) {\n args.result.set(`Error: Invalid index ${args.index}`);\n return;\n }\n\n const targetCharm = charms[args.index];\n args.result.set(`Navigating to note: ${targetCharm[NAME]}`);\n\n return navigateTo(state.allCharms.key(args.index));\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\ntype BacklinksIndex = {\n mentionable: MentionableCharm[];\n};\n\nexport default recipe<ChatbotNoteInput, ChatbotNoteResult>(\n \"Chatbot + Note\",\n ({ title, messages }) => {\n const allCharms = schemaifyWish<MentionableCharm[]>(\"#allCharms\", []);\n const index = schemaifyWish<BacklinksIndex>(\"#default/backlinksIndex\", {\n mentionable: [],\n });\n const mentionable = schemaifyWish<MentionableCharm[]>(\n \"#mentionable\",\n [],\n );\n\n const list = cell<ListItem[]>([]);\n\n const tools = {\n searchWeb: {\n pattern: searchWeb,\n },\n readWebpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n addListItem: {\n handler: addListItem({ list }),\n },\n readListItems: {\n handler: readListItems({ list }),\n },\n listMentionable: {\n description:\n \"List all mentionable items titles (read the body with readNoteByIndex).\",\n handler: listMentionable({ mentionable }),\n },\n readContentByIndex: {\n description:\n \"Read the content of a mentionable by its index in the listMentionable() list (if possible)\",\n handler: readContentByIndex({\n allNotes: mentionable as unknown as OpaqueRef<Note[]>,\n }),\n },\n editContentByIndex: {\n description:\n \"Edit the content of a mentionable by its index in the listMentionable() list (if possible)\",\n handler: editContentByIndex({\n allNotes: mentionable as unknown as OpaqueRef<Note[]>,\n }),\n },\n navigateToNote: {\n description:\n \"Navigate to a mentionable by its index in the listMentionable() list.\",\n handler: navigateToNote({\n allCharms: allCharms as unknown as OpaqueRef<MentionableCharm[]>,\n }),\n },\n newNote: {\n description: \"Create a new note instance\",\n handler: newNote({\n allCharms: allCharms as unknown as OpaqueRef<MentionableCharm[]>,\n index: index as unknown as OpaqueRef<any>,\n }),\n },\n };\n\n const chat = Chat({ messages, tools });\n\n return {\n [NAME]: title,\n chat,\n messages,\n list,\n // Expose sub-charms as mentionable targets\n mentionable: [chat as unknown as MentionableCharm],\n };\n },\n);\n"}}}}},"of:baedreigayykp34gmnn2ckdu2zfleo6tyu3qqo46p2fifo44yez3htt227i":{"application/json":{"ba4jcbaoftoa3n7imawbtj4kexj4z4mizwaebrix47gtckoqhokb7z36g":{"is":{"value":{"name":"/common-tools.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMTool,\n Cell,\n compileAndRun,\n computed,\n derive,\n fetchData,\n fetchProgram,\n handler,\n ifElse,\n navigateTo,\n recipe,\n} from \"commontools\";\n\n///// COMMON TOOLS (get it?) ////\n\n/**\n * Calculate the result of a mathematical expression.\n * Supports +, -, *, /, and parentheses.\n */\ntype CalculatorRequest = {\n /** The mathematical expression to evaluate. */\n expression: string;\n /** The base to use for the calculation. */\n base?: number;\n};\n\nexport const calculator = recipe<\n CalculatorRequest,\n string | { error: string }\n>(({ expression, base }) => {\n return derive({ expression, base }, ({ expression, base }) => {\n const sanitized = expression.replace(/[^0-9+\\-*/().\\s]/g, \"\");\n let sanitizedBase = Number(base);\n if (\n Number.isNaN(sanitizedBase) || sanitizedBase < 2 || sanitizedBase > 36\n ) {\n sanitizedBase = 10;\n }\n let result;\n try {\n result = Function(\n `\"use strict\"; return Number(${sanitized}).toString(${sanitizedBase})`,\n )();\n } catch (error) {\n result = { error: (error as any)?.message || \"<error>\" };\n }\n return result;\n });\n});\n\n/** Add an item to the list. */\ntype AddListItemRequest = {\n /** The item to add to the list. */\n item: string;\n result: Cell<string>;\n};\n\n/** Read all items from the list. */\ntype ReadListItemsRequest = {\n result: Cell<string>;\n};\n\nexport type ListItem = {\n title: string;\n};\n\nexport const addListItem = handler<\n AddListItemRequest,\n { list: Cell<ListItem[]> }\n>(\n (args, state) => {\n try {\n state.list.push({ title: args.item });\n args.result.set(`${state.list.get().length} items`);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nexport const readListItems = handler<\n ReadListItemsRequest,\n { list: ListItem[] }\n>(\n (args, state) => {\n try {\n const items = state.list;\n if (items.length === 0) {\n args.result.set(\"The list is empty\");\n } else {\n const itemList = items.map((item, index) =>\n `${index + 1}. ${item.title}`\n ).join(\"\\n\");\n args.result.set(`List items (${items.length} total):\\n${itemList}`);\n }\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\n/** Search the web for information. */\ntype SearchQuery = {\n /** The query to search the web for. */\n query: string;\n};\n\ntype SearchWebResult = {\n results: {\n title: string;\n url: string;\n description: string;\n }[];\n};\n\nexport const searchWeb = recipe<\n SearchQuery,\n SearchWebResult | { error: string }\n>(({ query }) => {\n const { result, error } = fetchData<SearchWebResult>({\n url: \"/api/agent-tools/web-search\",\n mode: \"json\",\n options: {\n method: \"POST\",\n headers: {\n \"Content-Type\": \"application/json\",\n },\n body: {\n query,\n max_results: 5,\n },\n },\n });\n\n // TODO(seefeld): Should we instead return { result, error }? Or allocate a\n // special [ERROR] for errors? Ideally this isn't specific to using recipes as\n // tools but a general pattern.\n return ifElse(error, { error }, result);\n});\n\n/** Read and extract content from a specific webpage URL. */\ntype ReadWebRequest = {\n /** The URL of the webpage to read and extract content from. */\n url: string;\n};\n\ntype ReadWebResult = {\n content: string;\n metadata: {\n title?: string;\n author?: string;\n date?: string;\n word_count: number;\n };\n};\n\nexport const readWebpage = recipe<\n ReadWebRequest,\n ReadWebResult | { error: string }\n>(({ url }) => {\n const { result, error } = fetchData<ReadWebResult>({\n url: \"/api/agent-tools/web-read\",\n mode: \"json\",\n options: {\n method: \"POST\",\n headers: {\n \"Content-Type\": \"application/json\",\n },\n body: {\n url,\n max_tokens: 4000,\n include_code: true,\n },\n },\n });\n\n return ifElse(error, { error }, result);\n});\n\ntype ToolsInput = {\n list: ListItem[];\n};\n\nexport default recipe<ToolsInput>(({ list }) => {\n const tools: Record<string, BuiltInLLMTool> = {\n search_web: {\n pattern: searchWeb,\n },\n read_webpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n addListItem: {\n handler: addListItem({ list }),\n },\n };\n\n return { tools, list };\n});\n\n/**\n * `fetchAndRunPattern({ url: \"https://...\", args: {} })`\n *\n * Instantiates patterns (e.g. from listPatternIndex) and returns the cell that\n * contains the results. The instantiated pattern will keep running and updating\n * the cell. Pass the resulting cell to `navigateTo` to show the pattern's UI.\n *\n * Pass in arguments to initialize the pattern. It's especially useful to pass\n * in links to other cells as `{ \"@link\": \"/of:bafe.../path/to/data\" }`.\n */\ntype FetchAndRunPatternInput = {\n url: string;\n args: Cell<any>;\n};\nexport const fetchAndRunPattern = recipe<FetchAndRunPatternInput>(\n ({ url, args }) => {\n const { pending: _fetchPending, result: program, error: _fetchError } =\n fetchProgram({ url });\n\n // Use derive to safely handle when program is undefined/pending\n const compileParams = derive(program, (p) => ({\n files: p?.files ?? [],\n main: p?.main ?? \"\",\n input: args,\n }));\n\n const { pending, result, error } = compileAndRun(compileParams);\n\n return ifElse(\n computed(() => pending || (!result && !error)),\n undefined,\n {\n cell: result,\n error,\n },\n );\n },\n);\n\n/**\n * `navigateTo({ cell: { \"@link\": \"/of:xyz\" } })` - Navigates to that cell's UI\n *\n * Especially useful after instantiating a pattern with fetchAndRunPattern:\n * Pass the \"@link\" you get at `cell` to navigate to the pattern's view.\n */\ntype NavigateToPatternInput = { cell: Cell<any> }; // Hack to steer LLM\nexport const navigateToPattern = recipe<NavigateToPatternInput>(\n ({ cell }) => {\n const success = navigateTo(cell);\n\n return ifElse(success, { success }, undefined);\n },\n);\n\n/**\n * `listPatternIndex()` - Returns the index of patterns.\n *\n * Useful as input to fetchAndRun.\n */\ntype ListPatternIndexInput = Record<string, never>;\n\nexport const listPatternIndex = recipe<ListPatternIndexInput>(\n ({ _ }) => {\n const { pending, result } = fetchData({\n url: \"/api/patterns/index.md\",\n mode: \"text\",\n });\n return ifElse(computed(() => pending || !result), undefined, { result });\n },\n);\n"}}}}}}},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740}}}]}}	124010	
16:19:04.511
{"the":"task/return","of":"job:ba4jcb5wyzv3hf3hcmim4jsbumrrcrp74q6hcwc2v2wjpv3hif4iv4oa3","is":{"ok":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{"application/commit+json":{"ba4jcavntb4u2adfkq3ho426vsgu22kvq45wzldkialwlku7hlltl7a7o":{"is":{"since":20,"transaction":{"cmd":"/memory/transact","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"changes":{"of:baedreiayeohgxjzmij53y63lgaax5ndolqk5ksdwu6xscel4kx2m2s6c3q":{"application/json":{"ba4jcb3hhqhe4nfpe2r3jcw4pjcg5xj6dshwik532oxtibrg3rlpdpyf6":{"is":{"value":{"id":"ba4jcaodz2xu6wbjq3i54qb4dily77jzm6ofnrimmtbv6lcfgexob2umv","program":{"main":"/default-app.tsx","files":[{"/":{"link@1":{"path":[],"id":"of:baedreibr6gycs6dvh32an73hiiddc54zmousvmu7eknp2k75nj2hprzofy"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiczp2strjgmqqr4y4cdhnfgyxpa2p7jh2clgkahly3d2ctbm52z2i"}}},{"/":{"link@1":{"path":[],"id":"of:baedreibkc7zcxdembp7sxpowfbthuiwev4tyyvciuvwzu7egg6323czmh4"}}},{"/":{"link@1":{"path":[],"id":"of:baedreigmgcvh4yl4bwa5mobdiqln6dtzz62ok6ctgh2gaiijiarqi3utkm"}}},{"/":{"link@1":{"path":[],"id":"of:baedreigo5n6mtjvvxsxkwqnzmvrl6vclp2fam46mx7nzykshmgyjtyivgu"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiam356b7666ueqii5minnknx2nes4rblkbvqnp7ogzjqoislg65du"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiaconf4zx2gafumhuetpthdpy6ncqtjjnlagr2mjfzrtuygwatzju"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiayx6zri6trvdy7qaw5ljqys5fb64tlzmd6pih5afnpdyqcnhau5y"}}},{"/":{"link@1":{"path":[],"id":"of:baedreigayykp34gmnn2ckdu2zfleo6tyu3qqo46p2fifo44yez3htt227i"}}}]},"spec":"recipe"}}}}},"of:baedreibr6gycs6dvh32an73hiiddc54zmousvmu7eknp2k75nj2hprzofy":{"application/json":{"ba4jcbvpt5rfkhehimagciotvn3bpzzhz3uo5p4gmlr7l4jlydp7ixyuz":{"is":{"value":{"name":"/default-app.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n handler,\n NAME,\n navigateTo,\n recipe,\n str,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chatbot from \"./chatbot.tsx\";\nimport ChatbotOutliner from \"./chatbot-outliner.tsx\";\nimport { default as Note } from \"./note.tsx\";\nimport BacklinksIndex, { type MentionableCharm } from \"./backlinks-index.tsx\";\nimport ChatList from \"./chatbot-list-view.tsx\";\nimport OmniboxFAB from \"./omnibox-fab.tsx\";\n\ntype MinimalCharm = {\n [NAME]?: string;\n};\n\ntype CharmsListInput = void;\n\n// Recipe returns only UI, no data outputs (only symbol properties)\ninterface CharmsListOutput {\n [key: string]: unknown;\n backlinksIndex: {\n mentionable: MentionableCharm[];\n };\n sidebarUI: unknown;\n fabUI: unknown;\n}\n\nconst _visit = handler<\n Record<string, never>,\n { charm: Cell<MinimalCharm> }\n>((_, state) => {\n return navigateTo(state.charm);\n}, { proxy: true });\n\nconst removeCharm = handler<\n Record<string, never>,\n {\n charm: Cell<MinimalCharm>;\n allCharms: Cell<MinimalCharm[]>;\n }\n>((_, state) => {\n const allCharmsValue = state.allCharms.get();\n const index = allCharmsValue.findIndex((c: any) => state.charm.equals(c));\n\n if (index !== -1) {\n const charmListCopy = [...allCharmsValue];\n console.log(\"charmListCopy before\", charmListCopy.length);\n charmListCopy.splice(index, 1);\n console.log(\"charmListCopy after\", charmListCopy.length);\n state.allCharms.set(charmListCopy);\n }\n});\n\nconst toggleFab = handler<any, { fabExpanded: Cell<boolean> }>(\n (_, { fabExpanded }) => {\n fabExpanded.set(!fabExpanded.get());\n },\n);\n\nconst spawnChatList = handler<void, void>((_, __) => {\n return navigateTo(ChatList({\n selectedCharm: { charm: undefined },\n charmsList: [],\n }));\n});\n\nconst spawnChatbot = handler<void, void>((_, __) => {\n return navigateTo(Chatbot({\n messages: [],\n tools: undefined,\n }));\n});\n\nconst spawnChatbotOutliner = handler<void, void>((_, __) => {\n return navigateTo(ChatbotOutliner({\n title: \"Chatbot Outliner\",\n expandChat: false,\n messages: [],\n outline: {\n root: { body: \"\", children: [], attachments: [] },\n },\n }));\n});\n\nconst spawnNote = handler<void, void>((_, __) => {\n return navigateTo(Note({\n title: \"New Note\",\n content: \"\",\n }));\n});\n\nexport default recipe<CharmsListInput, CharmsListOutput>(\n \"DefaultCharmList\",\n (_) => {\n const { allCharms } = wish<{ allCharms: MentionableCharm[] }>(\"/\");\n const index = BacklinksIndex({ allCharms });\n\n const fab = OmniboxFAB({\n mentionable: index.mentionable as unknown as Cell<MentionableCharm[]>,\n });\n\n return {\n backlinksIndex: index,\n [NAME]: str`DefaultCharmList (${allCharms.length})`,\n [UI]: (\n <ct-screen>\n <ct-keybind\n code=\"KeyN\"\n alt\n preventDefault\n onct-keybind={spawnChatList()}\n />\n <ct-keybind\n code=\"KeyO\"\n meta\n preventDefault\n onct-keybind={toggleFab({ fabExpanded: fab.fabExpanded })}\n />\n <ct-keybind\n code=\"KeyO\"\n ctrl\n preventDefault\n onct-keybind={toggleFab({ fabExpanded: fab.fabExpanded })}\n />\n\n <ct-toolbar slot=\"header\" sticky>\n <div slot=\"start\">\n <ct-button\n onClick={spawnChatList()}\n >\n üìÇ Chat List\n </ct-button>\n <ct-button\n onClick={spawnChatbot()}\n >\n üí¨ Chatbot\n </ct-button>\n <ct-button\n onClick={spawnChatbotOutliner()}\n >\n üìù Chatbot Outliner\n </ct-button>\n <ct-button\n onClick={spawnNote()}\n >\n üìÑ Note\n </ct-button>\n </div>\n </ct-toolbar>\n\n <ct-vscroll flex showScrollbar>\n <ct-vstack gap=\"4\" padding=\"6\">\n <style>\n {`\n .pattern-link {\n cursor: pointer;\n color: inherit;\n text-decoration: none;\n }\n .pattern-link:hover {\n text-decoration: underline;\n }\n `}\n </style>\n <h2>Pages</h2>\n\n <ct-table full-width hover>\n <tbody>\n {allCharms.map((charm) => (\n <tr>\n <td>\n <ct-cell-context $cell={charm}>\n <ct-cell-link $cell={charm} />\n </ct-cell-context>\n </td>\n <td>\n <ct-button\n size=\"sm\"\n variant=\"ghost\"\n onClick={removeCharm({ charm, allCharms })}\n >\n üóëÔ∏è\n </ct-button>\n </td>\n </tr>\n ))}\n </tbody>\n </ct-table>\n </ct-vstack>\n </ct-vscroll>\n </ct-screen>\n ),\n sidebarUI: undefined,\n fabUI: fab[UI],\n };\n },\n);\n"}}}}},"of:baedreiczp2strjgmqqr4y4cdhnfgyxpa2p7jh2clgkahly3d2ctbm52z2i":{"application/json":{"ba4jcbt6ddwmeffgpkxsqtfzakrhur22vsc4gzalizp2kegda7jxjgdpm":{"is":{"value":{"name":"/chatbot.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n computed,\n Default,\n fetchData,\n generateObject,\n handler,\n llmDialog,\n NAME,\n pattern,\n patternTool,\n Stream,\n UI,\n VNode,\n wish,\n} from \"commontools\";\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\n\nfunction schemaifyWish<T>(path: string) {\n return wish<T>(path);\n}\n\nconst sendMessage = handler<\n {\n detail: {\n text: string;\n attachments: Array<PromptAttachment>;\n mentions: Array<any>;\n message: string; // Backward compatibility\n };\n },\n {\n addMessage: Stream<BuiltInLLMMessage>;\n }\n>((event, { addMessage }) => {\n const { text } = event.detail;\n\n // Send the message as-is. Any markdown links like [name](/of:...)\n // are just text that the LLM can parse and use with addAttachment() tool.\n addMessage.send({\n role: \"user\",\n content: [{ type: \"text\" as const, text }],\n });\n});\n\nconst clearChat = handler(\n (\n _: never,\n { messages, pending }: {\n messages: Cell<Array<BuiltInLLMMessage>>;\n pending: Cell<boolean | undefined>;\n },\n ) => {\n messages.set([]);\n pending.set(false);\n },\n);\n\ntype ChatInput = {\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n tools?: any;\n theme?: any;\n system?: string;\n};\n\ntype PromptAttachment = {\n id: string;\n name: string;\n type: \"file\" | \"clipboard\" | \"mention\";\n data?: any; // File | Blob | string\n charm?: any;\n removable?: boolean; // Whether this attachment can be removed\n};\n\ntype ChatOutput = {\n messages: Array<BuiltInLLMMessage>;\n pending: boolean | undefined;\n addMessage: Stream<BuiltInLLMMessage>;\n clearChat: Stream<void>;\n cancelGeneration: Stream<void>;\n title?: string;\n pinnedCells: Array<PromptAttachment>;\n tools: any;\n ui: {\n chatLog: VNode;\n promptInput: VNode;\n attachmentsAndTools: VNode;\n };\n};\n\nexport const TitleGenerator = pattern<\n { model?: string; messages: Array<BuiltInLLMMessage> }\n>(({ model, messages }) => {\n const previewMessage = computed(() => {\n if (!messages || messages.length === 0) return \"\";\n\n const firstMessage = messages[0];\n\n if (!firstMessage) return \"\";\n\n return JSON.stringify(firstMessage);\n });\n\n const { result } = generateObject({\n system:\n \"Generate at most a 3-word title based on the following content, respond with NOTHING but the literal title text.\",\n prompt: previewMessage,\n model,\n schema: {\n type: \"object\",\n properties: {\n title: {\n type: \"string\",\n description: \"The title of the chat\",\n },\n },\n required: [\"title\"],\n },\n });\n\n const title = computed(() => {\n return result?.title || \"Untitled Chat\";\n });\n\n return title;\n});\n\nconst listMentionable = pattern<\n { mentionable: Array<MentionableCharm> },\n { result: Array<{ label: string; cell: Cell<unknown> }> }\n>(\n ({ mentionable }) => {\n const result = mentionable.map((charm) => ({\n label: charm[NAME]!,\n cell: charm,\n }));\n return { result };\n },\n);\n\nconst listRecent = pattern<\n { recentCharms: Array<MentionableCharm> },\n { result: Array<{ label: string; cell: Cell<unknown> }> }\n>(\n ({ recentCharms }) => {\n const namesList = recentCharms.map((charm) => ({\n label: charm[NAME]!,\n cell: charm,\n }));\n return { result: namesList };\n },\n);\n\nexport default pattern<ChatInput, ChatOutput>(\n ({ messages, tools, theme, system }) => {\n const model = Cell.of<string>(\"anthropic:claude-sonnet-4-5\");\n const mentionable = schemaifyWish<MentionableCharm[]>(\"#mentionable\");\n const recentCharms = schemaifyWish<MentionableCharm[]>(\"#recent\");\n\n const assistantTools = {\n listMentionable: patternTool(listMentionable, { mentionable }),\n listRecent: patternTool(listRecent, { recentCharms }),\n };\n\n // Merge static and assistant tools\n const mergedTools = computed(() => ({\n ...tools,\n ...assistantTools,\n }));\n\n const latest = computed(() => recentCharms[0]);\n const latestName = computed(() => recentCharms[0]?.[NAME]);\n\n const {\n addMessage,\n cancelGeneration,\n pending,\n flattenedTools,\n pinnedCells,\n } = llmDialog(\n {\n system: computed(() => {\n return system ?? \"You are a polite but efficient assistant.\";\n }),\n messages,\n tools: mergedTools,\n model,\n context: computed(() => ({\n [latestName]: latest,\n })),\n },\n );\n\n const { result } = fetchData({\n url: \"/api/ai/llm/models\",\n mode: \"json\",\n });\n\n const items = computed(() => {\n if (!result) return [];\n const items = Object.keys(result as any).map((key) => ({\n label: key,\n value: key,\n }));\n return items;\n });\n\n const title = TitleGenerator({ model, messages });\n\n const promptInput = (\n <ct-prompt-input\n slot=\"footer\"\n placeholder=\"Ask the LLM a question...\"\n pending={pending}\n $mentionable={mentionable}\n modelItems={items}\n $model={model}\n onct-send={sendMessage({ addMessage })}\n onct-stop={cancelGeneration}\n />\n );\n\n const chatLog = (\n <ct-vscroll\n style=\"padding: 1rem;\"\n flex\n showScrollbar\n fadeEdges\n snapToBottom\n >\n <ct-chat\n theme={theme}\n $messages={messages}\n pending={pending}\n tools={flattenedTools}\n />\n </ct-vscroll>\n );\n\n const attachmentsAndTools = (\n <ct-hstack align=\"center\" gap=\"1\">\n <ct-cell-context $cell={pinnedCells}>\n <ct-attachments-bar pinnedCells={pinnedCells} />\n </ct-cell-context>\n <ct-tools-chip tools={flattenedTools} />\n <ct-button\n variant=\"pill\"\n type=\"button\"\n title=\"Clear chat\"\n onClick={clearChat({\n messages,\n pending,\n })}\n >\n Clear\n </ct-button>\n </ct-hstack>\n );\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <ct-vstack slot=\"header\">\n <ct-heading level={4}>{title}</ct-heading>\n {attachmentsAndTools}\n </ct-vstack>\n\n {chatLog}\n\n {promptInput}\n </ct-screen>\n ),\n messages,\n pending,\n addMessage,\n clearChat: clearChat({\n messages,\n pending,\n }),\n cancelGeneration,\n title,\n pinnedCells,\n tools: flattenedTools,\n ui: {\n chatLog,\n promptInput,\n attachmentsAndTools,\n },\n };\n },\n);\n"}}}}},"of:baedreibkc7zcxdembp7sxpowfbthuiwev4tyyvciuvwzu7egg6323czmh4":{"application/json":{"ba4jcb4arsk7c7axovlb2gztmprwn45blyew2apjcv6lgh6r3oiuqdcnv":{"is":{"value":{"name":"/chatbot-outliner.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n Default,\n derive,\n handler,\n ifElse,\n JSONSchema,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot.tsx\";\nimport { MentionableCharm } from \"./backlinks-index.tsx\";\n\ntype Charm = any;\n\ntype OutlinerNode = {\n body: Default<string, \"\">;\n children: Default<OutlinerNode[], []>;\n attachments: Default<OpaqueRef<any>[], []>;\n};\n\ntype Outliner = {\n root: OutlinerNode;\n};\n\ntype PageResult = {\n outline: Default<\n Outliner,\n { root: { body: \"\"; children: []; attachments: [] } }\n >;\n};\n\nexport type PageInput = {\n outline: Outliner;\n};\n\nconst handleCharmLinkClick = handler<\n {\n detail: {\n charm: Cell<Charm>;\n };\n },\n Record<string, never>\n>(({ detail }, _) => {\n return navigateTo(detail.charm);\n});\n\nfunction getMentionable() {\n return derive<MentionableCharm[], MentionableCharm[]>(\n wish<MentionableCharm[]>(\"#mentionable\"),\n (i) => i,\n );\n}\n\nexport const Page = recipe<PageInput>(\n \"Page\",\n ({ outline }) => {\n const mentionable = getMentionable();\n\n return {\n [NAME]: \"Page\",\n [UI]: (\n <ct-outliner\n $value={outline as any}\n $mentionable={mentionable}\n oncharm-link-click={handleCharmLinkClick({})}\n />\n ),\n outline,\n };\n },\n);\n\ntype LLMTestInput = {\n title?: Cell<Default<string, \"LLM Test\">>;\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n expandChat?: Cell<Default<boolean, false>>;\n outline?: Default<\n Outliner,\n { root: { body: \"Untitled Page\"; children: []; attachments: [] } }\n >;\n};\n\ntype LLMTestResult = {\n messages: Default<Array<BuiltInLLMMessage>, []>;\n};\n\n// put a node at the end of the outline (by appending to root.children)\nconst appendOutlinerNode = handler<\n {\n /** The text content/title of the outliner node to be appended */\n body: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { outline: Cell<Outliner> }\n>(\n (args, state) => {\n try {\n (state.outline.key(\"root\").key(\"children\")).push({\n body: args.body,\n children: [],\n attachments: [],\n });\n\n args.result.set(\n `${state.outline.key(\"root\").key(\"children\").get().length} nodes`,\n );\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nexport default recipe<LLMTestInput, LLMTestResult>(\n \"Outliner\",\n ({ title, expandChat, messages, outline }) => {\n const tools = {\n appendOutlinerNode: {\n description: \"Add a new outliner node.\",\n inputSchema: {\n type: \"object\",\n properties: {\n body: {\n type: \"string\",\n description: \"The title of the new node.\",\n },\n },\n required: [\"body\"],\n } as JSONSchema,\n handler: appendOutlinerNode({ outline }),\n },\n };\n\n const chat = Chat({ messages, tools });\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <ct-hstack justify=\"between\" slot=\"header\">\n <div></div>\n <div>\n <ct-checkbox $checked={expandChat}>Show Chat</ct-checkbox>\n </div>\n </ct-hstack>\n\n <ct-autolayout tabNames={[\"Chat\", \"Tools\"]}>\n <ct-screen>\n <div slot=\"header\">\n <ct-input\n $value={title}\n placeholder=\"Enter title...\"\n />\n </div>\n\n <ct-vscroll flex showScrollbar fadeEdges snapToBottom>\n <ct-vstack data-label=\"Tools\">\n <Page outline={outline} />\n </ct-vstack>\n </ct-vscroll>\n </ct-screen>\n\n {ifElse(\n expandChat,\n chat,\n null,\n )}\n </ct-autolayout>\n </ct-screen>\n ),\n messages,\n };\n },\n);\n"}}}}},"of:baedreigmgcvh4yl4bwa5mobdiqln6dtzz62ok6ctgh2gaiijiarqi3utkm":{"application/json":{"ba4jcbwqf32i3chop2umyg6phmnh6uuwcsqxzucot4vckoq3nyuajjyf5":{"is":{"value":{"name":"/note.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n cell,\n type Default,\n derive,\n generateText,\n handler,\n NAME,\n navigateTo,\n patternTool,\n recipe,\n str,\n Stream,\n UI,\n wish,\n} from \"commontools\";\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\ntype Input = {\n title?: Cell<Default<string, \"Untitled Note\">>;\n content?: Cell<Default<string, \"\">>;\n};\n\n/** Represents a small #note a user took to remember some text. */\ntype Output = {\n mentioned: Default<Array<MentionableCharm>, []>;\n backlinks: MentionableCharm[];\n\n content: Default<string, \"\">;\n grep: Stream<{ query: string }>;\n translate: Stream<{ language: string }>;\n editContent: Stream<{ detail: { value: string } }>;\n};\n\nconst _updateTitle = handler<\n { detail: { value: string } },\n { title: Cell<string> }\n>(\n (event, state) => {\n state.title.set(event.detail?.value ?? \"\");\n },\n);\n\nconst _updateContent = handler<\n { detail: { value: string } },\n { content: Cell<string> }\n>(\n (event, state) => {\n state.content.set(event.detail?.value ?? \"\");\n },\n);\n\nconst handleCharmLinkClick = handler<\n {\n detail: {\n charm: Cell<MentionableCharm>;\n };\n },\n Record<string, never>\n>(({ detail }, _) => {\n return navigateTo(detail.charm);\n});\n\nconst handleNewBacklink = handler<\n {\n detail: {\n text: string;\n charmId: any;\n charm: Cell<MentionableCharm>;\n navigate: boolean;\n };\n },\n {\n mentionable: Cell<MentionableCharm[]>;\n }\n>(({ detail }, { mentionable }) => {\n console.log(\"new charm\", detail.text, detail.charmId);\n\n if (detail.navigate) {\n return navigateTo(detail.charm);\n } else {\n mentionable.push(detail.charm as unknown as MentionableCharm);\n }\n});\n\n/** This edits the content */\nconst handleEditContent = handler<\n { detail: { value: string }; result?: Cell<string> },\n { content: Cell<string> }\n>(\n ({ detail, result }, { content }) => {\n content.set(detail.value);\n result?.set(\"test!\");\n },\n);\n\nconst handleCharmLinkClicked = handler<void, { charm: Cell<MentionableCharm> }>(\n (_, { charm }) => {\n return navigateTo(charm);\n },\n);\n\nfunction schemaifyWish<T>(path: string, def: T) {\n return derive(wish<T>(path) as T, (i) => i ?? def);\n}\n\nconst Note = recipe<Input, Output>(\n \"Note\",\n ({ title, content }) => {\n const mentionable = schemaifyWish<MentionableCharm[]>(\n \"#mentionable\",\n [],\n );\n const mentioned = cell<MentionableCharm[]>([]);\n\n // populated in backlinks-index.tsx\n const backlinks = cell<MentionableCharm[]>([]);\n\n // The only way to serialize a pattern, apparently?\n const pattern = derive(undefined, () => JSON.stringify(Note));\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <div slot=\"header\">\n <ct-input\n $value={title}\n placeholder=\"Enter title...\"\n />\n </div>\n\n <ct-code-editor\n $value={content}\n $mentionable={mentionable}\n $mentioned={mentioned}\n $pattern={pattern}\n onbacklink-click={handleCharmLinkClick({})}\n onbacklink-create={handleNewBacklink({ mentionable })}\n language=\"text/markdown\"\n theme=\"light\"\n wordWrap\n tabIndent\n lineNumbers\n />\n\n <ct-hstack slot=\"footer\">\n {backlinks?.map((charm) => (\n <ct-button\n onClick={handleCharmLinkClicked({ charm })}\n >\n {charm?.[NAME]}\n </ct-button>\n ))}\n </ct-hstack>\n </ct-screen>\n ),\n title,\n content,\n mentioned,\n backlinks,\n grep: patternTool(\n ({ query, content }: { query: string; content: string }) => {\n return derive({ query, content }, ({ query, content }) => {\n return content.split(\"\\n\").filter((c) => c.includes(query));\n });\n },\n { content },\n ),\n translate: patternTool(\n (\n { language, content }: {\n language: string;\n content: string;\n },\n ) => {\n const result = generateText({\n system: str`Translate the content to ${language}.`,\n prompt: str`<to_translate>${content}</to_translate>`,\n });\n\n return derive(result, ({ pending, result }) => {\n if (pending) return undefined;\n if (result == null) return \"Error occured\";\n return result;\n });\n },\n { content },\n ),\n editContent: handleEditContent({ content }),\n };\n },\n);\n\nexport default Note;\n"}}}}},"of:baedreigo5n6mtjvvxsxkwqnzmvrl6vclp2fam46mx7nzykshmgyjtyivgu":{"application/json":{"ba4jcbrirsjwxxl3j76wrhuidg2n25fp4rxs7snvygimxuasbpq2axb7f":{"is":{"value":{"name":"/backlinks-index.tsx","contents":"/// <cts-enable />\nimport { Cell, derive, lift, NAME, OpaqueRef, recipe, UI } from \"commontools\";\n\nexport type MentionableCharm = {\n [NAME]?: string;\n mentioned: MentionableCharm[];\n backlinks: MentionableCharm[];\n};\n\nexport type WriteableBacklinks = {\n mentioned: WriteableBacklinks[];\n backlinks: Cell<WriteableBacklinks[]>;\n};\n\ntype Input = {\n allCharms: MentionableCharm[];\n};\n\ntype Output = {\n mentionable: MentionableCharm[];\n};\n\nconst computeIndex = lift<\n { allCharms: WriteableBacklinks[] },\n void\n>(\n ({ allCharms }) => {\n const cs = allCharms ?? [];\n\n for (const c of cs) {\n c.backlinks?.set([]);\n }\n\n for (const c of cs) {\n const mentions = c.mentioned ?? [];\n for (const m of mentions) {\n m?.backlinks?.push(c);\n }\n }\n },\n);\n\n/**\n * BacklinksIndex builds a map of backlinks across all charms and exposes a\n * unified mentionable list for consumers like editors.\n *\n * Behavior:\n * - Backlinks are computed by scanning each charm's `mentioned` list and\n * mapping mention target -> list of source charms.\n * - Mentionable list is a union of:\n * - every charm in `allCharms`\n * - any items a charm exports via a `mentionable` property\n * (either an array of charms or a Cell of such an array)\n *\n * The backlinks map is keyed by a charm's `content` value (falling back to\n * its `[NAME]`). This mirrors how existing note patterns identify notes when\n * computing backlinks locally.\n */\nconst BacklinksIndex = recipe<Input, Output>(\n \"BacklinksIndex\",\n ({ allCharms }) => {\n computeIndex({\n allCharms: allCharms as unknown as OpaqueRef<WriteableBacklinks[]>,\n });\n\n // Compute mentionable list from allCharms reactively\n const mentionable = derive(allCharms, (charmList) => {\n const cs = charmList ?? [];\n const out: MentionableCharm[] = [];\n for (const c of cs) {\n out.push(c);\n const exported = (c as unknown as {\n mentionable?: MentionableCharm[] | { get?: () => MentionableCharm[] };\n }).mentionable;\n if (Array.isArray(exported)) {\n for (const m of exported) if (m) out.push(m);\n } else if (exported && typeof (exported as any).get === \"function\") {\n const arr = (exported as { get: () => MentionableCharm[] }).get() ??\n [];\n for (const m of arr) if (m) out.push(m);\n }\n }\n return out;\n });\n\n return {\n [NAME]: \"BacklinksIndex\",\n [UI]: undefined,\n mentionable,\n };\n },\n);\n\nexport default BacklinksIndex;\n"}}}}},"of:baedreiam356b7666ueqii5minnknx2nes4rblkbvqnp7ogzjqoislg65du":{"application/json":{"ba4jcbfoua2vmphnb46podjhdafqebq4lcekcmr5qgxyyfzpdbgibof6r":{"is":{"value":{"name":"/chatbot-list-view.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n Default,\n derive,\n handler,\n ID,\n ifElse,\n lift,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n toSchema,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot-note-composed.tsx\";\nimport { ListItem } from \"./common-tools.tsx\";\n\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\ntype CharmEntry = {\n [ID]: string; // randomId is a string\n local_id: string; // same as ID but easier to access\n charm: any;\n};\n\ntype Input = {\n selectedCharm: Default<{ charm: any }, { charm: undefined }>;\n charmsList: Default<CharmEntry[], []>;\n theme?: {\n accentColor: Cell<Default<string, \"#3b82f6\">>;\n fontFace: Cell<Default<string, \"system-ui, -apple-system, sans-serif\">>;\n borderRadius: Cell<Default<string, \"0.5rem\">>;\n };\n};\n\ntype Output = {\n selectedCharm: Default<{ charm: any }, { charm: undefined }>;\n // Expose a mentionable list aggregated from local chat entries\n // Returned as an opaque ref to an array (not a Cell), suitable for\n // upstream aggregators that read exported mentionables.\n mentionable?: MentionableCharm[];\n};\n\nconst removeChat = handler<\n unknown,\n {\n charmsList: Cell<CharmEntry[]>;\n id: string;\n selectedCharm: Cell<Default<{ charm: any }, { charm: undefined }>>;\n }\n>(\n (\n _,\n { charmsList, id, selectedCharm },\n ) => {\n const list = charmsList.get();\n const index = list.findIndex((entry) => entry.local_id === id);\n if (index === -1) return;\n\n const removed = list[index];\n const next = [...list];\n next.splice(index, 1);\n charmsList.set(next);\n\n // If we removed the currently selected charm, choose a new selection.\n const current = selectedCharm.get();\n if (current?.charm === removed.charm) {\n const replacement = next[index] ?? next[index - 1];\n if (replacement) {\n selectedCharm.set({ charm: replacement.charm });\n } else {\n selectedCharm.set({ charm: undefined as unknown as any });\n }\n }\n },\n);\n\n// this will be called whenever charm or selectedCharm changes\n// pass isInitialized to make sure we dont call this each time\n// we change selectedCharm, otherwise creates a loop\nconst storeCharm = lift(\n toSchema<{\n charm: any;\n selectedCharm: Cell<Default<{ charm: any }, { charm: undefined }>>;\n charmsList: Cell<CharmEntry[]>;\n allCharms: Cell<MentionableCharm[]>;\n theme?: {\n accentColor: Default<string, \"#3b82f6\">;\n fontFace: Default<string, \"system-ui, -apple-system, sans-serif\">;\n borderRadius: Default<string, \"0.5rem\">;\n };\n isInitialized: Cell<boolean>;\n }>(),\n undefined,\n ({ charm, selectedCharm, charmsList, isInitialized, allCharms: _ }) => { // Not including `allCharms` is a compile error...\n if (!isInitialized.get()) {\n console.log(\n \"storeCharm storing charm:\",\n charm,\n );\n selectedCharm.set({ charm });\n\n // create the chat charm with a custom name including a random suffix\n const randomId = Math.random().toString(36).substring(2, 10); // Random 8-char string\n charmsList.push({ [ID]: randomId, local_id: randomId, charm });\n\n isInitialized.set(true);\n return charm;\n } else {\n console.log(\"storeCharm: already initialized\");\n }\n return undefined;\n },\n);\n\nconst populateChatList = lift(\n toSchema<{\n charmsList: CharmEntry[];\n allCharms: Cell<any[]>;\n selectedCharm: Cell<{ charm: any }>;\n }>(),\n undefined,\n (\n { charmsList, allCharms, selectedCharm },\n ) => {\n if (charmsList.length === 0) {\n const isInitialized = Cell.of(false);\n return storeCharm({\n charm: Chat({\n title: \"New Chat\",\n messages: [],\n }),\n selectedCharm,\n charmsList,\n allCharms,\n isInitialized: isInitialized as unknown as Cell<boolean>,\n });\n }\n\n return charmsList;\n },\n);\n\nconst createChatRecipe = handler<\n unknown,\n {\n selectedCharm: Cell<{ charm: any }>;\n charmsList: Cell<CharmEntry[]>;\n allCharms: Cell<MentionableCharm[]>;\n }\n>(\n (_, { selectedCharm, charmsList, allCharms }) => {\n const isInitialized = Cell.of(false);\n\n const charm = Chat({\n title: \"New Chat\",\n messages: [],\n });\n // store the charm ref in a cell (pass isInitialized to prevent recursive calls)\n return storeCharm({\n charm,\n selectedCharm,\n charmsList: charmsList as unknown as OpaqueRef<CharmEntry[]>,\n allCharms,\n isInitialized: isInitialized as unknown as Cell<boolean>,\n });\n },\n);\n\nconst selectCharm = handler<\n unknown,\n { selectedCharm: Cell<{ charm: any }>; charm: any }\n>(\n (_, { selectedCharm, charm }) => {\n console.log(\"selectCharm: updating selectedCharm to \", charm);\n selectedCharm.set({ charm });\n return selectedCharm;\n },\n);\n\nconst logCharmsList = lift<\n { charmsList: Cell<CharmEntry[]> },\n Cell<CharmEntry[]>\n>(\n ({ charmsList }) => {\n console.log(\"logCharmsList: \", charmsList.get());\n return charmsList;\n },\n);\n\nconst _handleCharmLinkClicked = handler(\n (_: any, { charm }: { charm: Cell<MentionableCharm> }) => {\n return navigateTo(charm);\n },\n);\n\nconst _merge = lift(\n (\n { allCharms, charmsList }: { allCharms: any[]; charmsList: CharmEntry[] },\n ) => {\n return [...charmsList.map((c) => c.charm), ...allCharms];\n },\n);\n\nconst getSelectedCharm = lift<\n { entry: { charm: any | undefined } },\n {\n chat: unknown;\n list: ListItem[];\n } | undefined\n>(\n ({ entry }) => {\n return entry?.charm;\n },\n);\n\nconst getCharmName = lift(({ charm }: { charm: any }) => {\n return charm?.[NAME] || \"Unknown\";\n});\n\nconst extractLocalMentionable = lift<\n { list: CharmEntry[] },\n MentionableCharm[]\n>(({ list }) => {\n const out: MentionableCharm[] = [];\n for (const entry of list) {\n const c = entry.charm;\n out.push(c.chat);\n }\n return out;\n});\n\n// create the named cell inside the recipe body, so we do it just once\nexport default recipe<Input, Output>(\n \"Launcher\",\n ({ selectedCharm, charmsList, theme }) => {\n const allCharms = derive<MentionableCharm[], MentionableCharm[]>(\n wish<MentionableCharm[]>(\"#allCharms\"),\n (c) => c ?? [],\n );\n logCharmsList({ charmsList: charmsList as unknown as Cell<CharmEntry[]> });\n\n populateChatList({\n selectedCharm: selectedCharm as unknown as Cell<\n Pick<CharmEntry, \"charm\">\n >,\n charmsList,\n allCharms,\n });\n\n const selected = getSelectedCharm({ entry: selectedCharm });\n\n // Aggregate mentionables from the local charms list so that this\n // container exposes its child chat charms as mention targets.\n const localMentionable = extractLocalMentionable({ list: charmsList });\n\n const localTheme = theme ?? {\n accentColor: Cell.of(\"#3b82f6\"),\n fontFace: Cell.of(\"system-ui, -apple-system, sans-serif\"),\n borderRadius: Cell.of(\"0.5rem\"),\n };\n\n return {\n [NAME]: \"Launcher\",\n [UI]: (\n <ct-theme theme={localTheme as any}>\n <ct-screen>\n <div slot=\"header\">\n <ct-toolbar dense sticky>\n <div slot=\"start\">\n <ct-button\n id=\"new-chat-btn\"\n onClick={createChatRecipe({\n selectedCharm,\n charmsList,\n allCharms,\n })}\n >\n Create New Chat\n <ct-kbd>alt+N</ct-kbd>\n </ct-button>\n </div>\n </ct-toolbar>\n\n {/* Keyboard shortcuts */}\n <ct-keybind\n code=\"KeyN\"\n alt\n preventDefault\n onct-keybind={createChatRecipe({\n selectedCharm,\n charmsList,\n allCharms,\n })}\n />\n </div>\n <ct-autolayout\n leftOpen\n rightOpen={false}\n >\n {/* workaround: this seems to correctly start the sub-recipes on a refresh while directly rendering does not */}\n {/* this should be fixed after the builder-refactor (DX1) */}\n <ct-screen>\n <ct-render $cell={selected.chat} />\n </ct-screen>\n\n <aside slot=\"left\">\n <div>\n <ct-heading level={3}>Chat List</ct-heading>\n </div>\n <div role=\"list\">\n {charmsList.map((charmEntry) => (\n <ct-list-item\n onct-activate={selectCharm({\n selectedCharm,\n charm: charmEntry.charm,\n })}\n >\n <span>{getCharmName({ charm: charmEntry.charm })}</span>\n <span slot=\"meta\">{charmEntry.local_id}</span>\n <ct-button\n slot=\"actions\"\n size=\"sm\"\n title=\"Delete Chat\"\n variant=\"destructive\"\n onClick={removeChat({\n charmsList: charmsList as unknown as OpaqueRef<\n CharmEntry[]\n >,\n id: charmEntry.local_id,\n selectedCharm: selectedCharm as unknown as OpaqueRef<\n Default<{ charm: any }, { charm: undefined }>\n >,\n })}\n >\n üóëÔ∏è\n </ct-button>\n </ct-list-item>\n ))}\n </div>\n </aside>\n\n <aside slot=\"right\">\n {ifElse(\n selected,\n <>\n <ct-ct-collapsible>\n <ct-heading slot=\"trigger\" level={5} no-margin>\n List\n </ct-heading>\n <ct-list $value={selected.list} />\n </ct-ct-collapsible>\n </>,\n null,\n )}\n <ct-collapsible>\n <ct-heading slot=\"trigger\" level={5} no-margin>\n Theme\n </ct-heading>\n <ct-vstack style=\"padding: 0.5rem 0; gap: 0.5rem;\">\n <ct-vstack>\n <ct-text>Font Family</ct-text>\n <ct-select\n items={[\n {\n label: \"System\",\n value: \"system-ui, -apple-system, sans-serif\",\n },\n {\n label: \"Monospace\",\n value: \"ui-monospace, Consolas, monospace\",\n },\n {\n label: \"Serif\",\n value: \"Georgia, Times, serif\",\n },\n {\n label: \"Sans Serif\",\n value: \"Arial, Helvetica, sans-serif\",\n },\n ]}\n $value={localTheme.fontFace}\n />\n </ct-vstack>\n\n <ct-vstack>\n <ct-text>Accent Color</ct-text>\n <ct-select\n items={[\n { label: \"Blue\", value: \"#3b82f6\" },\n { label: \"Purple\", value: \"#8b5cf6\" },\n { label: \"Green\", value: \"#10b981\" },\n { label: \"Red\", value: \"#ef4444\" },\n { label: \"Orange\", value: \"#f97316\" },\n { label: \"Pink\", value: \"#ec4899\" },\n { label: \"Indigo\", value: \"#6366f1\" },\n { label: \"Teal\", value: \"#14b8a6\" },\n ]}\n $value={localTheme.accentColor}\n />\n </ct-vstack>\n\n <ct-vstack>\n <ct-text>Border Radius</ct-text>\n <ct-select\n items={[\n { label: \"None\", value: \"0px\" },\n { label: \"Small\", value: \"0.25rem\" },\n { label: \"Medium\", value: \"0.5rem\" },\n { label: \"Large\", value: \"0.75rem\" },\n { label: \"Extra Large\", value: \"1rem\" },\n { label: \"Rounded\", value: \"1.5rem\" },\n ]}\n $value={localTheme.borderRadius}\n />\n </ct-vstack>\n </ct-vstack>\n </ct-collapsible>\n </aside>\n </ct-autolayout>\n </ct-screen>\n </ct-theme>\n ),\n selectedCharm,\n charmsList,\n // Expose the aggregated mentionables for parent-level indexing.\n mentionable: localMentionable,\n };\n },\n);\n"}}}}},"of:baedreiaconf4zx2gafumhuetpthdpy6ncqtjjnlagr2mjfzrtuygwatzju":{"application/json":{"ba4jcbr2plisj6q563jgf3recfb534r7dzbq3p54wcylyo42ywjs6ewn4":{"is":{"value":{"name":"/omnibox-fab.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n computed,\n handler,\n ifElse,\n NAME,\n pattern,\n patternTool,\n UI,\n} from \"commontools\";\nimport Chatbot from \"./chatbot.tsx\";\nimport {\n calculator,\n fetchAndRunPattern,\n listPatternIndex,\n navigateToPattern,\n readWebpage,\n searchWeb,\n} from \"./common-tools.tsx\";\nimport { MentionableCharm } from \"./backlinks-index.tsx\";\n\ninterface OmniboxFABInput {\n mentionable: Cell<MentionableCharm[]>;\n}\n\nconst toggle = handler<any, { value: Cell<boolean> }>((_, { value }) => {\n value.set(!value.get());\n});\n\nconst closeFab = handler<any, { fabExpanded: Cell<boolean> }>(\n (_, { fabExpanded }) => {\n fabExpanded.set(false);\n },\n);\n\nconst dismissPeek = handler<\n any,\n { peekDismissedIndex: Cell<number>; assistantMessageCount: number }\n>((_, { peekDismissedIndex, assistantMessageCount }) => {\n // Store the current assistant message count so we know which message was dismissed\n peekDismissedIndex.set(assistantMessageCount);\n});\n\nexport default pattern<OmniboxFABInput>(\n (_) => {\n const omnibot = Chatbot({\n system:\n \"You are a polite but efficient assistant. Think Star Trek computer - helpful and professional without unnecessary conversation. Let your actions speak for themselves.\\n\\nTool usage priority:\\n- For patterns: listPatternIndex first\\n- For existing pages/notes/content: listRecent or listMentionable to identify what they're referencing\\n- Attach relevant items to conversation after instantiation/retrieval if they support ongoing tasks\\n- Remove attachments when no longer relevant\\n- Search web only as last resort when nothing exists in the space\\n\\nBe matter-of-fact. Prefer action to explanation.\",\n tools: {\n searchWeb: {\n pattern: searchWeb,\n },\n readWebpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n fetchAndRunPattern: patternTool(fetchAndRunPattern),\n listPatternIndex: patternTool(listPatternIndex),\n navigateTo: patternTool(navigateToPattern),\n },\n });\n\n const fabExpanded = Cell.of(false);\n const showHistory = Cell.of(false);\n const peekDismissedIndex = Cell.of(-1); // Track which message index was dismissed\n\n // Derive assistant message count for dismiss tracking\n const assistantMessageCount = computed(() => {\n return omnibot.messages.filter((m) => m.role === \"assistant\").length;\n });\n\n // Derive latest assistant message for peek\n const latestAssistantMessage = computed(() => {\n if (!omnibot.messages || omnibot.messages.length === 0) return null;\n\n for (let i = omnibot.messages.length - 1; i >= 0; i--) {\n const msg = omnibot.messages[i];\n if (msg.role === \"assistant\") {\n const content = typeof msg.content === \"string\"\n ? msg.content\n : msg.content.map((part: any) => {\n if (part.type === \"text\") return part.text;\n return \"\";\n }).join(\"\");\n\n return content;\n }\n }\n return null;\n });\n\n return {\n [NAME]: \"OmniboxFAB\",\n messages: omnibot.messages,\n [UI]: (\n <ct-fab\n expanded={computed(() => fabExpanded.get())}\n variant=\"primary\"\n position=\"bottom-right\"\n pending={omnibot.pending}\n $previewMessage={latestAssistantMessage}\n onct-fab-backdrop-click={closeFab({ fabExpanded })}\n onct-fab-escape={closeFab({ fabExpanded })}\n onClick={toggle({ value: fabExpanded })}\n >\n <div style=\"width: 100%; display: flex; flex-direction: column; max-height: 580px;\">\n {/* Chevron at top - the \"handle\" for the drawer */}\n <div style=\"border-bottom: 1px solid #e5e5e5; flex-shrink: 0;\">\n <ct-chevron-button\n expanded={computed(() => showHistory.get())}\n loading={omnibot.pending}\n onct-toggle={toggle({ value: showHistory })}\n />\n </div>\n\n <div\n style={computed(() => {\n const show = showHistory.get();\n return `flex: ${\n show ? \"1\" : \"0\"\n }; min-height: 0; display: flex; flex-direction: column; opacity: ${\n show ? \"1\" : \"0\"\n }; max-height: ${\n show ? \"480px\" : \"0\"\n }; overflow: hidden; transition: opacity 300ms ease, max-height 400ms cubic-bezier(0.34, 1.56, 0.64, 1), flex 400ms cubic-bezier(0.34, 1.56, 0.64, 1); pointer-events: ${\n show ? \"auto\" : \"none\"\n };`;\n })}\n >\n <div style=\"padding: .25rem; flex-shrink: 0;\">\n {omnibot.ui.attachmentsAndTools}\n </div>\n <div style=\"flex: 1; overflow-y: auto; min-height: 0;\">\n <ct-cell-context $cell={omnibot}>\n {omnibot.ui.chatLog}\n </ct-cell-context>\n </div>\n </div>\n\n {ifElse(\n computed(() => {\n const show = showHistory.get();\n const dismissedIdx = peekDismissedIndex.get();\n return !show && latestAssistantMessage &&\n assistantMessageCount !== dismissedIdx;\n }),\n <div style=\"margin: .5rem; margin-bottom: 0; padding: 0; flex-shrink: 0; position: relative;\">\n <ct-button\n variant=\"ghost\"\n size=\"icon\"\n onClick={dismissPeek({\n peekDismissedIndex,\n assistantMessageCount,\n })}\n style=\"position: absolute; top: 0px; right: 0px; z-index: 1; font-size: 16px;\"\n title=\"Dismiss\"\n >\n √ó\n </ct-button>\n <div\n onClick={toggle({ value: showHistory })}\n style=\"cursor: pointer;\"\n >\n <ct-cell-context $cell={latestAssistantMessage}>\n <ct-chat-message\n role=\"assistant\"\n compact\n content={latestAssistantMessage}\n pending={omnibot.pending}\n />\n </ct-cell-context>\n </div>\n </div>,\n null,\n )}\n\n {/* Prompt input - always at bottom */}\n <div style=\"padding: 0.5rem; flex-shrink: 0;\">\n {omnibot.ui.promptInput}\n </div>\n </div>\n </ct-fab>\n ),\n fabExpanded,\n };\n },\n);\n"}}}}},"of:baedreiayx6zri6trvdy7qaw5ljqys5fb64tlzmd6pih5afnpdyqcnhau5y":{"application/json":{"ba4jcbh6cwld4jbyaablnjvoxyng7o6zltqfvv2yybv6wy5i5ajsielq6":{"is":{"value":{"name":"/chatbot-note-composed.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n cell,\n Default,\n derive,\n handler,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot.tsx\";\nimport Note from \"./note.tsx\";\nimport {\n addListItem,\n calculator,\n ListItem,\n readListItems,\n readWebpage,\n searchWeb,\n} from \"./common-tools.tsx\";\n\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\n\nfunction schemaifyWish<T>(path: string, def: T) {\n return derive(wish<T>(path), (i) => i ?? def);\n}\n\ntype ChatbotNoteInput = {\n title?: Cell<Default<string, \"LLM Test\">>;\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n};\n\ntype ChatbotNoteResult = {\n messages: Default<Array<BuiltInLLMMessage>, []>;\n chat: any;\n list: Default<ListItem[], []>;\n // Optional: expose sub-charms as mentionable targets\n mentionable?: MentionableCharm[];\n};\n\nconst newNote = handler<\n {\n /** The text content of the note */\n title: string;\n content?: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allCharms: Cell<MentionableCharm[]>; index: any }\n>(\n (args, _) => {\n try {\n const n = Note({\n title: args.title,\n content: args.content ?? \"\",\n });\n\n args.result.set(\n `Created note ${args.title}`,\n );\n\n // TODO(bf): we have to navigate here until DX1 lands\n // then we go back to pushing to allCharms\n return navigateTo(n);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst listMentionable = handler<\n {\n /** A cell to store the result text */\n result: Cell<string>;\n },\n { mentionable: MentionableCharm[] }\n>(\n (args, state) => {\n try {\n const namesList = state.mentionable.map((charm) => charm[NAME]);\n args.result.set(JSON.stringify(namesList));\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst readContentByIndex = handler<\n {\n /** A cell to store the result text */\n index: number;\n result: Cell<string>;\n },\n { allNotes: Note[] }\n>(\n (args, state) => {\n try {\n args.result.set(\n state.allNotes[args.index]?.content || \"No content found\",\n );\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\ntype Note = MentionableCharm & { content: string };\nconst editContentByIndex = handler<\n {\n /** The index of the note to edit */\n index: number;\n /** The new text content of the note */\n body: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allNotes: Cell<Note[]> }\n>(\n (args, state) => {\n try {\n const charms = state.allNotes.get();\n if (args.index < 0 || args.index >= charms.length) {\n args.result.set(`Error: Invalid index ${args.index}`);\n return;\n }\n\n state.allNotes.key(args.index).key(\"content\").set(args.body);\n args.result.set(`Updated note at index ${args.index}!`);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst navigateToNote = handler<\n {\n /** The index of the note to navigate to */\n index: number;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allCharms: Cell<MentionableCharm[]> }\n>(\n (args, state) => {\n try {\n const charms = state.allCharms.get();\n if (args.index < 0 || args.index >= charms.length) {\n args.result.set(`Error: Invalid index ${args.index}`);\n return;\n }\n\n const targetCharm = charms[args.index];\n args.result.set(`Navigating to note: ${targetCharm[NAME]}`);\n\n return navigateTo(state.allCharms.key(args.index));\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\ntype BacklinksIndex = {\n mentionable: MentionableCharm[];\n};\n\nexport default recipe<ChatbotNoteInput, ChatbotNoteResult>(\n \"Chatbot + Note\",\n ({ title, messages }) => {\n const allCharms = schemaifyWish<MentionableCharm[]>(\"#allCharms\", []);\n const index = schemaifyWish<BacklinksIndex>(\"#default/backlinksIndex\", {\n mentionable: [],\n });\n const mentionable = schemaifyWish<MentionableCharm[]>(\n \"#mentionable\",\n [],\n );\n\n const list = cell<ListItem[]>([]);\n\n const tools = {\n searchWeb: {\n pattern: searchWeb,\n },\n readWebpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n addListItem: {\n handler: addListItem({ list }),\n },\n readListItems: {\n handler: readListItems({ list }),\n },\n listMentionable: {\n description:\n \"List all mentionable items titles (read the body with readNoteByIndex).\",\n handler: listMentionable({ mentionable }),\n },\n readContentByIndex: {\n description:\n \"Read the content of a mentionable by its index in the listMentionable() list (if possible)\",\n handler: readContentByIndex({\n allNotes: mentionable as unknown as OpaqueRef<Note[]>,\n }),\n },\n editContentByIndex: {\n description:\n \"Edit the content of a mentionable by its index in the listMentionable() list (if possible)\",\n handler: editContentByIndex({\n allNotes: mentionable as unknown as OpaqueRef<Note[]>,\n }),\n },\n navigateToNote: {\n description:\n \"Navigate to a mentionable by its index in the listMentionable() list.\",\n handler: navigateToNote({\n allCharms: allCharms as unknown as OpaqueRef<MentionableCharm[]>,\n }),\n },\n newNote: {\n description: \"Create a new note instance\",\n handler: newNote({\n allCharms: allCharms as unknown as OpaqueRef<MentionableCharm[]>,\n index: index as unknown as OpaqueRef<any>,\n }),\n },\n };\n\n const chat = Chat({ messages, tools });\n\n return {\n [NAME]: title,\n chat,\n messages,\n list,\n // Expose sub-charms as mentionable targets\n mentionable: [chat as unknown as MentionableCharm],\n };\n },\n);\n"}}}}},"of:baedreigayykp34gmnn2ckdu2zfleo6tyu3qqo46p2fifo44yez3htt227i":{"application/json":{"ba4jcbaoftoa3n7imawbtj4kexj4z4mizwaebrix47gtckoqhokb7z36g":{"is":{"value":{"name":"/common-tools.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMTool,\n Cell,\n compileAndRun,\n computed,\n derive,\n fetchData,\n fetchProgram,\n handler,\n ifElse,\n navigateTo,\n recipe,\n} from \"commontools\";\n\n///// COMMON TOOLS (get it?) ////\n\n/**\n * Calculate the result of a mathematical expression.\n * Supports +, -, *, /, and parentheses.\n */\ntype CalculatorRequest = {\n /** The mathematical expression to evaluate. */\n expression: string;\n /** The base to use for the calculation. */\n base?: number;\n};\n\nexport const calculator = recipe<\n CalculatorRequest,\n string | { error: string }\n>(({ expression, base }) => {\n return derive({ expression, base }, ({ expression, base }) => {\n const sanitized = expression.replace(/[^0-9+\\-*/().\\s]/g, \"\");\n let sanitizedBase = Number(base);\n if (\n Number.isNaN(sanitizedBase) || sanitizedBase < 2 || sanitizedBase > 36\n ) {\n sanitizedBase = 10;\n }\n let result;\n try {\n result = Function(\n `\"use strict\"; return Number(${sanitized}).toString(${sanitizedBase})`,\n )();\n } catch (error) {\n result = { error: (error as any)?.message || \"<error>\" };\n }\n return result;\n });\n});\n\n/** Add an item to the list. */\ntype AddListItemRequest = {\n /** The item to add to the list. */\n item: string;\n result: Cell<string>;\n};\n\n/** Read all items from the list. */\ntype ReadListItemsRequest = {\n result: Cell<string>;\n};\n\nexport type ListItem = {\n title: string;\n};\n\nexport const addListItem = handler<\n AddListItemRequest,\n { list: Cell<ListItem[]> }\n>(\n (args, state) => {\n try {\n state.list.push({ title: args.item });\n args.result.set(`${state.list.get().length} items`);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nexport const readListItems = handler<\n ReadListItemsRequest,\n { list: ListItem[] }\n>(\n (args, state) => {\n try {\n const items = state.list;\n if (items.length === 0) {\n args.result.set(\"The list is empty\");\n } else {\n const itemList = items.map((item, index) =>\n `${index + 1}. ${item.title}`\n ).join(\"\\n\");\n args.result.set(`List items (${items.length} total):\\n${itemList}`);\n }\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\n/** Search the web for information. */\ntype SearchQuery = {\n /** The query to search the web for. */\n query: string;\n};\n\ntype SearchWebResult = {\n results: {\n title: string;\n url: string;\n description: string;\n }[];\n};\n\nexport const searchWeb = recipe<\n SearchQuery,\n SearchWebResult | { error: string }\n>(({ query }) => {\n const { result, error } = fetchData<SearchWebResult>({\n url: \"/api/agent-tools/web-search\",\n mode: \"json\",\n options: {\n method: \"POST\",\n headers: {\n \"Content-Type\": \"application/json\",\n },\n body: {\n query,\n max_results: 5,\n },\n },\n });\n\n // TODO(seefeld): Should we instead return { result, error }? Or allocate a\n // special [ERROR] for errors? Ideally this isn't specific to using recipes as\n // tools but a general pattern.\n return ifElse(error, { error }, result);\n});\n\n/** Read and extract content from a specific webpage URL. */\ntype ReadWebRequest = {\n /** The URL of the webpage to read and extract content from. */\n url: string;\n};\n\ntype ReadWebResult = {\n content: string;\n metadata: {\n title?: string;\n author?: string;\n date?: string;\n word_count: number;\n };\n};\n\nexport const readWebpage = recipe<\n ReadWebRequest,\n ReadWebResult | { error: string }\n>(({ url }) => {\n const { result, error } = fetchData<ReadWebResult>({\n url: \"/api/agent-tools/web-read\",\n mode: \"json\",\n options: {\n method: \"POST\",\n headers: {\n \"Content-Type\": \"application/json\",\n },\n body: {\n url,\n max_tokens: 4000,\n include_code: true,\n },\n },\n });\n\n return ifElse(error, { error }, result);\n});\n\ntype ToolsInput = {\n list: ListItem[];\n};\n\nexport default recipe<ToolsInput>(({ list }) => {\n const tools: Record<string, BuiltInLLMTool> = {\n search_web: {\n pattern: searchWeb,\n },\n read_webpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n addListItem: {\n handler: addListItem({ list }),\n },\n };\n\n return { tools, list };\n});\n\n/**\n * `fetchAndRunPattern({ url: \"https://...\", args: {} })`\n *\n * Instantiates patterns (e.g. from listPatternIndex) and returns the cell that\n * contains the results. The instantiated pattern will keep running and updating\n * the cell. Pass the resulting cell to `navigateTo` to show the pattern's UI.\n *\n * Pass in arguments to initialize the pattern. It's especially useful to pass\n * in links to other cells as `{ \"@link\": \"/of:bafe.../path/to/data\" }`.\n */\ntype FetchAndRunPatternInput = {\n url: string;\n args: Cell<any>;\n};\nexport const fetchAndRunPattern = recipe<FetchAndRunPatternInput>(\n ({ url, args }) => {\n const { pending: _fetchPending, result: program, error: _fetchError } =\n fetchProgram({ url });\n\n // Use derive to safely handle when program is undefined/pending\n const compileParams = derive(program, (p) => ({\n files: p?.files ?? [],\n main: p?.main ?? \"\",\n input: args,\n }));\n\n const { pending, result, error } = compileAndRun(compileParams);\n\n return ifElse(\n computed(() => pending || (!result && !error)),\n undefined,\n {\n cell: result,\n error,\n },\n );\n },\n);\n\n/**\n * `navigateTo({ cell: { \"@link\": \"/of:xyz\" } })` - Navigates to that cell's UI\n *\n * Especially useful after instantiating a pattern with fetchAndRunPattern:\n * Pass the \"@link\" you get at `cell` to navigate to the pattern's view.\n */\ntype NavigateToPatternInput = { cell: Cell<any> }; // Hack to steer LLM\nexport const navigateToPattern = recipe<NavigateToPatternInput>(\n ({ cell }) => {\n const success = navigateTo(cell);\n\n return ifElse(success, { success }, undefined);\n },\n);\n\n/**\n * `listPatternIndex()` - Returns the index of patterns.\n *\n * Useful as input to fetchAndRun.\n */\ntype ListPatternIndexInput = Record<string, never>;\n\nexport const listPatternIndex = recipe<ListPatternIndexInput>(\n ({ _ }) => {\n const { pending, result } = fetchData({\n url: \"/api/patterns/index.md\",\n mode: \"text\",\n });\n return ifElse(computed(() => pending || !result), undefined, { result });\n },\n);\n"}}}}}}},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740}}}}}}}}	62031	
16:19:04.515
{"the":"task/return","of":"job:ba4jcbmi7dxrmzxfatl7v5qzminqcgjnwsrkhwec5un462m4ssvaeaeze","is":{"ok":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{"of:baedreiayeohgxjzmij53y63lgaax5ndolqk5ksdwu6xscel4kx2m2s6c3q":{"application/json":{"ba4jcb3hhqhe4nfpe2r3jcw4pjcg5xj6dshwik532oxtibrg3rlpdpyf6":{"is":{"value":{"id":"ba4jcaodz2xu6wbjq3i54qb4dily77jzm6ofnrimmtbv6lcfgexob2umv","program":{"main":"/default-app.tsx","files":[{"/":{"link@1":{"path":[],"id":"of:baedreibr6gycs6dvh32an73hiiddc54zmousvmu7eknp2k75nj2hprzofy"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiczp2strjgmqqr4y4cdhnfgyxpa2p7jh2clgkahly3d2ctbm52z2i"}}},{"/":{"link@1":{"path":[],"id":"of:baedreibkc7zcxdembp7sxpowfbthuiwev4tyyvciuvwzu7egg6323czmh4"}}},{"/":{"link@1":{"path":[],"id":"of:baedreigmgcvh4yl4bwa5mobdiqln6dtzz62ok6ctgh2gaiijiarqi3utkm"}}},{"/":{"link@1":{"path":[],"id":"of:baedreigo5n6mtjvvxsxkwqnzmvrl6vclp2fam46mx7nzykshmgyjtyivgu"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiam356b7666ueqii5minnknx2nes4rblkbvqnp7ogzjqoislg65du"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiaconf4zx2gafumhuetpthdpy6ncqtjjnlagr2mjfzrtuygwatzju"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiayx6zri6trvdy7qaw5ljqys5fb64tlzmd6pih5afnpdyqcnhau5y"}}},{"/":{"link@1":{"path":[],"id":"of:baedreigayykp34gmnn2ckdu2zfleo6tyu3qqo46p2fifo44yez3htt227i"}}}]},"spec":"recipe"}},"since":20}}},"of:baedreibr6gycs6dvh32an73hiiddc54zmousvmu7eknp2k75nj2hprzofy":{"application/json":{"ba4jcbvpt5rfkhehimagciotvn3bpzzhz3uo5p4gmlr7l4jlydp7ixyuz":{"is":{"value":{"name":"/default-app.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n handler,\n NAME,\n navigateTo,\n recipe,\n str,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chatbot from \"./chatbot.tsx\";\nimport ChatbotOutliner from \"./chatbot-outliner.tsx\";\nimport { default as Note } from \"./note.tsx\";\nimport BacklinksIndex, { type MentionableCharm } from \"./backlinks-index.tsx\";\nimport ChatList from \"./chatbot-list-view.tsx\";\nimport OmniboxFAB from \"./omnibox-fab.tsx\";\n\ntype MinimalCharm = {\n [NAME]?: string;\n};\n\ntype CharmsListInput = void;\n\n// Recipe returns only UI, no data outputs (only symbol properties)\ninterface CharmsListOutput {\n [key: string]: unknown;\n backlinksIndex: {\n mentionable: MentionableCharm[];\n };\n sidebarUI: unknown;\n fabUI: unknown;\n}\n\nconst _visit = handler<\n Record<string, never>,\n { charm: Cell<MinimalCharm> }\n>((_, state) => {\n return navigateTo(state.charm);\n}, { proxy: true });\n\nconst removeCharm = handler<\n Record<string, never>,\n {\n charm: Cell<MinimalCharm>;\n allCharms: Cell<MinimalCharm[]>;\n }\n>((_, state) => {\n const allCharmsValue = state.allCharms.get();\n const index = allCharmsValue.findIndex((c: any) => state.charm.equals(c));\n\n if (index !== -1) {\n const charmListCopy = [...allCharmsValue];\n console.log(\"charmListCopy before\", charmListCopy.length);\n charmListCopy.splice(index, 1);\n console.log(\"charmListCopy after\", charmListCopy.length);\n state.allCharms.set(charmListCopy);\n }\n});\n\nconst toggleFab = handler<any, { fabExpanded: Cell<boolean> }>(\n (_, { fabExpanded }) => {\n fabExpanded.set(!fabExpanded.get());\n },\n);\n\nconst spawnChatList = handler<void, void>((_, __) => {\n return navigateTo(ChatList({\n selectedCharm: { charm: undefined },\n charmsList: [],\n }));\n});\n\nconst spawnChatbot = handler<void, void>((_, __) => {\n return navigateTo(Chatbot({\n messages: [],\n tools: undefined,\n }));\n});\n\nconst spawnChatbotOutliner = handler<void, void>((_, __) => {\n return navigateTo(ChatbotOutliner({\n title: \"Chatbot Outliner\",\n expandChat: false,\n messages: [],\n outline: {\n root: { body: \"\", children: [], attachments: [] },\n },\n }));\n});\n\nconst spawnNote = handler<void, void>((_, __) => {\n return navigateTo(Note({\n title: \"New Note\",\n content: \"\",\n }));\n});\n\nexport default recipe<CharmsListInput, CharmsListOutput>(\n \"DefaultCharmList\",\n (_) => {\n const { allCharms } = wish<{ allCharms: MentionableCharm[] }>(\"/\");\n const index = BacklinksIndex({ allCharms });\n\n const fab = OmniboxFAB({\n mentionable: index.mentionable as unknown as Cell<MentionableCharm[]>,\n });\n\n return {\n backlinksIndex: index,\n [NAME]: str`DefaultCharmList (${allCharms.length})`,\n [UI]: (\n <ct-screen>\n <ct-keybind\n code=\"KeyN\"\n alt\n preventDefault\n onct-keybind={spawnChatList()}\n />\n <ct-keybind\n code=\"KeyO\"\n meta\n preventDefault\n onct-keybind={toggleFab({ fabExpanded: fab.fabExpanded })}\n />\n <ct-keybind\n code=\"KeyO\"\n ctrl\n preventDefault\n onct-keybind={toggleFab({ fabExpanded: fab.fabExpanded })}\n />\n\n <ct-toolbar slot=\"header\" sticky>\n <div slot=\"start\">\n <ct-button\n onClick={spawnChatList()}\n >\n üìÇ Chat List\n </ct-button>\n <ct-button\n onClick={spawnChatbot()}\n >\n üí¨ Chatbot\n </ct-button>\n <ct-button\n onClick={spawnChatbotOutliner()}\n >\n üìù Chatbot Outliner\n </ct-button>\n <ct-button\n onClick={spawnNote()}\n >\n üìÑ Note\n </ct-button>\n </div>\n </ct-toolbar>\n\n <ct-vscroll flex showScrollbar>\n <ct-vstack gap=\"4\" padding=\"6\">\n <style>\n {`\n .pattern-link {\n cursor: pointer;\n color: inherit;\n text-decoration: none;\n }\n .pattern-link:hover {\n text-decoration: underline;\n }\n `}\n </style>\n <h2>Pages</h2>\n\n <ct-table full-width hover>\n <tbody>\n {allCharms.map((charm) => (\n <tr>\n <td>\n <ct-cell-context $cell={charm}>\n <ct-cell-link $cell={charm} />\n </ct-cell-context>\n </td>\n <td>\n <ct-button\n size=\"sm\"\n variant=\"ghost\"\n onClick={removeCharm({ charm, allCharms })}\n >\n üóëÔ∏è\n </ct-button>\n </td>\n </tr>\n ))}\n </tbody>\n </ct-table>\n </ct-vstack>\n </ct-vscroll>\n </ct-screen>\n ),\n sidebarUI: undefined,\n fabUI: fab[UI],\n };\n },\n);\n"}},"since":20}}},"of:baedreiczp2strjgmqqr4y4cdhnfgyxpa2p7jh2clgkahly3d2ctbm52z2i":{"application/json":{"ba4jcbt6ddwmeffgpkxsqtfzakrhur22vsc4gzalizp2kegda7jxjgdpm":{"is":{"value":{"name":"/chatbot.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n computed,\n Default,\n fetchData,\n generateObject,\n handler,\n llmDialog,\n NAME,\n pattern,\n patternTool,\n Stream,\n UI,\n VNode,\n wish,\n} from \"commontools\";\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\n\nfunction schemaifyWish<T>(path: string) {\n return wish<T>(path);\n}\n\nconst sendMessage = handler<\n {\n detail: {\n text: string;\n attachments: Array<PromptAttachment>;\n mentions: Array<any>;\n message: string; // Backward compatibility\n };\n },\n {\n addMessage: Stream<BuiltInLLMMessage>;\n }\n>((event, { addMessage }) => {\n const { text } = event.detail;\n\n // Send the message as-is. Any markdown links like [name](/of:...)\n // are just text that the LLM can parse and use with addAttachment() tool.\n addMessage.send({\n role: \"user\",\n content: [{ type: \"text\" as const, text }],\n });\n});\n\nconst clearChat = handler(\n (\n _: never,\n { messages, pending }: {\n messages: Cell<Array<BuiltInLLMMessage>>;\n pending: Cell<boolean | undefined>;\n },\n ) => {\n messages.set([]);\n pending.set(false);\n },\n);\n\ntype ChatInput = {\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n tools?: any;\n theme?: any;\n system?: string;\n};\n\ntype PromptAttachment = {\n id: string;\n name: string;\n type: \"file\" | \"clipboard\" | \"mention\";\n data?: any; // File | Blob | string\n charm?: any;\n removable?: boolean; // Whether this attachment can be removed\n};\n\ntype ChatOutput = {\n messages: Array<BuiltInLLMMessage>;\n pending: boolean | undefined;\n addMessage: Stream<BuiltInLLMMessage>;\n clearChat: Stream<void>;\n cancelGeneration: Stream<void>;\n title?: string;\n pinnedCells: Array<PromptAttachment>;\n tools: any;\n ui: {\n chatLog: VNode;\n promptInput: VNode;\n attachmentsAndTools: VNode;\n };\n};\n\nexport const TitleGenerator = pattern<\n { model?: string; messages: Array<BuiltInLLMMessage> }\n>(({ model, messages }) => {\n const previewMessage = computed(() => {\n if (!messages || messages.length === 0) return \"\";\n\n const firstMessage = messages[0];\n\n if (!firstMessage) return \"\";\n\n return JSON.stringify(firstMessage);\n });\n\n const { result } = generateObject({\n system:\n \"Generate at most a 3-word title based on the following content, respond with NOTHING but the literal title text.\",\n prompt: previewMessage,\n model,\n schema: {\n type: \"object\",\n properties: {\n title: {\n type: \"string\",\n description: \"The title of the chat\",\n },\n },\n required: [\"title\"],\n },\n });\n\n const title = computed(() => {\n return result?.title || \"Untitled Chat\";\n });\n\n return title;\n});\n\nconst listMentionable = pattern<\n { mentionable: Array<MentionableCharm> },\n { result: Array<{ label: string; cell: Cell<unknown> }> }\n>(\n ({ mentionable }) => {\n const result = mentionable.map((charm) => ({\n label: charm[NAME]!,\n cell: charm,\n }));\n return { result };\n },\n);\n\nconst listRecent = pattern<\n { recentCharms: Array<MentionableCharm> },\n { result: Array<{ label: string; cell: Cell<unknown> }> }\n>(\n ({ recentCharms }) => {\n const namesList = recentCharms.map((charm) => ({\n label: charm[NAME]!,\n cell: charm,\n }));\n return { result: namesList };\n },\n);\n\nexport default pattern<ChatInput, ChatOutput>(\n ({ messages, tools, theme, system }) => {\n const model = Cell.of<string>(\"anthropic:claude-sonnet-4-5\");\n const mentionable = schemaifyWish<MentionableCharm[]>(\"#mentionable\");\n const recentCharms = schemaifyWish<MentionableCharm[]>(\"#recent\");\n\n const assistantTools = {\n listMentionable: patternTool(listMentionable, { mentionable }),\n listRecent: patternTool(listRecent, { recentCharms }),\n };\n\n // Merge static and assistant tools\n const mergedTools = computed(() => ({\n ...tools,\n ...assistantTools,\n }));\n\n const latest = computed(() => recentCharms[0]);\n const latestName = computed(() => recentCharms[0]?.[NAME]);\n\n const {\n addMessage,\n cancelGeneration,\n pending,\n flattenedTools,\n pinnedCells,\n } = llmDialog(\n {\n system: computed(() => {\n return system ?? \"You are a polite but efficient assistant.\";\n }),\n messages,\n tools: mergedTools,\n model,\n context: computed(() => ({\n [latestName]: latest,\n })),\n },\n );\n\n const { result } = fetchData({\n url: \"/api/ai/llm/models\",\n mode: \"json\",\n });\n\n const items = computed(() => {\n if (!result) return [];\n const items = Object.keys(result as any).map((key) => ({\n label: key,\n value: key,\n }));\n return items;\n });\n\n const title = TitleGenerator({ model, messages });\n\n const promptInput = (\n <ct-prompt-input\n slot=\"footer\"\n placeholder=\"Ask the LLM a question...\"\n pending={pending}\n $mentionable={mentionable}\n modelItems={items}\n $model={model}\n onct-send={sendMessage({ addMessage })}\n onct-stop={cancelGeneration}\n />\n );\n\n const chatLog = (\n <ct-vscroll\n style=\"padding: 1rem;\"\n flex\n showScrollbar\n fadeEdges\n snapToBottom\n >\n <ct-chat\n theme={theme}\n $messages={messages}\n pending={pending}\n tools={flattenedTools}\n />\n </ct-vscroll>\n );\n\n const attachmentsAndTools = (\n <ct-hstack align=\"center\" gap=\"1\">\n <ct-cell-context $cell={pinnedCells}>\n <ct-attachments-bar pinnedCells={pinnedCells} />\n </ct-cell-context>\n <ct-tools-chip tools={flattenedTools} />\n <ct-button\n variant=\"pill\"\n type=\"button\"\n title=\"Clear chat\"\n onClick={clearChat({\n messages,\n pending,\n })}\n >\n Clear\n </ct-button>\n </ct-hstack>\n );\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <ct-vstack slot=\"header\">\n <ct-heading level={4}>{title}</ct-heading>\n {attachmentsAndTools}\n </ct-vstack>\n\n {chatLog}\n\n {promptInput}\n </ct-screen>\n ),\n messages,\n pending,\n addMessage,\n clearChat: clearChat({\n messages,\n pending,\n }),\n cancelGeneration,\n title,\n pinnedCells,\n tools: flattenedTools,\n ui: {\n chatLog,\n promptInput,\n attachmentsAndTools,\n },\n };\n },\n);\n"}},"since":20}}},"of:baedreibkc7zcxdembp7sxpowfbthuiwev4tyyvciuvwzu7egg6323czmh4":{"application/json":{"ba4jcb4arsk7c7axovlb2gztmprwn45blyew2apjcv6lgh6r3oiuqdcnv":{"is":{"value":{"name":"/chatbot-outliner.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n Default,\n derive,\n handler,\n ifElse,\n JSONSchema,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot.tsx\";\nimport { MentionableCharm } from \"./backlinks-index.tsx\";\n\ntype Charm = any;\n\ntype OutlinerNode = {\n body: Default<string, \"\">;\n children: Default<OutlinerNode[], []>;\n attachments: Default<OpaqueRef<any>[], []>;\n};\n\ntype Outliner = {\n root: OutlinerNode;\n};\n\ntype PageResult = {\n outline: Default<\n Outliner,\n { root: { body: \"\"; children: []; attachments: [] } }\n >;\n};\n\nexport type PageInput = {\n outline: Outliner;\n};\n\nconst handleCharmLinkClick = handler<\n {\n detail: {\n charm: Cell<Charm>;\n };\n },\n Record<string, never>\n>(({ detail }, _) => {\n return navigateTo(detail.charm);\n});\n\nfunction getMentionable() {\n return derive<MentionableCharm[], MentionableCharm[]>(\n wish<MentionableCharm[]>(\"#mentionable\"),\n (i) => i,\n );\n}\n\nexport const Page = recipe<PageInput>(\n \"Page\",\n ({ outline }) => {\n const mentionable = getMentionable();\n\n return {\n [NAME]: \"Page\",\n [UI]: (\n <ct-outliner\n $value={outline as any}\n $mentionable={mentionable}\n oncharm-link-click={handleCharmLinkClick({})}\n />\n ),\n outline,\n };\n },\n);\n\ntype LLMTestInput = {\n title?: Cell<Default<string, \"LLM Test\">>;\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n expandChat?: Cell<Default<boolean, false>>;\n outline?: Default<\n Outliner,\n { root: { body: \"Untitled Page\"; children: []; attachments: [] } }\n >;\n};\n\ntype LLMTestResult = {\n messages: Default<Array<BuiltInLLMMessage>, []>;\n};\n\n// put a node at the end of the outline (by appending to root.children)\nconst appendOutlinerNode = handler<\n {\n /** The text content/title of the outliner node to be appended */\n body: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { outline: Cell<Outliner> }\n>(\n (args, state) => {\n try {\n (state.outline.key(\"root\").key(\"children\")).push({\n body: args.body,\n children: [],\n attachments: [],\n });\n\n args.result.set(\n `${state.outline.key(\"root\").key(\"children\").get().length} nodes`,\n );\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nexport default recipe<LLMTestInput, LLMTestResult>(\n \"Outliner\",\n ({ title, expandChat, messages, outline }) => {\n const tools = {\n appendOutlinerNode: {\n description: \"Add a new outliner node.\",\n inputSchema: {\n type: \"object\",\n properties: {\n body: {\n type: \"string\",\n description: \"The title of the new node.\",\n },\n },\n required: [\"body\"],\n } as JSONSchema,\n handler: appendOutlinerNode({ outline }),\n },\n };\n\n const chat = Chat({ messages, tools });\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <ct-hstack justify=\"between\" slot=\"header\">\n <div></div>\n <div>\n <ct-checkbox $checked={expandChat}>Show Chat</ct-checkbox>\n </div>\n </ct-hstack>\n\n <ct-autolayout tabNames={[\"Chat\", \"Tools\"]}>\n <ct-screen>\n <div slot=\"header\">\n <ct-input\n $value={title}\n placeholder=\"Enter title...\"\n />\n </div>\n\n <ct-vscroll flex showScrollbar fadeEdges snapToBottom>\n <ct-vstack data-label=\"Tools\">\n <Page outline={outline} />\n </ct-vstack>\n </ct-vscroll>\n </ct-screen>\n\n {ifElse(\n expandChat,\n chat,\n null,\n )}\n </ct-autolayout>\n </ct-screen>\n ),\n messages,\n };\n },\n);\n"}},"since":20}}},"of:baedreigmgcvh4yl4bwa5mobdiqln6dtzz62ok6ctgh2gaiijiarqi3utkm":{"application/json":{"ba4jcbwqf32i3chop2umyg6phmnh6uuwcsqxzucot4vckoq3nyuajjyf5":{"is":{"value":{"name":"/note.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n cell,\n type Default,\n derive,\n generateText,\n handler,\n NAME,\n navigateTo,\n patternTool,\n recipe,\n str,\n Stream,\n UI,\n wish,\n} from \"commontools\";\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\ntype Input = {\n title?: Cell<Default<string, \"Untitled Note\">>;\n content?: Cell<Default<string, \"\">>;\n};\n\n/** Represents a small #note a user took to remember some text. */\ntype Output = {\n mentioned: Default<Array<MentionableCharm>, []>;\n backlinks: MentionableCharm[];\n\n content: Default<string, \"\">;\n grep: Stream<{ query: string }>;\n translate: Stream<{ language: string }>;\n editContent: Stream<{ detail: { value: string } }>;\n};\n\nconst _updateTitle = handler<\n { detail: { value: string } },\n { title: Cell<string> }\n>(\n (event, state) => {\n state.title.set(event.detail?.value ?? \"\");\n },\n);\n\nconst _updateContent = handler<\n { detail: { value: string } },\n { content: Cell<string> }\n>(\n (event, state) => {\n state.content.set(event.detail?.value ?? \"\");\n },\n);\n\nconst handleCharmLinkClick = handler<\n {\n detail: {\n charm: Cell<MentionableCharm>;\n };\n },\n Record<string, never>\n>(({ detail }, _) => {\n return navigateTo(detail.charm);\n});\n\nconst handleNewBacklink = handler<\n {\n detail: {\n text: string;\n charmId: any;\n charm: Cell<MentionableCharm>;\n navigate: boolean;\n };\n },\n {\n mentionable: Cell<MentionableCharm[]>;\n }\n>(({ detail }, { mentionable }) => {\n console.log(\"new charm\", detail.text, detail.charmId);\n\n if (detail.navigate) {\n return navigateTo(detail.charm);\n } else {\n mentionable.push(detail.charm as unknown as MentionableCharm);\n }\n});\n\n/** This edits the content */\nconst handleEditContent = handler<\n { detail: { value: string }; result?: Cell<string> },\n { content: Cell<string> }\n>(\n ({ detail, result }, { content }) => {\n content.set(detail.value);\n result?.set(\"test!\");\n },\n);\n\nconst handleCharmLinkClicked = handler<void, { charm: Cell<MentionableCharm> }>(\n (_, { charm }) => {\n return navigateTo(charm);\n },\n);\n\nfunction schemaifyWish<T>(path: string, def: T) {\n return derive(wish<T>(path) as T, (i) => i ?? def);\n}\n\nconst Note = recipe<Input, Output>(\n \"Note\",\n ({ title, content }) => {\n const mentionable = schemaifyWish<MentionableCharm[]>(\n \"#mentionable\",\n [],\n );\n const mentioned = cell<MentionableCharm[]>([]);\n\n // populated in backlinks-index.tsx\n const backlinks = cell<MentionableCharm[]>([]);\n\n // The only way to serialize a pattern, apparently?\n const pattern = derive(undefined, () => JSON.stringify(Note));\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <div slot=\"header\">\n <ct-input\n $value={title}\n placeholder=\"Enter title...\"\n />\n </div>\n\n <ct-code-editor\n $value={content}\n $mentionable={mentionable}\n $mentioned={mentioned}\n $pattern={pattern}\n onbacklink-click={handleCharmLinkClick({})}\n onbacklink-create={handleNewBacklink({ mentionable })}\n language=\"text/markdown\"\n theme=\"light\"\n wordWrap\n tabIndent\n lineNumbers\n />\n\n <ct-hstack slot=\"footer\">\n {backlinks?.map((charm) => (\n <ct-button\n onClick={handleCharmLinkClicked({ charm })}\n >\n {charm?.[NAME]}\n </ct-button>\n ))}\n </ct-hstack>\n </ct-screen>\n ),\n title,\n content,\n mentioned,\n backlinks,\n grep: patternTool(\n ({ query, content }: { query: string; content: string }) => {\n return derive({ query, content }, ({ query, content }) => {\n return content.split(\"\\n\").filter((c) => c.includes(query));\n });\n },\n { content },\n ),\n translate: patternTool(\n (\n { language, content }: {\n language: string;\n content: string;\n },\n ) => {\n const result = generateText({\n system: str`Translate the content to ${language}.`,\n prompt: str`<to_translate>${content}</to_translate>`,\n });\n\n return derive(result, ({ pending, result }) => {\n if (pending) return undefined;\n if (result == null) return \"Error occured\";\n return result;\n });\n },\n { content },\n ),\n editContent: handleEditContent({ content }),\n };\n },\n);\n\nexport default Note;\n"}},"since":20}}},"of:baedreigo5n6mtjvvxsxkwqnzmvrl6vclp2fam46mx7nzykshmgyjtyivgu":{"application/json":{"ba4jcbrirsjwxxl3j76wrhuidg2n25fp4rxs7snvygimxuasbpq2axb7f":{"is":{"value":{"name":"/backlinks-index.tsx","contents":"/// <cts-enable />\nimport { Cell, derive, lift, NAME, OpaqueRef, recipe, UI } from \"commontools\";\n\nexport type MentionableCharm = {\n [NAME]?: string;\n mentioned: MentionableCharm[];\n backlinks: MentionableCharm[];\n};\n\nexport type WriteableBacklinks = {\n mentioned: WriteableBacklinks[];\n backlinks: Cell<WriteableBacklinks[]>;\n};\n\ntype Input = {\n allCharms: MentionableCharm[];\n};\n\ntype Output = {\n mentionable: MentionableCharm[];\n};\n\nconst computeIndex = lift<\n { allCharms: WriteableBacklinks[] },\n void\n>(\n ({ allCharms }) => {\n const cs = allCharms ?? [];\n\n for (const c of cs) {\n c.backlinks?.set([]);\n }\n\n for (const c of cs) {\n const mentions = c.mentioned ?? [];\n for (const m of mentions) {\n m?.backlinks?.push(c);\n }\n }\n },\n);\n\n/**\n * BacklinksIndex builds a map of backlinks across all charms and exposes a\n * unified mentionable list for consumers like editors.\n *\n * Behavior:\n * - Backlinks are computed by scanning each charm's `mentioned` list and\n * mapping mention target -> list of source charms.\n * - Mentionable list is a union of:\n * - every charm in `allCharms`\n * - any items a charm exports via a `mentionable` property\n * (either an array of charms or a Cell of such an array)\n *\n * The backlinks map is keyed by a charm's `content` value (falling back to\n * its `[NAME]`). This mirrors how existing note patterns identify notes when\n * computing backlinks locally.\n */\nconst BacklinksIndex = recipe<Input, Output>(\n \"BacklinksIndex\",\n ({ allCharms }) => {\n computeIndex({\n allCharms: allCharms as unknown as OpaqueRef<WriteableBacklinks[]>,\n });\n\n // Compute mentionable list from allCharms reactively\n const mentionable = derive(allCharms, (charmList) => {\n const cs = charmList ?? [];\n const out: MentionableCharm[] = [];\n for (const c of cs) {\n out.push(c);\n const exported = (c as unknown as {\n mentionable?: MentionableCharm[] | { get?: () => MentionableCharm[] };\n }).mentionable;\n if (Array.isArray(exported)) {\n for (const m of exported) if (m) out.push(m);\n } else if (exported && typeof (exported as any).get === \"function\") {\n const arr = (exported as { get: () => MentionableCharm[] }).get() ??\n [];\n for (const m of arr) if (m) out.push(m);\n }\n }\n return out;\n });\n\n return {\n [NAME]: \"BacklinksIndex\",\n [UI]: undefined,\n mentionable,\n };\n },\n);\n\nexport default BacklinksIndex;\n"}},"since":20}}},"of:baedreiam356b7666ueqii5minnknx2nes4rblkbvqnp7ogzjqoislg65du":{"application/json":{"ba4jcbfoua2vmphnb46podjhdafqebq4lcekcmr5qgxyyfzpdbgibof6r":{"is":{"value":{"name":"/chatbot-list-view.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n Default,\n derive,\n handler,\n ID,\n ifElse,\n lift,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n toSchema,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot-note-composed.tsx\";\nimport { ListItem } from \"./common-tools.tsx\";\n\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\ntype CharmEntry = {\n [ID]: string; // randomId is a string\n local_id: string; // same as ID but easier to access\n charm: any;\n};\n\ntype Input = {\n selectedCharm: Default<{ charm: any }, { charm: undefined }>;\n charmsList: Default<CharmEntry[], []>;\n theme?: {\n accentColor: Cell<Default<string, \"#3b82f6\">>;\n fontFace: Cell<Default<string, \"system-ui, -apple-system, sans-serif\">>;\n borderRadius: Cell<Default<string, \"0.5rem\">>;\n };\n};\n\ntype Output = {\n selectedCharm: Default<{ charm: any }, { charm: undefined }>;\n // Expose a mentionable list aggregated from local chat entries\n // Returned as an opaque ref to an array (not a Cell), suitable for\n // upstream aggregators that read exported mentionables.\n mentionable?: MentionableCharm[];\n};\n\nconst removeChat = handler<\n unknown,\n {\n charmsList: Cell<CharmEntry[]>;\n id: string;\n selectedCharm: Cell<Default<{ charm: any }, { charm: undefined }>>;\n }\n>(\n (\n _,\n { charmsList, id, selectedCharm },\n ) => {\n const list = charmsList.get();\n const index = list.findIndex((entry) => entry.local_id === id);\n if (index === -1) return;\n\n const removed = list[index];\n const next = [...list];\n next.splice(index, 1);\n charmsList.set(next);\n\n // If we removed the currently selected charm, choose a new selection.\n const current = selectedCharm.get();\n if (current?.charm === removed.charm) {\n const replacement = next[index] ?? next[index - 1];\n if (replacement) {\n selectedCharm.set({ charm: replacement.charm });\n } else {\n selectedCharm.set({ charm: undefined as unknown as any });\n }\n }\n },\n);\n\n// this will be called whenever charm or selectedCharm changes\n// pass isInitialized to make sure we dont call this each time\n// we change selectedCharm, otherwise creates a loop\nconst storeCharm = lift(\n toSchema<{\n charm: any;\n selectedCharm: Cell<Default<{ charm: any }, { charm: undefined }>>;\n charmsList: Cell<CharmEntry[]>;\n allCharms: Cell<MentionableCharm[]>;\n theme?: {\n accentColor: Default<string, \"#3b82f6\">;\n fontFace: Default<string, \"system-ui, -apple-system, sans-serif\">;\n borderRadius: Default<string, \"0.5rem\">;\n };\n isInitialized: Cell<boolean>;\n }>(),\n undefined,\n ({ charm, selectedCharm, charmsList, isInitialized, allCharms: _ }) => { // Not including `allCharms` is a compile error...\n if (!isInitialized.get()) {\n console.log(\n \"storeCharm storing charm:\",\n charm,\n );\n selectedCharm.set({ charm });\n\n // create the chat charm with a custom name including a random suffix\n const randomId = Math.random().toString(36).substring(2, 10); // Random 8-char string\n charmsList.push({ [ID]: randomId, local_id: randomId, charm });\n\n isInitialized.set(true);\n return charm;\n } else {\n console.log(\"storeCharm: already initialized\");\n }\n return undefined;\n },\n);\n\nconst populateChatList = lift(\n toSchema<{\n charmsList: CharmEntry[];\n allCharms: Cell<any[]>;\n selectedCharm: Cell<{ charm: any }>;\n }>(),\n undefined,\n (\n { charmsList, allCharms, selectedCharm },\n ) => {\n if (charmsList.length === 0) {\n const isInitialized = Cell.of(false);\n return storeCharm({\n charm: Chat({\n title: \"New Chat\",\n messages: [],\n }),\n selectedCharm,\n charmsList,\n allCharms,\n isInitialized: isInitialized as unknown as Cell<boolean>,\n });\n }\n\n return charmsList;\n },\n);\n\nconst createChatRecipe = handler<\n unknown,\n {\n selectedCharm: Cell<{ charm: any }>;\n charmsList: Cell<CharmEntry[]>;\n allCharms: Cell<MentionableCharm[]>;\n }\n>(\n (_, { selectedCharm, charmsList, allCharms }) => {\n const isInitialized = Cell.of(false);\n\n const charm = Chat({\n title: \"New Chat\",\n messages: [],\n });\n // store the charm ref in a cell (pass isInitialized to prevent recursive calls)\n return storeCharm({\n charm,\n selectedCharm,\n charmsList: charmsList as unknown as OpaqueRef<CharmEntry[]>,\n allCharms,\n isInitialized: isInitialized as unknown as Cell<boolean>,\n });\n },\n);\n\nconst selectCharm = handler<\n unknown,\n { selectedCharm: Cell<{ charm: any }>; charm: any }\n>(\n (_, { selectedCharm, charm }) => {\n console.log(\"selectCharm: updating selectedCharm to \", charm);\n selectedCharm.set({ charm });\n return selectedCharm;\n },\n);\n\nconst logCharmsList = lift<\n { charmsList: Cell<CharmEntry[]> },\n Cell<CharmEntry[]>\n>(\n ({ charmsList }) => {\n console.log(\"logCharmsList: \", charmsList.get());\n return charmsList;\n },\n);\n\nconst _handleCharmLinkClicked = handler(\n (_: any, { charm }: { charm: Cell<MentionableCharm> }) => {\n return navigateTo(charm);\n },\n);\n\nconst _merge = lift(\n (\n { allCharms, charmsList }: { allCharms: any[]; charmsList: CharmEntry[] },\n ) => {\n return [...charmsList.map((c) => c.charm), ...allCharms];\n },\n);\n\nconst getSelectedCharm = lift<\n { entry: { charm: any | undefined } },\n {\n chat: unknown;\n list: ListItem[];\n } | undefined\n>(\n ({ entry }) => {\n return entry?.charm;\n },\n);\n\nconst getCharmName = lift(({ charm }: { charm: any }) => {\n return charm?.[NAME] || \"Unknown\";\n});\n\nconst extractLocalMentionable = lift<\n { list: CharmEntry[] },\n MentionableCharm[]\n>(({ list }) => {\n const out: MentionableCharm[] = [];\n for (const entry of list) {\n const c = entry.charm;\n out.push(c.chat);\n }\n return out;\n});\n\n// create the named cell inside the recipe body, so we do it just once\nexport default recipe<Input, Output>(\n \"Launcher\",\n ({ selectedCharm, charmsList, theme }) => {\n const allCharms = derive<MentionableCharm[], MentionableCharm[]>(\n wish<MentionableCharm[]>(\"#allCharms\"),\n (c) => c ?? [],\n );\n logCharmsList({ charmsList: charmsList as unknown as Cell<CharmEntry[]> });\n\n populateChatList({\n selectedCharm: selectedCharm as unknown as Cell<\n Pick<CharmEntry, \"charm\">\n >,\n charmsList,\n allCharms,\n });\n\n const selected = getSelectedCharm({ entry: selectedCharm });\n\n // Aggregate mentionables from the local charms list so that this\n // container exposes its child chat charms as mention targets.\n const localMentionable = extractLocalMentionable({ list: charmsList });\n\n const localTheme = theme ?? {\n accentColor: Cell.of(\"#3b82f6\"),\n fontFace: Cell.of(\"system-ui, -apple-system, sans-serif\"),\n borderRadius: Cell.of(\"0.5rem\"),\n };\n\n return {\n [NAME]: \"Launcher\",\n [UI]: (\n <ct-theme theme={localTheme as any}>\n <ct-screen>\n <div slot=\"header\">\n <ct-toolbar dense sticky>\n <div slot=\"start\">\n <ct-button\n id=\"new-chat-btn\"\n onClick={createChatRecipe({\n selectedCharm,\n charmsList,\n allCharms,\n })}\n >\n Create New Chat\n <ct-kbd>alt+N</ct-kbd>\n </ct-button>\n </div>\n </ct-toolbar>\n\n {/* Keyboard shortcuts */}\n <ct-keybind\n code=\"KeyN\"\n alt\n preventDefault\n onct-keybind={createChatRecipe({\n selectedCharm,\n charmsList,\n allCharms,\n })}\n />\n </div>\n <ct-autolayout\n leftOpen\n rightOpen={false}\n >\n {/* workaround: this seems to correctly start the sub-recipes on a refresh while directly rendering does not */}\n {/* this should be fixed after the builder-refactor (DX1) */}\n <ct-screen>\n <ct-render $cell={selected.chat} />\n </ct-screen>\n\n <aside slot=\"left\">\n <div>\n <ct-heading level={3}>Chat List</ct-heading>\n </div>\n <div role=\"list\">\n {charmsList.map((charmEntry) => (\n <ct-list-item\n onct-activate={selectCharm({\n selectedCharm,\n charm: charmEntry.charm,\n })}\n >\n <span>{getCharmName({ charm: charmEntry.charm })}</span>\n <span slot=\"meta\">{charmEntry.local_id}</span>\n <ct-button\n slot=\"actions\"\n size=\"sm\"\n title=\"Delete Chat\"\n variant=\"destructive\"\n onClick={removeChat({\n charmsList: charmsList as unknown as OpaqueRef<\n CharmEntry[]\n >,\n id: charmEntry.local_id,\n selectedCharm: selectedCharm as unknown as OpaqueRef<\n Default<{ charm: any }, { charm: undefined }>\n >,\n })}\n >\n üóëÔ∏è\n </ct-button>\n </ct-list-item>\n ))}\n </div>\n </aside>\n\n <aside slot=\"right\">\n {ifElse(\n selected,\n <>\n <ct-ct-collapsible>\n <ct-heading slot=\"trigger\" level={5} no-margin>\n List\n </ct-heading>\n <ct-list $value={selected.list} />\n </ct-ct-collapsible>\n </>,\n null,\n )}\n <ct-collapsible>\n <ct-heading slot=\"trigger\" level={5} no-margin>\n Theme\n </ct-heading>\n <ct-vstack style=\"padding: 0.5rem 0; gap: 0.5rem;\">\n <ct-vstack>\n <ct-text>Font Family</ct-text>\n <ct-select\n items={[\n {\n label: \"System\",\n value: \"system-ui, -apple-system, sans-serif\",\n },\n {\n label: \"Monospace\",\n value: \"ui-monospace, Consolas, monospace\",\n },\n {\n label: \"Serif\",\n value: \"Georgia, Times, serif\",\n },\n {\n label: \"Sans Serif\",\n value: \"Arial, Helvetica, sans-serif\",\n },\n ]}\n $value={localTheme.fontFace}\n />\n </ct-vstack>\n\n <ct-vstack>\n <ct-text>Accent Color</ct-text>\n <ct-select\n items={[\n { label: \"Blue\", value: \"#3b82f6\" },\n { label: \"Purple\", value: \"#8b5cf6\" },\n { label: \"Green\", value: \"#10b981\" },\n { label: \"Red\", value: \"#ef4444\" },\n { label: \"Orange\", value: \"#f97316\" },\n { label: \"Pink\", value: \"#ec4899\" },\n { label: \"Indigo\", value: \"#6366f1\" },\n { label: \"Teal\", value: \"#14b8a6\" },\n ]}\n $value={localTheme.accentColor}\n />\n </ct-vstack>\n\n <ct-vstack>\n <ct-text>Border Radius</ct-text>\n <ct-select\n items={[\n { label: \"None\", value: \"0px\" },\n { label: \"Small\", value: \"0.25rem\" },\n { label: \"Medium\", value: \"0.5rem\" },\n { label: \"Large\", value: \"0.75rem\" },\n { label: \"Extra Large\", value: \"1rem\" },\n { label: \"Rounded\", value: \"1.5rem\" },\n ]}\n $value={localTheme.borderRadius}\n />\n </ct-vstack>\n </ct-vstack>\n </ct-collapsible>\n </aside>\n </ct-autolayout>\n </ct-screen>\n </ct-theme>\n ),\n selectedCharm,\n charmsList,\n // Expose the aggregated mentionables for parent-level indexing.\n mentionable: localMentionable,\n };\n },\n);\n"}},"since":20}}},"of:baedreiaconf4zx2gafumhuetpthdpy6ncqtjjnlagr2mjfzrtuygwatzju":{"application/json":{"ba4jcbr2plisj6q563jgf3recfb534r7dzbq3p54wcylyo42ywjs6ewn4":{"is":{"value":{"name":"/omnibox-fab.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n computed,\n handler,\n ifElse,\n NAME,\n pattern,\n patternTool,\n UI,\n} from \"commontools\";\nimport Chatbot from \"./chatbot.tsx\";\nimport {\n calculator,\n fetchAndRunPattern,\n listPatternIndex,\n navigateToPattern,\n readWebpage,\n searchWeb,\n} from \"./common-tools.tsx\";\nimport { MentionableCharm } from \"./backlinks-index.tsx\";\n\ninterface OmniboxFABInput {\n mentionable: Cell<MentionableCharm[]>;\n}\n\nconst toggle = handler<any, { value: Cell<boolean> }>((_, { value }) => {\n value.set(!value.get());\n});\n\nconst closeFab = handler<any, { fabExpanded: Cell<boolean> }>(\n (_, { fabExpanded }) => {\n fabExpanded.set(false);\n },\n);\n\nconst dismissPeek = handler<\n any,\n { peekDismissedIndex: Cell<number>; assistantMessageCount: number }\n>((_, { peekDismissedIndex, assistantMessageCount }) => {\n // Store the current assistant message count so we know which message was dismissed\n peekDismissedIndex.set(assistantMessageCount);\n});\n\nexport default pattern<OmniboxFABInput>(\n (_) => {\n const omnibot = Chatbot({\n system:\n \"You are a polite but efficient assistant. Think Star Trek computer - helpful and professional without unnecessary conversation. Let your actions speak for themselves.\\n\\nTool usage priority:\\n- For patterns: listPatternIndex first\\n- For existing pages/notes/content: listRecent or listMentionable to identify what they're referencing\\n- Attach relevant items to conversation after instantiation/retrieval if they support ongoing tasks\\n- Remove attachments when no longer relevant\\n- Search web only as last resort when nothing exists in the space\\n\\nBe matter-of-fact. Prefer action to explanation.\",\n tools: {\n searchWeb: {\n pattern: searchWeb,\n },\n readWebpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n fetchAndRunPattern: patternTool(fetchAndRunPattern),\n listPatternIndex: patternTool(listPatternIndex),\n navigateTo: patternTool(navigateToPattern),\n },\n });\n\n const fabExpanded = Cell.of(false);\n const showHistory = Cell.of(false);\n const peekDismissedIndex = Cell.of(-1); // Track which message index was dismissed\n\n // Derive assistant message count for dismiss tracking\n const assistantMessageCount = computed(() => {\n return omnibot.messages.filter((m) => m.role === \"assistant\").length;\n });\n\n // Derive latest assistant message for peek\n const latestAssistantMessage = computed(() => {\n if (!omnibot.messages || omnibot.messages.length === 0) return null;\n\n for (let i = omnibot.messages.length - 1; i >= 0; i--) {\n const msg = omnibot.messages[i];\n if (msg.role === \"assistant\") {\n const content = typeof msg.content === \"string\"\n ? msg.content\n : msg.content.map((part: any) => {\n if (part.type === \"text\") return part.text;\n return \"\";\n }).join(\"\");\n\n return content;\n }\n }\n return null;\n });\n\n return {\n [NAME]: \"OmniboxFAB\",\n messages: omnibot.messages,\n [UI]: (\n <ct-fab\n expanded={computed(() => fabExpanded.get())}\n variant=\"primary\"\n position=\"bottom-right\"\n pending={omnibot.pending}\n $previewMessage={latestAssistantMessage}\n onct-fab-backdrop-click={closeFab({ fabExpanded })}\n onct-fab-escape={closeFab({ fabExpanded })}\n onClick={toggle({ value: fabExpanded })}\n >\n <div style=\"width: 100%; display: flex; flex-direction: column; max-height: 580px;\">\n {/* Chevron at top - the \"handle\" for the drawer */}\n <div style=\"border-bottom: 1px solid #e5e5e5; flex-shrink: 0;\">\n <ct-chevron-button\n expanded={computed(() => showHistory.get())}\n loading={omnibot.pending}\n onct-toggle={toggle({ value: showHistory })}\n />\n </div>\n\n <div\n style={computed(() => {\n const show = showHistory.get();\n return `flex: ${\n show ? \"1\" : \"0\"\n }; min-height: 0; display: flex; flex-direction: column; opacity: ${\n show ? \"1\" : \"0\"\n }; max-height: ${\n show ? \"480px\" : \"0\"\n }; overflow: hidden; transition: opacity 300ms ease, max-height 400ms cubic-bezier(0.34, 1.56, 0.64, 1), flex 400ms cubic-bezier(0.34, 1.56, 0.64, 1); pointer-events: ${\n show ? \"auto\" : \"none\"\n };`;\n })}\n >\n <div style=\"padding: .25rem; flex-shrink: 0;\">\n {omnibot.ui.attachmentsAndTools}\n </div>\n <div style=\"flex: 1; overflow-y: auto; min-height: 0;\">\n <ct-cell-context $cell={omnibot}>\n {omnibot.ui.chatLog}\n </ct-cell-context>\n </div>\n </div>\n\n {ifElse(\n computed(() => {\n const show = showHistory.get();\n const dismissedIdx = peekDismissedIndex.get();\n return !show && latestAssistantMessage &&\n assistantMessageCount !== dismissedIdx;\n }),\n <div style=\"margin: .5rem; margin-bottom: 0; padding: 0; flex-shrink: 0; position: relative;\">\n <ct-button\n variant=\"ghost\"\n size=\"icon\"\n onClick={dismissPeek({\n peekDismissedIndex,\n assistantMessageCount,\n })}\n style=\"position: absolute; top: 0px; right: 0px; z-index: 1; font-size: 16px;\"\n title=\"Dismiss\"\n >\n √ó\n </ct-button>\n <div\n onClick={toggle({ value: showHistory })}\n style=\"cursor: pointer;\"\n >\n <ct-cell-context $cell={latestAssistantMessage}>\n <ct-chat-message\n role=\"assistant\"\n compact\n content={latestAssistantMessage}\n pending={omnibot.pending}\n />\n </ct-cell-context>\n </div>\n </div>,\n null,\n )}\n\n {/* Prompt input - always at bottom */}\n <div style=\"padding: 0.5rem; flex-shrink: 0;\">\n {omnibot.ui.promptInput}\n </div>\n </div>\n </ct-fab>\n ),\n fabExpanded,\n };\n },\n);\n"}},"since":20}}},"of:baedreiayx6zri6trvdy7qaw5ljqys5fb64tlzmd6pih5afnpdyqcnhau5y":{"application/json":{"ba4jcbh6cwld4jbyaablnjvoxyng7o6zltqfvv2yybv6wy5i5ajsielq6":{"is":{"value":{"name":"/chatbot-note-composed.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n cell,\n Default,\n derive,\n handler,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot.tsx\";\nimport Note from \"./note.tsx\";\nimport {\n addListItem,\n calculator,\n ListItem,\n readListItems,\n readWebpage,\n searchWeb,\n} from \"./common-tools.tsx\";\n\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\n\nfunction schemaifyWish<T>(path: string, def: T) {\n return derive(wish<T>(path), (i) => i ?? def);\n}\n\ntype ChatbotNoteInput = {\n title?: Cell<Default<string, \"LLM Test\">>;\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n};\n\ntype ChatbotNoteResult = {\n messages: Default<Array<BuiltInLLMMessage>, []>;\n chat: any;\n list: Default<ListItem[], []>;\n // Optional: expose sub-charms as mentionable targets\n mentionable?: MentionableCharm[];\n};\n\nconst newNote = handler<\n {\n /** The text content of the note */\n title: string;\n content?: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allCharms: Cell<MentionableCharm[]>; index: any }\n>(\n (args, _) => {\n try {\n const n = Note({\n title: args.title,\n content: args.content ?? \"\",\n });\n\n args.result.set(\n `Created note ${args.title}`,\n );\n\n // TODO(bf): we have to navigate here until DX1 lands\n // then we go back to pushing to allCharms\n return navigateTo(n);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst listMentionable = handler<\n {\n /** A cell to store the result text */\n result: Cell<string>;\n },\n { mentionable: MentionableCharm[] }\n>(\n (args, state) => {\n try {\n const namesList = state.mentionable.map((charm) => charm[NAME]);\n args.result.set(JSON.stringify(namesList));\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst readContentByIndex = handler<\n {\n /** A cell to store the result text */\n index: number;\n result: Cell<string>;\n },\n { allNotes: Note[] }\n>(\n (args, state) => {\n try {\n args.result.set(\n state.allNotes[args.index]?.content || \"No content found\",\n );\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\ntype Note = MentionableCharm & { content: string };\nconst editContentByIndex = handler<\n {\n /** The index of the note to edit */\n index: number;\n /** The new text content of the note */\n body: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allNotes: Cell<Note[]> }\n>(\n (args, state) => {\n try {\n const charms = state.allNotes.get();\n if (args.index < 0 || args.index >= charms.length) {\n args.result.set(`Error: Invalid index ${args.index}`);\n return;\n }\n\n state.allNotes.key(args.index).key(\"content\").set(args.body);\n args.result.set(`Updated note at index ${args.index}!`);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst navigateToNote = handler<\n {\n /** The index of the note to navigate to */\n index: number;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allCharms: Cell<MentionableCharm[]> }\n>(\n (args, state) => {\n try {\n const charms = state.allCharms.get();\n if (args.index < 0 || args.index >= charms.length) {\n args.result.set(`Error: Invalid index ${args.index}`);\n return;\n }\n\n const targetCharm = charms[args.index];\n args.result.set(`Navigating to note: ${targetCharm[NAME]}`);\n\n return navigateTo(state.allCharms.key(args.index));\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\ntype BacklinksIndex = {\n mentionable: MentionableCharm[];\n};\n\nexport default recipe<ChatbotNoteInput, ChatbotNoteResult>(\n \"Chatbot + Note\",\n ({ title, messages }) => {\n const allCharms = schemaifyWish<MentionableCharm[]>(\"#allCharms\", []);\n const index = schemaifyWish<BacklinksIndex>(\"#default/backlinksIndex\", {\n mentionable: [],\n });\n const mentionable = schemaifyWish<MentionableCharm[]>(\n \"#mentionable\",\n [],\n );\n\n const list = cell<ListItem[]>([]);\n\n const tools = {\n searchWeb: {\n pattern: searchWeb,\n },\n readWebpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n addListItem: {\n handler: addListItem({ list }),\n },\n readListItems: {\n handler: readListItems({ list }),\n },\n listMentionable: {\n description:\n \"List all mentionable items titles (read the body with readNoteByIndex).\",\n handler: listMentionable({ mentionable }),\n },\n readContentByIndex: {\n description:\n \"Read the content of a mentionable by its index in the listMentionable() list (if possible)\",\n handler: readContentByIndex({\n allNotes: mentionable as unknown as OpaqueRef<Note[]>,\n }),\n },\n editContentByIndex: {\n description:\n \"Edit the content of a mentionable by its index in the listMentionable() list (if possible)\",\n handler: editContentByIndex({\n allNotes: mentionable as unknown as OpaqueRef<Note[]>,\n }),\n },\n navigateToNote: {\n description:\n \"Navigate to a mentionable by its index in the listMentionable() list.\",\n handler: navigateToNote({\n allCharms: allCharms as unknown as OpaqueRef<MentionableCharm[]>,\n }),\n },\n newNote: {\n description: \"Create a new note instance\",\n handler: newNote({\n allCharms: allCharms as unknown as OpaqueRef<MentionableCharm[]>,\n index: index as unknown as OpaqueRef<any>,\n }),\n },\n };\n\n const chat = Chat({ messages, tools });\n\n return {\n [NAME]: title,\n chat,\n messages,\n list,\n // Expose sub-charms as mentionable targets\n mentionable: [chat as unknown as MentionableCharm],\n };\n },\n);\n"}},"since":20}}},"of:baedreigayykp34gmnn2ckdu2zfleo6tyu3qqo46p2fifo44yez3htt227i":{"application/json":{"ba4jcbaoftoa3n7imawbtj4kexj4z4mizwaebrix47gtckoqhokb7z36g":{"is":{"value":{"name":"/common-tools.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMTool,\n Cell,\n compileAndRun,\n computed,\n derive,\n fetchData,\n fetchProgram,\n handler,\n ifElse,\n navigateTo,\n recipe,\n} from \"commontools\";\n\n///// COMMON TOOLS (get it?) ////\n\n/**\n * Calculate the result of a mathematical expression.\n * Supports +, -, *, /, and parentheses.\n */\ntype CalculatorRequest = {\n /** The mathematical expression to evaluate. */\n expression: string;\n /** The base to use for the calculation. */\n base?: number;\n};\n\nexport const calculator = recipe<\n CalculatorRequest,\n string | { error: string }\n>(({ expression, base }) => {\n return derive({ expression, base }, ({ expression, base }) => {\n const sanitized = expression.replace(/[^0-9+\\-*/().\\s]/g, \"\");\n let sanitizedBase = Number(base);\n if (\n Number.isNaN(sanitizedBase) || sanitizedBase < 2 || sanitizedBase > 36\n ) {\n sanitizedBase = 10;\n }\n let result;\n try {\n result = Function(\n `\"use strict\"; return Number(${sanitized}).toString(${sanitizedBase})`,\n )();\n } catch (error) {\n result = { error: (error as any)?.message || \"<error>\" };\n }\n return result;\n });\n});\n\n/** Add an item to the list. */\ntype AddListItemRequest = {\n /** The item to add to the list. */\n item: string;\n result: Cell<string>;\n};\n\n/** Read all items from the list. */\ntype ReadListItemsRequest = {\n result: Cell<string>;\n};\n\nexport type ListItem = {\n title: string;\n};\n\nexport const addListItem = handler<\n AddListItemRequest,\n { list: Cell<ListItem[]> }\n>(\n (args, state) => {\n try {\n state.list.push({ title: args.item });\n args.result.set(`${state.list.get().length} items`);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nexport const readListItems = handler<\n ReadListItemsRequest,\n { list: ListItem[] }\n>(\n (args, state) => {\n try {\n const items = state.list;\n if (items.length === 0) {\n args.result.set(\"The list is empty\");\n } else {\n const itemList = items.map((item, index) =>\n `${index + 1}. ${item.title}`\n ).join(\"\\n\");\n args.result.set(`List items (${items.length} total):\\n${itemList}`);\n }\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\n/** Search the web for information. */\ntype SearchQuery = {\n /** The query to search the web for. */\n query: string;\n};\n\ntype SearchWebResult = {\n results: {\n title: string;\n url: string;\n description: string;\n }[];\n};\n\nexport const searchWeb = recipe<\n SearchQuery,\n SearchWebResult | { error: string }\n>(({ query }) => {\n const { result, error } = fetchData<SearchWebResult>({\n url: \"/api/agent-tools/web-search\",\n mode: \"json\",\n options: {\n method: \"POST\",\n headers: {\n \"Content-Type\": \"application/json\",\n },\n body: {\n query,\n max_results: 5,\n },\n },\n });\n\n // TODO(seefeld): Should we instead return { result, error }? Or allocate a\n // special [ERROR] for errors? Ideally this isn't specific to using recipes as\n // tools but a general pattern.\n return ifElse(error, { error }, result);\n});\n\n/** Read and extract content from a specific webpage URL. */\ntype ReadWebRequest = {\n /** The URL of the webpage to read and extract content from. */\n url: string;\n};\n\ntype ReadWebResult = {\n content: string;\n metadata: {\n title?: string;\n author?: string;\n date?: string;\n word_count: number;\n };\n};\n\nexport const readWebpage = recipe<\n ReadWebRequest,\n ReadWebResult | { error: string }\n>(({ url }) => {\n const { result, error } = fetchData<ReadWebResult>({\n url: \"/api/agent-tools/web-read\",\n mode: \"json\",\n options: {\n method: \"POST\",\n headers: {\n \"Content-Type\": \"application/json\",\n },\n body: {\n url,\n max_tokens: 4000,\n include_code: true,\n },\n },\n });\n\n return ifElse(error, { error }, result);\n});\n\ntype ToolsInput = {\n list: ListItem[];\n};\n\nexport default recipe<ToolsInput>(({ list }) => {\n const tools: Record<string, BuiltInLLMTool> = {\n search_web: {\n pattern: searchWeb,\n },\n read_webpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n addListItem: {\n handler: addListItem({ list }),\n },\n };\n\n return { tools, list };\n});\n\n/**\n * `fetchAndRunPattern({ url: \"https://...\", args: {} })`\n *\n * Instantiates patterns (e.g. from listPatternIndex) and returns the cell that\n * contains the results. The instantiated pattern will keep running and updating\n * the cell. Pass the resulting cell to `navigateTo` to show the pattern's UI.\n *\n * Pass in arguments to initialize the pattern. It's especially useful to pass\n * in links to other cells as `{ \"@link\": \"/of:bafe.../path/to/data\" }`.\n */\ntype FetchAndRunPatternInput = {\n url: string;\n args: Cell<any>;\n};\nexport const fetchAndRunPattern = recipe<FetchAndRunPatternInput>(\n ({ url, args }) => {\n const { pending: _fetchPending, result: program, error: _fetchError } =\n fetchProgram({ url });\n\n // Use derive to safely handle when program is undefined/pending\n const compileParams = derive(program, (p) => ({\n files: p?.files ?? [],\n main: p?.main ?? \"\",\n input: args,\n }));\n\n const { pending, result, error } = compileAndRun(compileParams);\n\n return ifElse(\n computed(() => pending || (!result && !error)),\n undefined,\n {\n cell: result,\n error,\n },\n );\n },\n);\n\n/**\n * `navigateTo({ cell: { \"@link\": \"/of:xyz\" } })` - Navigates to that cell's UI\n *\n * Especially useful after instantiating a pattern with fetchAndRunPattern:\n * Pass the \"@link\" you get at `cell` to navigate to the pattern's view.\n */\ntype NavigateToPatternInput = { cell: Cell<any> }; // Hack to steer LLM\nexport const navigateToPattern = recipe<NavigateToPatternInput>(\n ({ cell }) => {\n const success = navigateTo(cell);\n\n return ifElse(success, { success }, undefined);\n },\n);\n\n/**\n * `listPatternIndex()` - Returns the index of patterns.\n *\n * Useful as input to fetchAndRun.\n */\ntype ListPatternIndexInput = Record<string, never>;\n\nexport const listPatternIndex = recipe<ListPatternIndexInput>(\n ({ _ }) => {\n const { pending, result } = fetchData({\n url: \"/api/patterns/index.md\",\n mode: \"text\",\n });\n return ifElse(computed(() => pending || !result), undefined, { result });\n },\n);\n"}},"since":20}}}}}}}	61798	
16:19:04.518
{"invocation":{"cmd":"/memory/transact","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"changes":{"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi":{"application/json":{"ba4jcblbv4ntpujeldyyue27yrq2irathuskqiaxldyaxrv6konvwamk2":{"is":{"source":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"},"value":{"backlinksIndex":{"$alias":{"path":["internal","backlinksIndex"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}},"$NAME":{"$alias":{"path":["internal","$NAME"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}},"$UI":{"type":"vnode","name":"ct-screen","props":{},"children":[{"type":"vnode","name":"ct-keybind","props":{"code":"KeyN","alt":true,"preventDefault":true,"onct-keybind":{"$alias":{"path":["internal","__#5stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":[]},{"type":"vnode","name":"ct-keybind","props":{"code":"KeyO","meta":true,"preventDefault":true,"onct-keybind":{"$alias":{"path":["internal","__#4stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":[]},{"type":"vnode","name":"ct-keybind","props":{"code":"KeyO","ctrl":true,"preventDefault":true,"onct-keybind":{"$alias":{"path":["internal","__#3stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":[]},{"type":"vnode","name":"ct-toolbar","props":{"slot":"header","sticky":true},"children":[{"type":"vnode","name":"div","props":{"slot":"start"},"children":[{"type":"vnode","name":"ct-button","props":{"onClick":{"$alias":{"path":["internal","__#6stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":["üìÇ Chat List"]},{"type":"vnode","name":"ct-button","props":{"onClick":{"$alias":{"path":["internal","__#7stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":["üí¨ Chatbot"]},{"type":"vnode","name":"ct-button","props":{"onClick":{"$alias":{"path":["internal","__#8stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":["üìù Chatbot Outliner"]},{"type":"vnode","name":"ct-button","props":{"onClick":{"$alias":{"path":["internal","__#9stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":["üìÑ Note"]}]}]},{"type":"vnode","name":"ct-vscroll","props":{"flex":true,"showScrollbar":true},"children":[{"type":"vnode","name":"ct-vstack","props":{"gap":"4","padding":"6"},"children":[{"type":"vnode","name":"style","props":{},"children":["\n .pattern-link {\n cursor: pointer;\n color: inherit;\n text-decoration: none;\n }\n .pattern-link:hover {\n text-decoration: underline;\n }\n "]},{"type":"vnode","name":"h2","props":{},"children":["Pages"]},{"type":"vnode","name":"ct-table","props":{"full-width":true,"hover":true},"children":[{"type":"vnode","name":"tbody","props":{},"children":[{"$alias":{"path":["internal","__#1"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}]}]}]}]}]},"fabUI":{"$alias":{"path":["internal","__#2","$UI"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}}}}}},"of:baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu":{"application/json":{"ba4jcazs5e433hye4ml2gbzpvghtfb52vewegfxh4ozbugojp4idpgmwv":{"is":{"value":{"$TYPE":"ba4jcaodz2xu6wbjq3i54qb4dily77jzm6ofnrimmtbv6lcfgexob2umv","resultRef":{"/":{"link@1":{"path":[],"id":"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi","schema":{"type":"object","properties":{"backlinksIndex":{"type":"object","properties":{"mentionable":{"$ref":"#/$defs/AnonymousType_1"}},"required":["mentionable"]},"sidebarUI":true,"fabUI":true},"additionalProperties":true,"required":["backlinksIndex","sidebarUI","fabUI"],"$defs":{"AnonymousType_1":{"type":"array","items":{"$ref":"#/$defs/MentionableCharm"}},"MentionableCharm":{"type":"object","properties":{"mentioned":{"$ref":"#/$defs/AnonymousType_1"},"backlinks":{"$ref":"#/$defs/AnonymousType_1"},"$NAME":{"type":"string"}},"required":["mentioned","backlinks"]}}},"rootSchema":{"type":"object","properties":{"backlinksIndex":{"type":"object","properties":{"mentionable":{"$ref":"#/$defs/AnonymousType_1"}},"required":["mentionable"]},"sidebarUI":true,"fabUI":true},"additionalProperties":true,"required":["backlinksIndex","sidebarUI","fabUI"],"$defs":{"AnonymousType_1":{"type":"array","items":{"$ref":"#/$defs/MentionableCharm"}},"MentionableCharm":{"type":"object","properties":{"mentioned":{"$ref":"#/$defs/AnonymousType_1"},"backlinks":{"$ref":"#/$defs/AnonymousType_1"},"$NAME":{"type":"string"}},"required":["mentioned","backlinks"]}}}}}},"internal":{"__#3stream":{"$stream":true},"__#4stream":{"$stream":true},"__#5stream":{"$stream":true},"__#6stream":{"$stream":true},"__#7stream":{"$stream":true},"__#8stream":{"$stream":true},"__#9stream":{"$stream":true}},"spell":{"/":{"link@1":{"id":"of:baedreiayeohgxjzmij53y63lgaax5ndolqk5ksdwu6xscel4kx2m2s6c3q"}}},"argument":{}}}}}}}},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcawu6glgw2l33s3tpzkwfettmcznjol2vm6d7rqegyq4fayrde65x":{}},"signature":{"/":{"bytes":"0cIh3Vzzv4vJQZ57UdayDlhlspxlelbweeZ9al59soVGrfSKRXyB9trAJmfKMQiuNy0XFWf/kaYysCQuVoC8AQ"}}}}	5759	
16:19:04.528
{"invocation":{"cmd":"/memory/graph/query","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"selectSchema":{"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi":{"application/json":{"_":{"path":[],"schemaContext":{"schema":{"type":"object","properties":{"backlinksIndex":{"type":"object","properties":{"mentionable":{"$ref":"#/$defs/AnonymousType_1"}},"required":["mentionable"]},"sidebarUI":true,"fabUI":true},"additionalProperties":true,"required":["backlinksIndex","sidebarUI","fabUI"],"$defs":{"AnonymousType_1":{"type":"array","items":{"$ref":"#/$defs/MentionableCharm"}},"MentionableCharm":{"type":"object","properties":{"mentioned":{"$ref":"#/$defs/AnonymousType_1"},"backlinks":{"$ref":"#/$defs/AnonymousType_1"},"$NAME":{"type":"string"}},"required":["mentioned","backlinks"]}}},"rootSchema":{"type":"object","properties":{"backlinksIndex":{"type":"object","properties":{"mentionable":{"$ref":"#/$defs/AnonymousType_1"}},"required":["mentionable"]},"sidebarUI":true,"fabUI":true},"additionalProperties":true,"required":["backlinksIndex","sidebarUI","fabUI"],"$defs":{"AnonymousType_1":{"type":"array","items":{"$ref":"#/$defs/MentionableCharm"}},"MentionableCharm":{"type":"object","properties":{"mentioned":{"$ref":"#/$defs/AnonymousType_1"},"backlinks":{"$ref":"#/$defs/AnonymousType_1"},"$NAME":{"type":"string"}},"required":["mentioned","backlinks"]}}}}}}}},"subscribe":true,"excludeSent":true},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcb3kibm3a4bt4q3pvof6pb77cuktavb72xsjmgf5bglhbjfrksboc":{}},"signature":{"/":{"bytes":"nUZGRvjD5Wut3TPrrkUKof8HJ39BEqyPz8eKSpCFm4Nc+JdnOn1OOLxU3vjQxs+xHy63/6uiFraUYc6LuJ3PBQ"}}}}	1762	
16:19:04.528
{"invocation":{"cmd":"/memory/graph/query","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"selectSchema":{"of:baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu":{"application/json":{"_":{"path":["$TYPE"],"schemaContext":{"schema":false,"rootSchema":false}}}}},"subscribe":true,"excludeSent":true},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcb3kolp7fpbuim4hne64skcahgg4hvlkxozekjy4dxpd6nj2juhxk":{}},"signature":{"/":{"bytes":"H/Z9pRILnX+DsilRV5rw2sYJlPn7txpTdPcgi4gikFiAOp+MVRxaVpxRhFKfy4uLRJWBwMJdIvQlR1/IAodHCg"}}}}	651	
16:19:04.528
{"invocation":{"cmd":"/memory/graph/query","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"selectSchema":{"of:baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu":{"application/json":{"_":{"path":["internal"],"schemaContext":{"schema":false,"rootSchema":false}}}}},"subscribe":true,"excludeSent":true},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcaphpz5yhxwzvhbdoiveb472xakp4b7vhbrw3a27vodu4yobvgq34":{}},"signature":{"/":{"bytes":"B3Z78KVzslJRvuu1Beo4Mi312RRAkH+hrRKoN1SzrXhM6KiiTPYPelyHc2oyP7DKJuYoyXpxzidj7O86D19hCQ"}}}}	654	
16:19:04.528
{"invocation":{"cmd":"/memory/graph/query","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"selectSchema":{"of:baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu":{"application/json":{"_":{"path":["argument"],"schemaContext":{"schema":false,"rootSchema":false}}}}},"subscribe":true,"excludeSent":true},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcb3rys7azfjgdlbcs4nfgemczeuiiye2nuwrzfrmaswbprgbybwdj":{}},"signature":{"/":{"bytes":"Z229vyYdiU9GuuW9zOXGS+na/FVTs+U+uO2Ny5z5qOdPlRwyxTY+odDqpqnp/XriozPWJooyObwwutZNynUZBA"}}}}	654	
16:19:04.528
{"invocation":{"cmd":"/memory/graph/query","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"selectSchema":{"of:baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu":{"application/json":{"_":{"path":[],"schemaContext":{"schema":false,"rootSchema":false}}}}},"subscribe":true,"excludeSent":true},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcbogzg4amk62yroq7viqoz76xfydlxbut7qypm2cofemsfaxm66yp":{}},"signature":{"/":{"bytes":"Bjru6H6KhayXi37UiodJ4e5iMco0YJidOgwP6PPqcE5OurZ1xVTA/zaOG9gai7BH+4sLLQnmc7Gf95LIoiMlBA"}}}}	644	
16:19:04.528
{"the":"task/effect","of":"job:ba4jcby4qeu3vpdvsxa34zgu3vbicuiyqdgxwjuqosuhvsxxlon6lu3cp","is":{"commit":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{"application/commit+json":{"ba4jcb23x6fbzhwuk3uwbhkxtdbjf5vghhxcn7ai6zpqpu6ouhgn4zlpr":{"is":{"since":21,"transaction":{"cmd":"/memory/transact","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"changes":{"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi":{"application/json":{"ba4jcblbv4ntpujeldyyue27yrq2irathuskqiaxldyaxrv6konvwamk2":{"is":{"source":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"},"value":{"backlinksIndex":{"$alias":{"path":["internal","backlinksIndex"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}},"$NAME":{"$alias":{"path":["internal","$NAME"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}},"$UI":{"type":"vnode","name":"ct-screen","props":{},"children":[{"type":"vnode","name":"ct-keybind","props":{"code":"KeyN","alt":true,"preventDefault":true,"onct-keybind":{"$alias":{"path":["internal","__#5stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":[]},{"type":"vnode","name":"ct-keybind","props":{"code":"KeyO","meta":true,"preventDefault":true,"onct-keybind":{"$alias":{"path":["internal","__#4stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":[]},{"type":"vnode","name":"ct-keybind","props":{"code":"KeyO","ctrl":true,"preventDefault":true,"onct-keybind":{"$alias":{"path":["internal","__#3stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":[]},{"type":"vnode","name":"ct-toolbar","props":{"slot":"header","sticky":true},"children":[{"type":"vnode","name":"div","props":{"slot":"start"},"children":[{"type":"vnode","name":"ct-button","props":{"onClick":{"$alias":{"path":["internal","__#6stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":["üìÇ Chat List"]},{"type":"vnode","name":"ct-button","props":{"onClick":{"$alias":{"path":["internal","__#7stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":["üí¨ Chatbot"]},{"type":"vnode","name":"ct-button","props":{"onClick":{"$alias":{"path":["internal","__#8stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":["üìù Chatbot Outliner"]},{"type":"vnode","name":"ct-button","props":{"onClick":{"$alias":{"path":["internal","__#9stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":["üìÑ Note"]}]}]},{"type":"vnode","name":"ct-vscroll","props":{"flex":true,"showScrollbar":true},"children":[{"type":"vnode","name":"ct-vstack","props":{"gap":"4","padding":"6"},"children":[{"type":"vnode","name":"style","props":{},"children":["\n .pattern-link {\n cursor: pointer;\n color: inherit;\n text-decoration: none;\n }\n .pattern-link:hover {\n text-decoration: underline;\n }\n "]},{"type":"vnode","name":"h2","props":{},"children":["Pages"]},{"type":"vnode","name":"ct-table","props":{"full-width":true,"hover":true},"children":[{"type":"vnode","name":"tbody","props":{},"children":[{"$alias":{"path":["internal","__#1"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}]}]}]}]}]},"fabUI":{"$alias":{"path":["internal","__#2","$UI"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}}}}}},"of:baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu":{"application/json":{"ba4jcazs5e433hye4ml2gbzpvghtfb52vewegfxh4ozbugojp4idpgmwv":{"is":{"value":{"$TYPE":"ba4jcaodz2xu6wbjq3i54qb4dily77jzm6ofnrimmtbv6lcfgexob2umv","resultRef":{"/":{"link@1":{"path":[],"id":"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi","schema":{"type":"object","properties":{"backlinksIndex":{"type":"object","properties":{"mentionable":{"$ref":"#/$defs/AnonymousType_1"}},"required":["mentionable"]},"sidebarUI":true,"fabUI":true},"additionalProperties":true,"required":["backlinksIndex","sidebarUI","fabUI"],"$defs":{"AnonymousType_1":{"type":"array","items":{"$ref":"#/$defs/MentionableCharm"}},"MentionableCharm":{"type":"object","properties":{"mentioned":{"$ref":"#/$defs/AnonymousType_1"},"backlinks":{"$ref":"#/$defs/AnonymousType_1"},"$NAME":{"type":"string"}},"required":["mentioned","backlinks"]}}},"rootSchema":{"type":"object","properties":{"backlinksIndex":{"type":"object","properties":{"mentionable":{"$ref":"#/$defs/AnonymousType_1"}},"required":["mentionable"]},"sidebarUI":true,"fabUI":true},"additionalProperties":true,"required":["backlinksIndex","sidebarUI","fabUI"],"$defs":{"AnonymousType_1":{"type":"array","items":{"$ref":"#/$defs/MentionableCharm"}},"MentionableCharm":{"type":"object","properties":{"mentioned":{"$ref":"#/$defs/AnonymousType_1"},"backlinks":{"$ref":"#/$defs/AnonymousType_1"},"$NAME":{"type":"string"}},"required":["mentioned","backlinks"]}}}}}},"internal":{"__#3stream":{"$stream":true},"__#4stream":{"$stream":true},"__#5stream":{"$stream":true},"__#6stream":{"$stream":true},"__#7stream":{"$stream":true},"__#8stream":{"$stream":true},"__#9stream":{"$stream":true}},"spell":{"/":{"link@1":{"id":"of:baedreiayeohgxjzmij53y63lgaax5ndolqk5ksdwu6xscel4kx2m2s6c3q"}}},"argument":{}}}}}}}},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740}}}}}},"revisions":[{"the":"application/commit+json","of":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","cause":{"/":"baedreihlo7yuhe62rlosye5k6mmfexwuy464jx4bd3f6b6tz2q4zxtfn6e"},"since":21,"is":{"since":21,"transaction":{"cmd":"/memory/transact","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"changes":{"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi":{"application/json":{"ba4jcblbv4ntpujeldyyue27yrq2irathuskqiaxldyaxrv6konvwamk2":{"is":{"source":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"},"value":{"backlinksIndex":{"$alias":{"path":["internal","backlinksIndex"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}},"$NAME":{"$alias":{"path":["internal","$NAME"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}},"$UI":{"type":"vnode","name":"ct-screen","props":{},"children":[{"type":"vnode","name":"ct-keybind","props":{"code":"KeyN","alt":true,"preventDefault":true,"onct-keybind":{"$alias":{"path":["internal","__#5stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":[]},{"type":"vnode","name":"ct-keybind","props":{"code":"KeyO","meta":true,"preventDefault":true,"onct-keybind":{"$alias":{"path":["internal","__#4stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":[]},{"type":"vnode","name":"ct-keybind","props":{"code":"KeyO","ctrl":true,"preventDefault":true,"onct-keybind":{"$alias":{"path":["internal","__#3stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":[]},{"type":"vnode","name":"ct-toolbar","props":{"slot":"header","sticky":true},"children":[{"type":"vnode","name":"div","props":{"slot":"start"},"children":[{"type":"vnode","name":"ct-button","props":{"onClick":{"$alias":{"path":["internal","__#6stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":["üìÇ Chat List"]},{"type":"vnode","name":"ct-button","props":{"onClick":{"$alias":{"path":["internal","__#7stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":["üí¨ Chatbot"]},{"type":"vnode","name":"ct-button","props":{"onClick":{"$alias":{"path":["internal","__#8stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":["üìù Chatbot Outliner"]},{"type":"vnode","name":"ct-button","props":{"onClick":{"$alias":{"path":["internal","__#9stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":["üìÑ Note"]}]}]},{"type":"vnode","name":"ct-vscroll","props":{"flex":true,"showScrollbar":true},"children":[{"type":"vnode","name":"ct-vstack","props":{"gap":"4","padding":"6"},"children":[{"type":"vnode","name":"style","props":{},"children":["\n .pattern-link {\n cursor: pointer;\n color: inherit;\n text-decoration: none;\n }\n .pattern-link:hover {\n text-decoration: underline;\n }\n "]},{"type":"vnode","name":"h2","props":{},"children":["Pages"]},{"type":"vnode","name":"ct-table","props":{"full-width":true,"hover":true},"children":[{"type":"vnode","name":"tbody","props":{},"children":[{"$alias":{"path":["internal","__#1"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}]}]}]}]}]},"fabUI":{"$alias":{"path":["internal","__#2","$UI"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}}}}}},"of:baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu":{"application/json":{"ba4jcazs5e433hye4ml2gbzpvghtfb52vewegfxh4ozbugojp4idpgmwv":{"is":{"value":{"$TYPE":"ba4jcaodz2xu6wbjq3i54qb4dily77jzm6ofnrimmtbv6lcfgexob2umv","resultRef":{"/":{"link@1":{"path":[],"id":"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi","schema":{"type":"object","properties":{"backlinksIndex":{"type":"object","properties":{"mentionable":{"$ref":"#/$defs/AnonymousType_1"}},"required":["mentionable"]},"sidebarUI":true,"fabUI":true},"additionalProperties":true,"required":["backlinksIndex","sidebarUI","fabUI"],"$defs":{"AnonymousType_1":{"type":"array","items":{"$ref":"#/$defs/MentionableCharm"}},"MentionableCharm":{"type":"object","properties":{"mentioned":{"$ref":"#/$defs/AnonymousType_1"},"backlinks":{"$ref":"#/$defs/AnonymousType_1"},"$NAME":{"type":"string"}},"required":["mentioned","backlinks"]}}},"rootSchema":{"type":"object","properties":{"backlinksIndex":{"type":"object","properties":{"mentionable":{"$ref":"#/$defs/AnonymousType_1"}},"required":["mentionable"]},"sidebarUI":true,"fabUI":true},"additionalProperties":true,"required":["backlinksIndex","sidebarUI","fabUI"],"$defs":{"AnonymousType_1":{"type":"array","items":{"$ref":"#/$defs/MentionableCharm"}},"MentionableCharm":{"type":"object","properties":{"mentioned":{"$ref":"#/$defs/AnonymousType_1"},"backlinks":{"$ref":"#/$defs/AnonymousType_1"},"$NAME":{"type":"string"}},"required":["mentioned","backlinks"]}}}}}},"internal":{"__#3stream":{"$stream":true},"__#4stream":{"$stream":true},"__#5stream":{"$stream":true},"__#6stream":{"$stream":true},"__#7stream":{"$stream":true},"__#8stream":{"$stream":true},"__#9stream":{"$stream":true}},"spell":{"/":{"link@1":{"id":"of:baedreiayeohgxjzmij53y63lgaax5ndolqk5ksdwu6xscel4kx2m2s6c3q"}}},"argument":{}}}}}}}},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740}}}]}}	11594	
16:19:04.538
{"the":"task/return","of":"job:ba4jcawu6glgw2l33s3tpzkwfettmcznjol2vm6d7rqegyq4fayrde65x","is":{"ok":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{"application/commit+json":{"ba4jcb23x6fbzhwuk3uwbhkxtdbjf5vghhxcn7ai6zpqpu6ouhgn4zlpr":{"is":{"since":21,"transaction":{"cmd":"/memory/transact","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"changes":{"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi":{"application/json":{"ba4jcblbv4ntpujeldyyue27yrq2irathuskqiaxldyaxrv6konvwamk2":{"is":{"source":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"},"value":{"backlinksIndex":{"$alias":{"path":["internal","backlinksIndex"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}},"$NAME":{"$alias":{"path":["internal","$NAME"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}},"$UI":{"type":"vnode","name":"ct-screen","props":{},"children":[{"type":"vnode","name":"ct-keybind","props":{"code":"KeyN","alt":true,"preventDefault":true,"onct-keybind":{"$alias":{"path":["internal","__#5stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":[]},{"type":"vnode","name":"ct-keybind","props":{"code":"KeyO","meta":true,"preventDefault":true,"onct-keybind":{"$alias":{"path":["internal","__#4stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":[]},{"type":"vnode","name":"ct-keybind","props":{"code":"KeyO","ctrl":true,"preventDefault":true,"onct-keybind":{"$alias":{"path":["internal","__#3stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":[]},{"type":"vnode","name":"ct-toolbar","props":{"slot":"header","sticky":true},"children":[{"type":"vnode","name":"div","props":{"slot":"start"},"children":[{"type":"vnode","name":"ct-button","props":{"onClick":{"$alias":{"path":["internal","__#6stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":["üìÇ Chat List"]},{"type":"vnode","name":"ct-button","props":{"onClick":{"$alias":{"path":["internal","__#7stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":["üí¨ Chatbot"]},{"type":"vnode","name":"ct-button","props":{"onClick":{"$alias":{"path":["internal","__#8stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":["üìù Chatbot Outliner"]},{"type":"vnode","name":"ct-button","props":{"onClick":{"$alias":{"path":["internal","__#9stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":["üìÑ Note"]}]}]},{"type":"vnode","name":"ct-vscroll","props":{"flex":true,"showScrollbar":true},"children":[{"type":"vnode","name":"ct-vstack","props":{"gap":"4","padding":"6"},"children":[{"type":"vnode","name":"style","props":{},"children":["\n .pattern-link {\n cursor: pointer;\n color: inherit;\n text-decoration: none;\n }\n .pattern-link:hover {\n text-decoration: underline;\n }\n "]},{"type":"vnode","name":"h2","props":{},"children":["Pages"]},{"type":"vnode","name":"ct-table","props":{"full-width":true,"hover":true},"children":[{"type":"vnode","name":"tbody","props":{},"children":[{"$alias":{"path":["internal","__#1"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}]}]}]}]}]},"fabUI":{"$alias":{"path":["internal","__#2","$UI"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}}}}}},"of:baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu":{"application/json":{"ba4jcazs5e433hye4ml2gbzpvghtfb52vewegfxh4ozbugojp4idpgmwv":{"is":{"value":{"$TYPE":"ba4jcaodz2xu6wbjq3i54qb4dily77jzm6ofnrimmtbv6lcfgexob2umv","resultRef":{"/":{"link@1":{"path":[],"id":"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi","schema":{"type":"object","properties":{"backlinksIndex":{"type":"object","properties":{"mentionable":{"$ref":"#/$defs/AnonymousType_1"}},"required":["mentionable"]},"sidebarUI":true,"fabUI":true},"additionalProperties":true,"required":["backlinksIndex","sidebarUI","fabUI"],"$defs":{"AnonymousType_1":{"type":"array","items":{"$ref":"#/$defs/MentionableCharm"}},"MentionableCharm":{"type":"object","properties":{"mentioned":{"$ref":"#/$defs/AnonymousType_1"},"backlinks":{"$ref":"#/$defs/AnonymousType_1"},"$NAME":{"type":"string"}},"required":["mentioned","backlinks"]}}},"rootSchema":{"type":"object","properties":{"backlinksIndex":{"type":"object","properties":{"mentionable":{"$ref":"#/$defs/AnonymousType_1"}},"required":["mentionable"]},"sidebarUI":true,"fabUI":true},"additionalProperties":true,"required":["backlinksIndex","sidebarUI","fabUI"],"$defs":{"AnonymousType_1":{"type":"array","items":{"$ref":"#/$defs/MentionableCharm"}},"MentionableCharm":{"type":"object","properties":{"mentioned":{"$ref":"#/$defs/AnonymousType_1"},"backlinks":{"$ref":"#/$defs/AnonymousType_1"},"$NAME":{"type":"string"}},"required":["mentioned","backlinks"]}}}}}},"internal":{"__#3stream":{"$stream":true},"__#4stream":{"$stream":true},"__#5stream":{"$stream":true},"__#6stream":{"$stream":true},"__#7stream":{"$stream":true},"__#8stream":{"$stream":true},"__#9stream":{"$stream":true}},"spell":{"/":{"link@1":{"id":"of:baedreiayeohgxjzmij53y63lgaax5ndolqk5ksdwu6xscel4kx2m2s6c3q"}}},"argument":{}}}}}}}},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740}}}}}}}}	5823	
16:19:04.539
{"the":"task/return","of":"job:ba4jcb3kibm3a4bt4q3pvof6pb77cuktavb72xsjmgf5bglhbjfrksboc","is":{"ok":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi":{"application/json":{"ba4jcblbv4ntpujeldyyue27yrq2irathuskqiaxldyaxrv6konvwamk2":{"is":{"source":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"},"value":{"backlinksIndex":{"$alias":{"path":["internal","backlinksIndex"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}},"$NAME":{"$alias":{"path":["internal","$NAME"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}},"$UI":{"type":"vnode","name":"ct-screen","props":{},"children":[{"type":"vnode","name":"ct-keybind","props":{"code":"KeyN","alt":true,"preventDefault":true,"onct-keybind":{"$alias":{"path":["internal","__#5stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":[]},{"type":"vnode","name":"ct-keybind","props":{"code":"KeyO","meta":true,"preventDefault":true,"onct-keybind":{"$alias":{"path":["internal","__#4stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":[]},{"type":"vnode","name":"ct-keybind","props":{"code":"KeyO","ctrl":true,"preventDefault":true,"onct-keybind":{"$alias":{"path":["internal","__#3stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":[]},{"type":"vnode","name":"ct-toolbar","props":{"slot":"header","sticky":true},"children":[{"type":"vnode","name":"div","props":{"slot":"start"},"children":[{"type":"vnode","name":"ct-button","props":{"onClick":{"$alias":{"path":["internal","__#6stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":["üìÇ Chat List"]},{"type":"vnode","name":"ct-button","props":{"onClick":{"$alias":{"path":["internal","__#7stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":["üí¨ Chatbot"]},{"type":"vnode","name":"ct-button","props":{"onClick":{"$alias":{"path":["internal","__#8stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":["üìù Chatbot Outliner"]},{"type":"vnode","name":"ct-button","props":{"onClick":{"$alias":{"path":["internal","__#9stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}},"children":["üìÑ Note"]}]}]},{"type":"vnode","name":"ct-vscroll","props":{"flex":true,"showScrollbar":true},"children":[{"type":"vnode","name":"ct-vstack","props":{"gap":"4","padding":"6"},"children":[{"type":"vnode","name":"style","props":{},"children":["\n .pattern-link {\n cursor: pointer;\n color: inherit;\n text-decoration: none;\n }\n .pattern-link:hover {\n text-decoration: underline;\n }\n "]},{"type":"vnode","name":"h2","props":{},"children":["Pages"]},{"type":"vnode","name":"ct-table","props":{"full-width":true,"hover":true},"children":[{"type":"vnode","name":"tbody","props":{},"children":[{"$alias":{"path":["internal","__#1"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}]}]}]}]}]},"fabUI":{"$alias":{"path":["internal","__#2","$UI"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}}},"since":21}}},"of:baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu":{"application/json":{"ba4jcazs5e433hye4ml2gbzpvghtfb52vewegfxh4ozbugojp4idpgmwv":{"is":{"value":{"$TYPE":"ba4jcaodz2xu6wbjq3i54qb4dily77jzm6ofnrimmtbv6lcfgexob2umv","resultRef":{"/":{"link@1":{"path":[],"id":"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi","schema":{"type":"object","properties":{"backlinksIndex":{"type":"object","properties":{"mentionable":{"$ref":"#/$defs/AnonymousType_1"}},"required":["mentionable"]},"sidebarUI":true,"fabUI":true},"additionalProperties":true,"required":["backlinksIndex","sidebarUI","fabUI"],"$defs":{"AnonymousType_1":{"type":"array","items":{"$ref":"#/$defs/MentionableCharm"}},"MentionableCharm":{"type":"object","properties":{"mentioned":{"$ref":"#/$defs/AnonymousType_1"},"backlinks":{"$ref":"#/$defs/AnonymousType_1"},"$NAME":{"type":"string"}},"required":["mentioned","backlinks"]}}},"rootSchema":{"type":"object","properties":{"backlinksIndex":{"type":"object","properties":{"mentionable":{"$ref":"#/$defs/AnonymousType_1"}},"required":["mentionable"]},"sidebarUI":true,"fabUI":true},"additionalProperties":true,"required":["backlinksIndex","sidebarUI","fabUI"],"$defs":{"AnonymousType_1":{"type":"array","items":{"$ref":"#/$defs/MentionableCharm"}},"MentionableCharm":{"type":"object","properties":{"mentioned":{"$ref":"#/$defs/AnonymousType_1"},"backlinks":{"$ref":"#/$defs/AnonymousType_1"},"$NAME":{"type":"string"}},"required":["mentioned","backlinks"]}}}}}},"internal":{"__#3stream":{"$stream":true},"__#4stream":{"$stream":true},"__#5stream":{"$stream":true},"__#6stream":{"$stream":true},"__#7stream":{"$stream":true},"__#8stream":{"$stream":true},"__#9stream":{"$stream":true}},"spell":{"/":{"link@1":{"id":"of:baedreiayeohgxjzmij53y63lgaax5ndolqk5ksdwu6xscel4kx2m2s6c3q"}}},"argument":{}}},"since":21}}}}}}}	5502	
16:19:04.540
{"the":"task/return","of":"job:ba4jcb3kolp7fpbuim4hne64skcahgg4hvlkxozekjy4dxpd6nj2juhxk","is":{"ok":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{}}}}	166	
16:19:04.541
{"the":"task/return","of":"job:ba4jcaphpz5yhxwzvhbdoiveb472xakp4b7vhbrw3a27vodu4yobvgq34","is":{"ok":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{}}}}	166	
16:19:04.541
{"the":"task/return","of":"job:ba4jcb3rys7azfjgdlbcs4nfgemczeuiiye2nuwrzfrmaswbprgbybwdj","is":{"ok":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{}}}}	166	
16:19:04.541
{"the":"task/return","of":"job:ba4jcbogzg4amk62yroq7viqoz76xfydlxbut7qypm2cofemsfaxm66yp","is":{"ok":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{}}}}	166	
16:19:04.541
{"invocation":{"cmd":"/memory/transact","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"changes":{"of:baedreihmd2h2to24aze6v5xh44dceawamjsha3xnfd2rmwhd7lkhgpv6cm":{"application/json":{"ba4jcacvr43ugio7raj7pj3wx6h7sunui7gza5c57jmzzk64nsqxevdhe":true}},"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi":{"application/json":{"ba4jcbirzp25psvtv3foh7ltybu7htrr25rcst7e4xkxcbfl6s6dn6g73":true}},"of:baedreiahv63wxwgaem4hzjkizl4qncfgvca7pj5cvdon7cukumfon3ioye":{"application/json":{"ba4jcbh2u5rpxpdtmz4ggxpsbaqre5zd5eo6dc2eza2vqakh7bte27fny":{"is":{"value":[{"/":{"link@1":{"path":[],"id":"of:baedreihmd2h2to24aze6v5xh44dceawamjsha3xnfd2rmwhd7lkhgpv6cm","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},{"/":{"link@1":{"path":[],"id":"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}}]}}}}}},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcbr3xojawbt7nu73o2ppxjasx66hirzwkbqtbxozrn6vpvmijne62":{}},"signature":{"/":{"bytes":"3Av1kHV6te05Rk0VImLhR7Pji/Iq34cjPOW1wFgLIG2ZM4WYopwq5maGucKLtFu7xOhPOKvL/kdJv+QSNQMADA"}}}}	1249	
16:19:04.545
{"the":"task/effect","of":"job:ba4jcby4qeu3vpdvsxa34zgu3vbicuiyqdgxwjuqosuhvsxxlon6lu3cp","is":{"commit":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{"application/commit+json":{"ba4jcbqv2veuu2wlpfsf74narnrqxpovyc57xonrln2z3rncnlatmexws":{"is":{"since":22,"transaction":{"cmd":"/memory/transact","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"changes":{"of:baedreihmd2h2to24aze6v5xh44dceawamjsha3xnfd2rmwhd7lkhgpv6cm":{"application/json":{"ba4jcacvr43ugio7raj7pj3wx6h7sunui7gza5c57jmzzk64nsqxevdhe":true}},"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi":{"application/json":{"ba4jcbirzp25psvtv3foh7ltybu7htrr25rcst7e4xkxcbfl6s6dn6g73":true}},"of:baedreiahv63wxwgaem4hzjkizl4qncfgvca7pj5cvdon7cukumfon3ioye":{"application/json":{"ba4jcbh2u5rpxpdtmz4ggxpsbaqre5zd5eo6dc2eza2vqakh7bte27fny":{"is":{"value":[{"/":{"link@1":{"path":[],"id":"of:baedreihmd2h2to24aze6v5xh44dceawamjsha3xnfd2rmwhd7lkhgpv6cm","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},{"/":{"link@1":{"path":[],"id":"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}}]}}}}}},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740}}}}}},"revisions":[{"the":"application/commit+json","of":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","cause":{"/":"baedreigcxkusstkzn4wix7rucfwgc552xalx65zwfnxlhofujvmcnqs62i"},"since":22,"is":{"since":22,"transaction":{"cmd":"/memory/transact","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"changes":{"of:baedreihmd2h2to24aze6v5xh44dceawamjsha3xnfd2rmwhd7lkhgpv6cm":{"application/json":{"ba4jcacvr43ugio7raj7pj3wx6h7sunui7gza5c57jmzzk64nsqxevdhe":true}},"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi":{"application/json":{"ba4jcbirzp25psvtv3foh7ltybu7htrr25rcst7e4xkxcbfl6s6dn6g73":true}},"of:baedreiahv63wxwgaem4hzjkizl4qncfgvca7pj5cvdon7cukumfon3ioye":{"application/json":{"ba4jcbh2u5rpxpdtmz4ggxpsbaqre5zd5eo6dc2eza2vqakh7bte27fny":{"is":{"value":[{"/":{"link@1":{"path":[],"id":"of:baedreihmd2h2to24aze6v5xh44dceawamjsha3xnfd2rmwhd7lkhgpv6cm","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},{"/":{"link@1":{"path":[],"id":"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}}]}}}}}},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740}}},{"the":"application/json","of":"of:baedreiahv63wxwgaem4hzjkizl4qncfgvca7pj5cvdon7cukumfon3ioye","cause":{"/":"baedreie7ktwf654onthqy256ieccetxepur3ymlitedkwabi74gmtl4vxa"},"since":22,"is":{"value":[{"/":{"link@1":{"path":[],"id":"of:baedreihmd2h2to24aze6v5xh44dceawamjsha3xnfd2rmwhd7lkhgpv6cm","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},{"/":{"link@1":{"path":[],"id":"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}}]}}]}}	3107	
16:19:04.549
{"the":"task/return","of":"job:ba4jcbr3xojawbt7nu73o2ppxjasx66hirzwkbqtbxozrn6vpvmijne62","is":{"ok":{"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs":{"application/commit+json":{"ba4jcbqv2veuu2wlpfsf74narnrqxpovyc57xonrln2z3rncnlatmexws":{"is":{"since":22,"transaction":{"cmd":"/memory/transact","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"changes":{"of:baedreihmd2h2to24aze6v5xh44dceawamjsha3xnfd2rmwhd7lkhgpv6cm":{"application/json":{"ba4jcacvr43ugio7raj7pj3wx6h7sunui7gza5c57jmzzk64nsqxevdhe":true}},"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi":{"application/json":{"ba4jcbirzp25psvtv3foh7ltybu7htrr25rcst7e4xkxcbfl6s6dn6g73":true}},"of:baedreiahv63wxwgaem4hzjkizl4qncfgvca7pj5cvdon7cukumfon3ioye":{"application/json":{"ba4jcbh2u5rpxpdtmz4ggxpsbaqre5zd5eo6dc2eza2vqakh7bte27fny":{"is":{"value":[{"/":{"link@1":{"path":[],"id":"of:baedreihmd2h2to24aze6v5xh44dceawamjsha3xnfd2rmwhd7lkhgpv6cm","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}},{"/":{"link@1":{"path":[],"id":"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi","space":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs"}}}]}}}}}},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740}}}}}}}}	1313	
16:19:04.550
{"invocation":{"cmd":"/memory/transact","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"changes":{"of:baedreic2gtm7aqfvbe66bymvqwvj7pirepldufg7qqu5y5iyjywyit6f4u":{"application/json":{"ba4jca5h7iqlvnlssq4exn3ggvu6y4gadz43hhk5j6r7ma7b2p7ivg6dx":{"is":{"value":{"id":"ba4jcbdxdxfk3tzkdxyywtnhwnmsciefb72ghxb2cinrqplaho75p5jqm","program":{"main":"/backlinks-index.tsx","mainExport":"default","files":[{"/":{"link@1":{"path":[],"id":"of:baedreifpcfwetcxfpi5o35yq4vhejubgg36o45epxlxkqkgjugtpvmp6qi"}}},{"/":{"link@1":{"path":[],"id":"of:baedreihoalbj7twlkiy76mkfdxe6qh34qzrq5olu7g6qs7vvaezcq5m4fe"}}},{"/":{"link@1":{"path":[],"id":"of:baedreigk6amyomrcrzlhk6gsvofq2eqdzdgmkd54yg3anetwj3vs4knzly"}}},{"/":{"link@1":{"path":[],"id":"of:baedreicjcddjwsjm7uxe26ptf374fs2kybww7vrzcnio76yjpn7odvzjya"}}},{"/":{"link@1":{"path":[],"id":"of:baedreicn4kwdorucwtzyhsytcrknfano7loq7zoejbwb4nvmuld7gg34yi"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiadsveowpchhtvpqimbomslv7yvz5rrs73o7fgrburceyft5ndnvm"}}},{"/":{"link@1":{"path":[],"id":"of:baedreigf54gpicv44p4euyqaxo7dn3ax5qnzrcanfobpd3hsbgdak57uii"}}},{"/":{"link@1":{"path":[],"id":"of:baedreihniptz2tqeg4e7r4fjdpo3mbnnotc4b4szym7k367toawmu6i6o4"}}},{"/":{"link@1":{"path":[],"id":"of:baedreigtneejbjjxp5wvwpi5ahhnizfrd3segw2wa65tr3kz4skkioivye"}}}]}}}}}},"of:baedreifpcfwetcxfpi5o35yq4vhejubgg36o45epxlxkqkgjugtpvmp6qi":{"application/json":{"ba4jcbv6auco3wcljfpvolmysrpvwml3k4i2id73xp36uckd2abzgbafh":{"is":{"value":{"name":"/default-app.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n handler,\n NAME,\n navigateTo,\n recipe,\n str,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chatbot from \"./chatbot.tsx\";\nimport ChatbotOutliner from \"./chatbot-outliner.tsx\";\nimport { default as Note } from \"./note.tsx\";\nimport BacklinksIndex, { type MentionableCharm } from \"./backlinks-index.tsx\";\nimport ChatList from \"./chatbot-list-view.tsx\";\nimport OmniboxFAB from \"./omnibox-fab.tsx\";\n\ntype MinimalCharm = {\n [NAME]?: string;\n};\n\ntype CharmsListInput = void;\n\n// Recipe returns only UI, no data outputs (only symbol properties)\ninterface CharmsListOutput {\n [key: string]: unknown;\n backlinksIndex: {\n mentionable: MentionableCharm[];\n };\n sidebarUI: unknown;\n fabUI: unknown;\n}\n\nconst _visit = handler<\n Record<string, never>,\n { charm: Cell<MinimalCharm> }\n>((_, state) => {\n return navigateTo(state.charm);\n}, { proxy: true });\n\nconst removeCharm = handler<\n Record<string, never>,\n {\n charm: Cell<MinimalCharm>;\n allCharms: Cell<MinimalCharm[]>;\n }\n>((_, state) => {\n const allCharmsValue = state.allCharms.get();\n const index = allCharmsValue.findIndex((c: any) => state.charm.equals(c));\n\n if (index !== -1) {\n const charmListCopy = [...allCharmsValue];\n console.log(\"charmListCopy before\", charmListCopy.length);\n charmListCopy.splice(index, 1);\n console.log(\"charmListCopy after\", charmListCopy.length);\n state.allCharms.set(charmListCopy);\n }\n});\n\nconst toggleFab = handler<any, { fabExpanded: Cell<boolean> }>(\n (_, { fabExpanded }) => {\n fabExpanded.set(!fabExpanded.get());\n },\n);\n\nconst spawnChatList = handler<void, void>((_, __) => {\n return navigateTo(ChatList({\n selectedCharm: { charm: undefined },\n charmsList: [],\n }));\n});\n\nconst spawnChatbot = handler<void, void>((_, __) => {\n return navigateTo(Chatbot({\n messages: [],\n tools: undefined,\n }));\n});\n\nconst spawnChatbotOutliner = handler<void, void>((_, __) => {\n return navigateTo(ChatbotOutliner({\n title: \"Chatbot Outliner\",\n expandChat: false,\n messages: [],\n outline: {\n root: { body: \"\", children: [], attachments: [] },\n },\n }));\n});\n\nconst spawnNote = handler<void, void>((_, __) => {\n return navigateTo(Note({\n title: \"New Note\",\n content: \"\",\n }));\n});\n\nexport default recipe<CharmsListInput, CharmsListOutput>(\n \"DefaultCharmList\",\n (_) => {\n const { allCharms } = wish<{ allCharms: MentionableCharm[] }>(\"/\");\n const index = BacklinksIndex({ allCharms });\n\n const fab = OmniboxFAB({\n mentionable: index.mentionable as unknown as Cell<MentionableCharm[]>,\n });\n\n return {\n backlinksIndex: index,\n [NAME]: str`DefaultCharmList (${allCharms.length})`,\n [UI]: (\n <ct-screen>\n <ct-keybind\n code=\"KeyN\"\n alt\n preventDefault\n onct-keybind={spawnChatList()}\n />\n <ct-keybind\n code=\"KeyO\"\n meta\n preventDefault\n onct-keybind={toggleFab({ fabExpanded: fab.fabExpanded })}\n />\n <ct-keybind\n code=\"KeyO\"\n ctrl\n preventDefault\n onct-keybind={toggleFab({ fabExpanded: fab.fabExpanded })}\n />\n\n <ct-toolbar slot=\"header\" sticky>\n <div slot=\"start\">\n <ct-button\n onClick={spawnChatList()}\n >\n üìÇ Chat List\n </ct-button>\n <ct-button\n onClick={spawnChatbot()}\n >\n üí¨ Chatbot\n </ct-button>\n <ct-button\n onClick={spawnChatbotOutliner()}\n >\n üìù Chatbot Outliner\n </ct-button>\n <ct-button\n onClick={spawnNote()}\n >\n üìÑ Note\n </ct-button>\n </div>\n </ct-toolbar>\n\n <ct-vscroll flex showScrollbar>\n <ct-vstack gap=\"4\" padding=\"6\">\n <style>\n {`\n .pattern-link {\n cursor: pointer;\n color: inherit;\n text-decoration: none;\n }\n .pattern-link:hover {\n text-decoration: underline;\n }\n `}\n </style>\n <h2>Pages</h2>\n\n <ct-table full-width hover>\n <tbody>\n {allCharms.map((charm) => (\n <tr>\n <td>\n <ct-cell-context $cell={charm}>\n <ct-cell-link $cell={charm} />\n </ct-cell-context>\n </td>\n <td>\n <ct-button\n size=\"sm\"\n variant=\"ghost\"\n onClick={removeCharm({ charm, allCharms })}\n >\n üóëÔ∏è\n </ct-button>\n </td>\n </tr>\n ))}\n </tbody>\n </ct-table>\n </ct-vstack>\n </ct-vscroll>\n </ct-screen>\n ),\n sidebarUI: undefined,\n fabUI: fab[UI],\n };\n },\n);\n"}}}}},"of:baedreihoalbj7twlkiy76mkfdxe6qh34qzrq5olu7g6qs7vvaezcq5m4fe":{"application/json":{"ba4jcbcuo5fsl5bk4sn6j5plp64bmelns2spf3dzgyotwwpkautf3g44h":{"is":{"value":{"name":"/chatbot.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n computed,\n Default,\n fetchData,\n generateObject,\n handler,\n llmDialog,\n NAME,\n pattern,\n patternTool,\n Stream,\n UI,\n VNode,\n wish,\n} from \"commontools\";\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\n\nfunction schemaifyWish<T>(path: string) {\n return wish<T>(path);\n}\n\nconst sendMessage = handler<\n {\n detail: {\n text: string;\n attachments: Array<PromptAttachment>;\n mentions: Array<any>;\n message: string; // Backward compatibility\n };\n },\n {\n addMessage: Stream<BuiltInLLMMessage>;\n }\n>((event, { addMessage }) => {\n const { text } = event.detail;\n\n // Send the message as-is. Any markdown links like [name](/of:...)\n // are just text that the LLM can parse and use with addAttachment() tool.\n addMessage.send({\n role: \"user\",\n content: [{ type: \"text\" as const, text }],\n });\n});\n\nconst clearChat = handler(\n (\n _: never,\n { messages, pending }: {\n messages: Cell<Array<BuiltInLLMMessage>>;\n pending: Cell<boolean | undefined>;\n },\n ) => {\n messages.set([]);\n pending.set(false);\n },\n);\n\ntype ChatInput = {\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n tools?: any;\n theme?: any;\n system?: string;\n};\n\ntype PromptAttachment = {\n id: string;\n name: string;\n type: \"file\" | \"clipboard\" | \"mention\";\n data?: any; // File | Blob | string\n charm?: any;\n removable?: boolean; // Whether this attachment can be removed\n};\n\ntype ChatOutput = {\n messages: Array<BuiltInLLMMessage>;\n pending: boolean | undefined;\n addMessage: Stream<BuiltInLLMMessage>;\n clearChat: Stream<void>;\n cancelGeneration: Stream<void>;\n title?: string;\n pinnedCells: Array<PromptAttachment>;\n tools: any;\n ui: {\n chatLog: VNode;\n promptInput: VNode;\n attachmentsAndTools: VNode;\n };\n};\n\nexport const TitleGenerator = pattern<\n { model?: string; messages: Array<BuiltInLLMMessage> }\n>(({ model, messages }) => {\n const previewMessage = computed(() => {\n if (!messages || messages.length === 0) return \"\";\n\n const firstMessage = messages[0];\n\n if (!firstMessage) return \"\";\n\n return JSON.stringify(firstMessage);\n });\n\n const { result } = generateObject({\n system:\n \"Generate at most a 3-word title based on the following content, respond with NOTHING but the literal title text.\",\n prompt: previewMessage,\n model,\n schema: {\n type: \"object\",\n properties: {\n title: {\n type: \"string\",\n description: \"The title of the chat\",\n },\n },\n required: [\"title\"],\n },\n });\n\n const title = computed(() => {\n return result?.title || \"Untitled Chat\";\n });\n\n return title;\n});\n\nconst listMentionable = pattern<\n { mentionable: Array<MentionableCharm> },\n { result: Array<{ label: string; cell: Cell<unknown> }> }\n>(\n ({ mentionable }) => {\n const result = mentionable.map((charm) => ({\n label: charm[NAME]!,\n cell: charm,\n }));\n return { result };\n },\n);\n\nconst listRecent = pattern<\n { recentCharms: Array<MentionableCharm> },\n { result: Array<{ label: string; cell: Cell<unknown> }> }\n>(\n ({ recentCharms }) => {\n const namesList = recentCharms.map((charm) => ({\n label: charm[NAME]!,\n cell: charm,\n }));\n return { result: namesList };\n },\n);\n\nexport default pattern<ChatInput, ChatOutput>(\n ({ messages, tools, theme, system }) => {\n const model = Cell.of<string>(\"anthropic:claude-sonnet-4-5\");\n const mentionable = schemaifyWish<MentionableCharm[]>(\"#mentionable\");\n const recentCharms = schemaifyWish<MentionableCharm[]>(\"#recent\");\n\n const assistantTools = {\n listMentionable: patternTool(listMentionable, { mentionable }),\n listRecent: patternTool(listRecent, { recentCharms }),\n };\n\n // Merge static and assistant tools\n const mergedTools = computed(() => ({\n ...tools,\n ...assistantTools,\n }));\n\n const latest = computed(() => recentCharms[0]);\n const latestName = computed(() => recentCharms[0]?.[NAME]);\n\n const {\n addMessage,\n cancelGeneration,\n pending,\n flattenedTools,\n pinnedCells,\n } = llmDialog(\n {\n system: computed(() => {\n return system ?? \"You are a polite but efficient assistant.\";\n }),\n messages,\n tools: mergedTools,\n model,\n context: computed(() => ({\n [latestName]: latest,\n })),\n },\n );\n\n const { result } = fetchData({\n url: \"/api/ai/llm/models\",\n mode: \"json\",\n });\n\n const items = computed(() => {\n if (!result) return [];\n const items = Object.keys(result as any).map((key) => ({\n label: key,\n value: key,\n }));\n return items;\n });\n\n const title = TitleGenerator({ model, messages });\n\n const promptInput = (\n <ct-prompt-input\n slot=\"footer\"\n placeholder=\"Ask the LLM a question...\"\n pending={pending}\n $mentionable={mentionable}\n modelItems={items}\n $model={model}\n onct-send={sendMessage({ addMessage })}\n onct-stop={cancelGeneration}\n />\n );\n\n const chatLog = (\n <ct-vscroll\n style=\"padding: 1rem;\"\n flex\n showScrollbar\n fadeEdges\n snapToBottom\n >\n <ct-chat\n theme={theme}\n $messages={messages}\n pending={pending}\n tools={flattenedTools}\n />\n </ct-vscroll>\n );\n\n const attachmentsAndTools = (\n <ct-hstack align=\"center\" gap=\"1\">\n <ct-cell-context $cell={pinnedCells}>\n <ct-attachments-bar pinnedCells={pinnedCells} />\n </ct-cell-context>\n <ct-tools-chip tools={flattenedTools} />\n <ct-button\n variant=\"pill\"\n type=\"button\"\n title=\"Clear chat\"\n onClick={clearChat({\n messages,\n pending,\n })}\n >\n Clear\n </ct-button>\n </ct-hstack>\n );\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <ct-vstack slot=\"header\">\n <ct-heading level={4}>{title}</ct-heading>\n {attachmentsAndTools}\n </ct-vstack>\n\n {chatLog}\n\n {promptInput}\n </ct-screen>\n ),\n messages,\n pending,\n addMessage,\n clearChat: clearChat({\n messages,\n pending,\n }),\n cancelGeneration,\n title,\n pinnedCells,\n tools: flattenedTools,\n ui: {\n chatLog,\n promptInput,\n attachmentsAndTools,\n },\n };\n },\n);\n"}}}}},"of:baedreigk6amyomrcrzlhk6gsvofq2eqdzdgmkd54yg3anetwj3vs4knzly":{"application/json":{"ba4jcakcfmoogr5juad4px72n7xmo5juljplkwhqscymu3gwrbqhwgjjo":{"is":{"value":{"name":"/chatbot-outliner.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n Default,\n derive,\n handler,\n ifElse,\n JSONSchema,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot.tsx\";\nimport { MentionableCharm } from \"./backlinks-index.tsx\";\n\ntype Charm = any;\n\ntype OutlinerNode = {\n body: Default<string, \"\">;\n children: Default<OutlinerNode[], []>;\n attachments: Default<OpaqueRef<any>[], []>;\n};\n\ntype Outliner = {\n root: OutlinerNode;\n};\n\ntype PageResult = {\n outline: Default<\n Outliner,\n { root: { body: \"\"; children: []; attachments: [] } }\n >;\n};\n\nexport type PageInput = {\n outline: Outliner;\n};\n\nconst handleCharmLinkClick = handler<\n {\n detail: {\n charm: Cell<Charm>;\n };\n },\n Record<string, never>\n>(({ detail }, _) => {\n return navigateTo(detail.charm);\n});\n\nfunction getMentionable() {\n return derive<MentionableCharm[], MentionableCharm[]>(\n wish<MentionableCharm[]>(\"#mentionable\"),\n (i) => i,\n );\n}\n\nexport const Page = recipe<PageInput>(\n \"Page\",\n ({ outline }) => {\n const mentionable = getMentionable();\n\n return {\n [NAME]: \"Page\",\n [UI]: (\n <ct-outliner\n $value={outline as any}\n $mentionable={mentionable}\n oncharm-link-click={handleCharmLinkClick({})}\n />\n ),\n outline,\n };\n },\n);\n\ntype LLMTestInput = {\n title?: Cell<Default<string, \"LLM Test\">>;\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n expandChat?: Cell<Default<boolean, false>>;\n outline?: Default<\n Outliner,\n { root: { body: \"Untitled Page\"; children: []; attachments: [] } }\n >;\n};\n\ntype LLMTestResult = {\n messages: Default<Array<BuiltInLLMMessage>, []>;\n};\n\n// put a node at the end of the outline (by appending to root.children)\nconst appendOutlinerNode = handler<\n {\n /** The text content/title of the outliner node to be appended */\n body: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { outline: Cell<Outliner> }\n>(\n (args, state) => {\n try {\n (state.outline.key(\"root\").key(\"children\")).push({\n body: args.body,\n children: [],\n attachments: [],\n });\n\n args.result.set(\n `${state.outline.key(\"root\").key(\"children\").get().length} nodes`,\n );\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nexport default recipe<LLMTestInput, LLMTestResult>(\n \"Outliner\",\n ({ title, expandChat, messages, outline }) => {\n const tools = {\n appendOutlinerNode: {\n description: \"Add a new outliner node.\",\n inputSchema: {\n type: \"object\",\n properties: {\n body: {\n type: \"string\",\n description: \"The title of the new node.\",\n },\n },\n required: [\"body\"],\n } as JSONSchema,\n handler: appendOutlinerNode({ outline }),\n },\n };\n\n const chat = Chat({ messages, tools });\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <ct-hstack justify=\"between\" slot=\"header\">\n <div></div>\n <div>\n <ct-checkbox $checked={expandChat}>Show Chat</ct-checkbox>\n </div>\n </ct-hstack>\n\n <ct-autolayout tabNames={[\"Chat\", \"Tools\"]}>\n <ct-screen>\n <div slot=\"header\">\n <ct-input\n $value={title}\n placeholder=\"Enter title...\"\n />\n </div>\n\n <ct-vscroll flex showScrollbar fadeEdges snapToBottom>\n <ct-vstack data-label=\"Tools\">\n <Page outline={outline} />\n </ct-vstack>\n </ct-vscroll>\n </ct-screen>\n\n {ifElse(\n expandChat,\n chat,\n null,\n )}\n </ct-autolayout>\n </ct-screen>\n ),\n messages,\n };\n },\n);\n"}}}}},"of:baedreicjcddjwsjm7uxe26ptf374fs2kybww7vrzcnio76yjpn7odvzjya":{"application/json":{"ba4jcbqiwnbzqazav2ss6c4hct2dwvtpzryrc5eni6ch7mp6qatk63l7x":{"is":{"value":{"name":"/note.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n cell,\n type Default,\n derive,\n generateText,\n handler,\n NAME,\n navigateTo,\n patternTool,\n recipe,\n str,\n Stream,\n UI,\n wish,\n} from \"commontools\";\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\ntype Input = {\n title?: Cell<Default<string, \"Untitled Note\">>;\n content?: Cell<Default<string, \"\">>;\n};\n\n/** Represents a small #note a user took to remember some text. */\ntype Output = {\n mentioned: Default<Array<MentionableCharm>, []>;\n backlinks: MentionableCharm[];\n\n content: Default<string, \"\">;\n grep: Stream<{ query: string }>;\n translate: Stream<{ language: string }>;\n editContent: Stream<{ detail: { value: string } }>;\n};\n\nconst _updateTitle = handler<\n { detail: { value: string } },\n { title: Cell<string> }\n>(\n (event, state) => {\n state.title.set(event.detail?.value ?? \"\");\n },\n);\n\nconst _updateContent = handler<\n { detail: { value: string } },\n { content: Cell<string> }\n>(\n (event, state) => {\n state.content.set(event.detail?.value ?? \"\");\n },\n);\n\nconst handleCharmLinkClick = handler<\n {\n detail: {\n charm: Cell<MentionableCharm>;\n };\n },\n Record<string, never>\n>(({ detail }, _) => {\n return navigateTo(detail.charm);\n});\n\nconst handleNewBacklink = handler<\n {\n detail: {\n text: string;\n charmId: any;\n charm: Cell<MentionableCharm>;\n navigate: boolean;\n };\n },\n {\n mentionable: Cell<MentionableCharm[]>;\n }\n>(({ detail }, { mentionable }) => {\n console.log(\"new charm\", detail.text, detail.charmId);\n\n if (detail.navigate) {\n return navigateTo(detail.charm);\n } else {\n mentionable.push(detail.charm as unknown as MentionableCharm);\n }\n});\n\n/** This edits the content */\nconst handleEditContent = handler<\n { detail: { value: string }; result?: Cell<string> },\n { content: Cell<string> }\n>(\n ({ detail, result }, { content }) => {\n content.set(detail.value);\n result?.set(\"test!\");\n },\n);\n\nconst handleCharmLinkClicked = handler<void, { charm: Cell<MentionableCharm> }>(\n (_, { charm }) => {\n return navigateTo(charm);\n },\n);\n\nfunction schemaifyWish<T>(path: string, def: T) {\n return derive(wish<T>(path) as T, (i) => i ?? def);\n}\n\nconst Note = recipe<Input, Output>(\n \"Note\",\n ({ title, content }) => {\n const mentionable = schemaifyWish<MentionableCharm[]>(\n \"#mentionable\",\n [],\n );\n const mentioned = cell<MentionableCharm[]>([]);\n\n // populated in backlinks-index.tsx\n const backlinks = cell<MentionableCharm[]>([]);\n\n // The only way to serialize a pattern, apparently?\n const pattern = derive(undefined, () => JSON.stringify(Note));\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <div slot=\"header\">\n <ct-input\n $value={title}\n placeholder=\"Enter title...\"\n />\n </div>\n\n <ct-code-editor\n $value={content}\n $mentionable={mentionable}\n $mentioned={mentioned}\n $pattern={pattern}\n onbacklink-click={handleCharmLinkClick({})}\n onbacklink-create={handleNewBacklink({ mentionable })}\n language=\"text/markdown\"\n theme=\"light\"\n wordWrap\n tabIndent\n lineNumbers\n />\n\n <ct-hstack slot=\"footer\">\n {backlinks?.map((charm) => (\n <ct-button\n onClick={handleCharmLinkClicked({ charm })}\n >\n {charm?.[NAME]}\n </ct-button>\n ))}\n </ct-hstack>\n </ct-screen>\n ),\n title,\n content,\n mentioned,\n backlinks,\n grep: patternTool(\n ({ query, content }: { query: string; content: string }) => {\n return derive({ query, content }, ({ query, content }) => {\n return content.split(\"\\n\").filter((c) => c.includes(query));\n });\n },\n { content },\n ),\n translate: patternTool(\n (\n { language, content }: {\n language: string;\n content: string;\n },\n ) => {\n const result = generateText({\n system: str`Translate the content to ${language}.`,\n prompt: str`<to_translate>${content}</to_translate>`,\n });\n\n return derive(result, ({ pending, result }) => {\n if (pending) return undefined;\n if (result == null) return \"Error occured\";\n return result;\n });\n },\n { content },\n ),\n editContent: handleEditContent({ content }),\n };\n },\n);\n\nexport default Note;\n"}}}}},"of:baedreicn4kwdorucwtzyhsytcrknfano7loq7zoejbwb4nvmuld7gg34yi":{"application/json":{"ba4jcbojjpycmfoamqzaa4zthkb4ob4aec4yam7wvdhcqkigqpw32yv3c":{"is":{"value":{"name":"/backlinks-index.tsx","contents":"/// <cts-enable />\nimport { Cell, derive, lift, NAME, OpaqueRef, recipe, UI } from \"commontools\";\n\nexport type MentionableCharm = {\n [NAME]?: string;\n mentioned: MentionableCharm[];\n backlinks: MentionableCharm[];\n};\n\nexport type WriteableBacklinks = {\n mentioned: WriteableBacklinks[];\n backlinks: Cell<WriteableBacklinks[]>;\n};\n\ntype Input = {\n allCharms: MentionableCharm[];\n};\n\ntype Output = {\n mentionable: MentionableCharm[];\n};\n\nconst computeIndex = lift<\n { allCharms: WriteableBacklinks[] },\n void\n>(\n ({ allCharms }) => {\n const cs = allCharms ?? [];\n\n for (const c of cs) {\n c.backlinks?.set([]);\n }\n\n for (const c of cs) {\n const mentions = c.mentioned ?? [];\n for (const m of mentions) {\n m?.backlinks?.push(c);\n }\n }\n },\n);\n\n/**\n * BacklinksIndex builds a map of backlinks across all charms and exposes a\n * unified mentionable list for consumers like editors.\n *\n * Behavior:\n * - Backlinks are computed by scanning each charm's `mentioned` list and\n * mapping mention target -> list of source charms.\n * - Mentionable list is a union of:\n * - every charm in `allCharms`\n * - any items a charm exports via a `mentionable` property\n * (either an array of charms or a Cell of such an array)\n *\n * The backlinks map is keyed by a charm's `content` value (falling back to\n * its `[NAME]`). This mirrors how existing note patterns identify notes when\n * computing backlinks locally.\n */\nconst BacklinksIndex = recipe<Input, Output>(\n \"BacklinksIndex\",\n ({ allCharms }) => {\n computeIndex({\n allCharms: allCharms as unknown as OpaqueRef<WriteableBacklinks[]>,\n });\n\n // Compute mentionable list from allCharms reactively\n const mentionable = derive(allCharms, (charmList) => {\n const cs = charmList ?? [];\n const out: MentionableCharm[] = [];\n for (const c of cs) {\n out.push(c);\n const exported = (c as unknown as {\n mentionable?: MentionableCharm[] | { get?: () => MentionableCharm[] };\n }).mentionable;\n if (Array.isArray(exported)) {\n for (const m of exported) if (m) out.push(m);\n } else if (exported && typeof (exported as any).get === \"function\") {\n const arr = (exported as { get: () => MentionableCharm[] }).get() ??\n [];\n for (const m of arr) if (m) out.push(m);\n }\n }\n return out;\n });\n\n return {\n [NAME]: \"BacklinksIndex\",\n [UI]: undefined,\n mentionable,\n };\n },\n);\n\nexport default BacklinksIndex;\n"}}}}},"of:baedreiadsveowpchhtvpqimbomslv7yvz5rrs73o7fgrburceyft5ndnvm":{"application/json":{"ba4jcaifdy6wqk6vllondiay3xdvwzmbu6ca5zbapjubg2qhxur5hwt5r":{"is":{"value":{"name":"/chatbot-list-view.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n Default,\n derive,\n handler,\n ID,\n ifElse,\n lift,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n toSchema,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot-note-composed.tsx\";\nimport { ListItem } from \"./common-tools.tsx\";\n\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\ntype CharmEntry = {\n [ID]: string; // randomId is a string\n local_id: string; // same as ID but easier to access\n charm: any;\n};\n\ntype Input = {\n selectedCharm: Default<{ charm: any }, { charm: undefined }>;\n charmsList: Default<CharmEntry[], []>;\n theme?: {\n accentColor: Cell<Default<string, \"#3b82f6\">>;\n fontFace: Cell<Default<string, \"system-ui, -apple-system, sans-serif\">>;\n borderRadius: Cell<Default<string, \"0.5rem\">>;\n };\n};\n\ntype Output = {\n selectedCharm: Default<{ charm: any }, { charm: undefined }>;\n // Expose a mentionable list aggregated from local chat entries\n // Returned as an opaque ref to an array (not a Cell), suitable for\n // upstream aggregators that read exported mentionables.\n mentionable?: MentionableCharm[];\n};\n\nconst removeChat = handler<\n unknown,\n {\n charmsList: Cell<CharmEntry[]>;\n id: string;\n selectedCharm: Cell<Default<{ charm: any }, { charm: undefined }>>;\n }\n>(\n (\n _,\n { charmsList, id, selectedCharm },\n ) => {\n const list = charmsList.get();\n const index = list.findIndex((entry) => entry.local_id === id);\n if (index === -1) return;\n\n const removed = list[index];\n const next = [...list];\n next.splice(index, 1);\n charmsList.set(next);\n\n // If we removed the currently selected charm, choose a new selection.\n const current = selectedCharm.get();\n if (current?.charm === removed.charm) {\n const replacement = next[index] ?? next[index - 1];\n if (replacement) {\n selectedCharm.set({ charm: replacement.charm });\n } else {\n selectedCharm.set({ charm: undefined as unknown as any });\n }\n }\n },\n);\n\n// this will be called whenever charm or selectedCharm changes\n// pass isInitialized to make sure we dont call this each time\n// we change selectedCharm, otherwise creates a loop\nconst storeCharm = lift(\n toSchema<{\n charm: any;\n selectedCharm: Cell<Default<{ charm: any }, { charm: undefined }>>;\n charmsList: Cell<CharmEntry[]>;\n allCharms: Cell<MentionableCharm[]>;\n theme?: {\n accentColor: Default<string, \"#3b82f6\">;\n fontFace: Default<string, \"system-ui, -apple-system, sans-serif\">;\n borderRadius: Default<string, \"0.5rem\">;\n };\n isInitialized: Cell<boolean>;\n }>(),\n undefined,\n ({ charm, selectedCharm, charmsList, isInitialized, allCharms: _ }) => { // Not including `allCharms` is a compile error...\n if (!isInitialized.get()) {\n console.log(\n \"storeCharm storing charm:\",\n charm,\n );\n selectedCharm.set({ charm });\n\n // create the chat charm with a custom name including a random suffix\n const randomId = Math.random().toString(36).substring(2, 10); // Random 8-char string\n charmsList.push({ [ID]: randomId, local_id: randomId, charm });\n\n isInitialized.set(true);\n return charm;\n } else {\n console.log(\"storeCharm: already initialized\");\n }\n return undefined;\n },\n);\n\nconst populateChatList = lift(\n toSchema<{\n charmsList: CharmEntry[];\n allCharms: Cell<any[]>;\n selectedCharm: Cell<{ charm: any }>;\n }>(),\n undefined,\n (\n { charmsList, allCharms, selectedCharm },\n ) => {\n if (charmsList.length === 0) {\n const isInitialized = Cell.of(false);\n return storeCharm({\n charm: Chat({\n title: \"New Chat\",\n messages: [],\n }),\n selectedCharm,\n charmsList,\n allCharms,\n isInitialized: isInitialized as unknown as Cell<boolean>,\n });\n }\n\n return charmsList;\n },\n);\n\nconst createChatRecipe = handler<\n unknown,\n {\n selectedCharm: Cell<{ charm: any }>;\n charmsList: Cell<CharmEntry[]>;\n allCharms: Cell<MentionableCharm[]>;\n }\n>(\n (_, { selectedCharm, charmsList, allCharms }) => {\n const isInitialized = Cell.of(false);\n\n const charm = Chat({\n title: \"New Chat\",\n messages: [],\n });\n // store the charm ref in a cell (pass isInitialized to prevent recursive calls)\n return storeCharm({\n charm,\n selectedCharm,\n charmsList: charmsList as unknown as OpaqueRef<CharmEntry[]>,\n allCharms,\n isInitialized: isInitialized as unknown as Cell<boolean>,\n });\n },\n);\n\nconst selectCharm = handler<\n unknown,\n { selectedCharm: Cell<{ charm: any }>; charm: any }\n>(\n (_, { selectedCharm, charm }) => {\n console.log(\"selectCharm: updating selectedCharm to \", charm);\n selectedCharm.set({ charm });\n return selectedCharm;\n },\n);\n\nconst logCharmsList = lift<\n { charmsList: Cell<CharmEntry[]> },\n Cell<CharmEntry[]>\n>(\n ({ charmsList }) => {\n console.log(\"logCharmsList: \", charmsList.get());\n return charmsList;\n },\n);\n\nconst _handleCharmLinkClicked = handler(\n (_: any, { charm }: { charm: Cell<MentionableCharm> }) => {\n return navigateTo(charm);\n },\n);\n\nconst _merge = lift(\n (\n { allCharms, charmsList }: { allCharms: any[]; charmsList: CharmEntry[] },\n ) => {\n return [...charmsList.map((c) => c.charm), ...allCharms];\n },\n);\n\nconst getSelectedCharm = lift<\n { entry: { charm: any | undefined } },\n {\n chat: unknown;\n list: ListItem[];\n } | undefined\n>(\n ({ entry }) => {\n return entry?.charm;\n },\n);\n\nconst getCharmName = lift(({ charm }: { charm: any }) => {\n return charm?.[NAME] || \"Unknown\";\n});\n\nconst extractLocalMentionable = lift<\n { list: CharmEntry[] },\n MentionableCharm[]\n>(({ list }) => {\n const out: MentionableCharm[] = [];\n for (const entry of list) {\n const c = entry.charm;\n out.push(c.chat);\n }\n return out;\n});\n\n// create the named cell inside the recipe body, so we do it just once\nexport default recipe<Input, Output>(\n \"Launcher\",\n ({ selectedCharm, charmsList, theme }) => {\n const allCharms = derive<MentionableCharm[], MentionableCharm[]>(\n wish<MentionableCharm[]>(\"#allCharms\"),\n (c) => c ?? [],\n );\n logCharmsList({ charmsList: charmsList as unknown as Cell<CharmEntry[]> });\n\n populateChatList({\n selectedCharm: selectedCharm as unknown as Cell<\n Pick<CharmEntry, \"charm\">\n >,\n charmsList,\n allCharms,\n });\n\n const selected = getSelectedCharm({ entry: selectedCharm });\n\n // Aggregate mentionables from the local charms list so that this\n // container exposes its child chat charms as mention targets.\n const localMentionable = extractLocalMentionable({ list: charmsList });\n\n const localTheme = theme ?? {\n accentColor: Cell.of(\"#3b82f6\"),\n fontFace: Cell.of(\"system-ui, -apple-system, sans-serif\"),\n borderRadius: Cell.of(\"0.5rem\"),\n };\n\n return {\n [NAME]: \"Launcher\",\n [UI]: (\n <ct-theme theme={localTheme as any}>\n <ct-screen>\n <div slot=\"header\">\n <ct-toolbar dense sticky>\n <div slot=\"start\">\n <ct-button\n id=\"new-chat-btn\"\n onClick={createChatRecipe({\n selectedCharm,\n charmsList,\n allCharms,\n })}\n >\n Create New Chat\n <ct-kbd>alt+N</ct-kbd>\n </ct-button>\n </div>\n </ct-toolbar>\n\n {/* Keyboard shortcuts */}\n <ct-keybind\n code=\"KeyN\"\n alt\n preventDefault\n onct-keybind={createChatRecipe({\n selectedCharm,\n charmsList,\n allCharms,\n })}\n />\n </div>\n <ct-autolayout\n leftOpen\n rightOpen={false}\n >\n {/* workaround: this seems to correctly start the sub-recipes on a refresh while directly rendering does not */}\n {/* this should be fixed after the builder-refactor (DX1) */}\n <ct-screen>\n <ct-render $cell={selected.chat} />\n </ct-screen>\n\n <aside slot=\"left\">\n <div>\n <ct-heading level={3}>Chat List</ct-heading>\n </div>\n <div role=\"list\">\n {charmsList.map((charmEntry) => (\n <ct-list-item\n onct-activate={selectCharm({\n selectedCharm,\n charm: charmEntry.charm,\n })}\n >\n <span>{getCharmName({ charm: charmEntry.charm })}</span>\n <span slot=\"meta\">{charmEntry.local_id}</span>\n <ct-button\n slot=\"actions\"\n size=\"sm\"\n title=\"Delete Chat\"\n variant=\"destructive\"\n onClick={removeChat({\n charmsList: charmsList as unknown as OpaqueRef<\n CharmEntry[]\n >,\n id: charmEntry.local_id,\n selectedCharm: selectedCharm as unknown as OpaqueRef<\n Default<{ charm: any }, { charm: undefined }>\n >,\n })}\n >\n üóëÔ∏è\n </ct-button>\n </ct-list-item>\n ))}\n </div>\n </aside>\n\n <aside slot=\"right\">\n {ifElse(\n selected,\n <>\n <ct-ct-collapsible>\n <ct-heading slot=\"trigger\" level={5} no-margin>\n List\n </ct-heading>\n <ct-list $value={selected.list} />\n </ct-ct-collapsible>\n </>,\n null,\n )}\n <ct-collapsible>\n <ct-heading slot=\"trigger\" level={5} no-margin>\n Theme\n </ct-heading>\n <ct-vstack style=\"padding: 0.5rem 0; gap: 0.5rem;\">\n <ct-vstack>\n <ct-text>Font Family</ct-text>\n <ct-select\n items={[\n {\n label: \"System\",\n value: \"system-ui, -apple-system, sans-serif\",\n },\n {\n label: \"Monospace\",\n value: \"ui-monospace, Consolas, monospace\",\n },\n {\n label: \"Serif\",\n value: \"Georgia, Times, serif\",\n },\n {\n label: \"Sans Serif\",\n value: \"Arial, Helvetica, sans-serif\",\n },\n ]}\n $value={localTheme.fontFace}\n />\n </ct-vstack>\n\n <ct-vstack>\n <ct-text>Accent Color</ct-text>\n <ct-select\n items={[\n { label: \"Blue\", value: \"#3b82f6\" },\n { label: \"Purple\", value: \"#8b5cf6\" },\n { label: \"Green\", value: \"#10b981\" },\n { label: \"Red\", value: \"#ef4444\" },\n { label: \"Orange\", value: \"#f97316\" },\n { label: \"Pink\", value: \"#ec4899\" },\n { label: \"Indigo\", value: \"#6366f1\" },\n { label: \"Teal\", value: \"#14b8a6\" },\n ]}\n $value={localTheme.accentColor}\n />\n </ct-vstack>\n\n <ct-vstack>\n <ct-text>Border Radius</ct-text>\n <ct-select\n items={[\n { label: \"None\", value: \"0px\" },\n { label: \"Small\", value: \"0.25rem\" },\n { label: \"Medium\", value: \"0.5rem\" },\n { label: \"Large\", value: \"0.75rem\" },\n { label: \"Extra Large\", value: \"1rem\" },\n { label: \"Rounded\", value: \"1.5rem\" },\n ]}\n $value={localTheme.borderRadius}\n />\n </ct-vstack>\n </ct-vstack>\n </ct-collapsible>\n </aside>\n </ct-autolayout>\n </ct-screen>\n </ct-theme>\n ),\n selectedCharm,\n charmsList,\n // Expose the aggregated mentionables for parent-level indexing.\n mentionable: localMentionable,\n };\n },\n);\n"}}}}},"of:baedreigf54gpicv44p4euyqaxo7dn3ax5qnzrcanfobpd3hsbgdak57uii":{"application/json":{"ba4jcabyq6mtmxz6xqmxbtapgquac5b2wisjg2vjdxelpb52i2qr7rwh7":{"is":{"value":{"name":"/omnibox-fab.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n computed,\n handler,\n ifElse,\n NAME,\n pattern,\n patternTool,\n UI,\n} from \"commontools\";\nimport Chatbot from \"./chatbot.tsx\";\nimport {\n calculator,\n fetchAndRunPattern,\n listPatternIndex,\n navigateToPattern,\n readWebpage,\n searchWeb,\n} from \"./common-tools.tsx\";\nimport { MentionableCharm } from \"./backlinks-index.tsx\";\n\ninterface OmniboxFABInput {\n mentionable: Cell<MentionableCharm[]>;\n}\n\nconst toggle = handler<any, { value: Cell<boolean> }>((_, { value }) => {\n value.set(!value.get());\n});\n\nconst closeFab = handler<any, { fabExpanded: Cell<boolean> }>(\n (_, { fabExpanded }) => {\n fabExpanded.set(false);\n },\n);\n\nconst dismissPeek = handler<\n any,\n { peekDismissedIndex: Cell<number>; assistantMessageCount: number }\n>((_, { peekDismissedIndex, assistantMessageCount }) => {\n // Store the current assistant message count so we know which message was dismissed\n peekDismissedIndex.set(assistantMessageCount);\n});\n\nexport default pattern<OmniboxFABInput>(\n (_) => {\n const omnibot = Chatbot({\n system:\n \"You are a polite but efficient assistant. Think Star Trek computer - helpful and professional without unnecessary conversation. Let your actions speak for themselves.\\n\\nTool usage priority:\\n- For patterns: listPatternIndex first\\n- For existing pages/notes/content: listRecent or listMentionable to identify what they're referencing\\n- Attach relevant items to conversation after instantiation/retrieval if they support ongoing tasks\\n- Remove attachments when no longer relevant\\n- Search web only as last resort when nothing exists in the space\\n\\nBe matter-of-fact. Prefer action to explanation.\",\n tools: {\n searchWeb: {\n pattern: searchWeb,\n },\n readWebpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n fetchAndRunPattern: patternTool(fetchAndRunPattern),\n listPatternIndex: patternTool(listPatternIndex),\n navigateTo: patternTool(navigateToPattern),\n },\n });\n\n const fabExpanded = Cell.of(false);\n const showHistory = Cell.of(false);\n const peekDismissedIndex = Cell.of(-1); // Track which message index was dismissed\n\n // Derive assistant message count for dismiss tracking\n const assistantMessageCount = computed(() => {\n return omnibot.messages.filter((m) => m.role === \"assistant\").length;\n });\n\n // Derive latest assistant message for peek\n const latestAssistantMessage = computed(() => {\n if (!omnibot.messages || omnibot.messages.length === 0) return null;\n\n for (let i = omnibot.messages.length - 1; i >= 0; i--) {\n const msg = omnibot.messages[i];\n if (msg.role === \"assistant\") {\n const content = typeof msg.content === \"string\"\n ? msg.content\n : msg.content.map((part: any) => {\n if (part.type === \"text\") return part.text;\n return \"\";\n }).join(\"\");\n\n return content;\n }\n }\n return null;\n });\n\n return {\n [NAME]: \"OmniboxFAB\",\n messages: omnibot.messages,\n [UI]: (\n <ct-fab\n expanded={computed(() => fabExpanded.get())}\n variant=\"primary\"\n position=\"bottom-right\"\n pending={omnibot.pending}\n $previewMessage={latestAssistantMessage}\n onct-fab-backdrop-click={closeFab({ fabExpanded })}\n onct-fab-escape={closeFab({ fabExpanded })}\n onClick={toggle({ value: fabExpanded })}\n >\n <div style=\"width: 100%; display: flex; flex-direction: column; max-height: 580px;\">\n {/* Chevron at top - the \"handle\" for the drawer */}\n <div style=\"border-bottom: 1px solid #e5e5e5; flex-shrink: 0;\">\n <ct-chevron-button\n expanded={computed(() => showHistory.get())}\n loading={omnibot.pending}\n onct-toggle={toggle({ value: showHistory })}\n />\n </div>\n\n <div\n style={computed(() => {\n const show = showHistory.get();\n return `flex: ${\n show ? \"1\" : \"0\"\n }; min-height: 0; display: flex; flex-direction: column; opacity: ${\n show ? \"1\" : \"0\"\n }; max-height: ${\n show ? \"480px\" : \"0\"\n }; overflow: hidden; transition: opacity 300ms ease, max-height 400ms cubic-bezier(0.34, 1.56, 0.64, 1), flex 400ms cubic-bezier(0.34, 1.56, 0.64, 1); pointer-events: ${\n show ? \"auto\" : \"none\"\n };`;\n })}\n >\n <div style=\"padding: .25rem; flex-shrink: 0;\">\n {omnibot.ui.attachmentsAndTools}\n </div>\n <div style=\"flex: 1; overflow-y: auto; min-height: 0;\">\n <ct-cell-context $cell={omnibot}>\n {omnibot.ui.chatLog}\n </ct-cell-context>\n </div>\n </div>\n\n {ifElse(\n computed(() => {\n const show = showHistory.get();\n const dismissedIdx = peekDismissedIndex.get();\n return !show && latestAssistantMessage &&\n assistantMessageCount !== dismissedIdx;\n }),\n <div style=\"margin: .5rem; margin-bottom: 0; padding: 0; flex-shrink: 0; position: relative;\">\n <ct-button\n variant=\"ghost\"\n size=\"icon\"\n onClick={dismissPeek({\n peekDismissedIndex,\n assistantMessageCount,\n })}\n style=\"position: absolute; top: 0px; right: 0px; z-index: 1; font-size: 16px;\"\n title=\"Dismiss\"\n >\n √ó\n </ct-button>\n <div\n onClick={toggle({ value: showHistory })}\n style=\"cursor: pointer;\"\n >\n <ct-cell-context $cell={latestAssistantMessage}>\n <ct-chat-message\n role=\"assistant\"\n compact\n content={latestAssistantMessage}\n pending={omnibot.pending}\n />\n </ct-cell-context>\n </div>\n </div>,\n null,\n )}\n\n {/* Prompt input - always at bottom */}\n <div style=\"padding: 0.5rem; flex-shrink: 0;\">\n {omnibot.ui.promptInput}\n </div>\n </div>\n </ct-fab>\n ),\n fabExpanded,\n };\n },\n);\n"}}}}},"of:baedreihniptz2tqeg4e7r4fjdpo3mbnnotc4b4szym7k367toawmu6i6o4":{"application/json":{"ba4jcaw3luohjilvr55munyxzuovsw63henngm6xhkrm36xfqav5ifn3o":{"is":{"value":{"name":"/chatbot-note-composed.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n cell,\n Default,\n derive,\n handler,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot.tsx\";\nimport Note from \"./note.tsx\";\nimport {\n addListItem,\n calculator,\n ListItem,\n readListItems,\n readWebpage,\n searchWeb,\n} from \"./common-tools.tsx\";\n\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\n\nfunction schemaifyWish<T>(path: string, def: T) {\n return derive(wish<T>(path), (i) => i ?? def);\n}\n\ntype ChatbotNoteInput = {\n title?: Cell<Default<string, \"LLM Test\">>;\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n};\n\ntype ChatbotNoteResult = {\n messages: Default<Array<BuiltInLLMMessage>, []>;\n chat: any;\n list: Default<ListItem[], []>;\n // Optional: expose sub-charms as mentionable targets\n mentionable?: MentionableCharm[];\n};\n\nconst newNote = handler<\n {\n /** The text content of the note */\n title: string;\n content?: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allCharms: Cell<MentionableCharm[]>; index: any }\n>(\n (args, _) => {\n try {\n const n = Note({\n title: args.title,\n content: args.content ?? \"\",\n });\n\n args.result.set(\n `Created note ${args.title}`,\n );\n\n // TODO(bf): we have to navigate here until DX1 lands\n // then we go back to pushing to allCharms\n return navigateTo(n);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst listMentionable = handler<\n {\n /** A cell to store the result text */\n result: Cell<string>;\n },\n { mentionable: MentionableCharm[] }\n>(\n (args, state) => {\n try {\n const namesList = state.mentionable.map((charm) => charm[NAME]);\n args.result.set(JSON.stringify(namesList));\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst readContentByIndex = handler<\n {\n /** A cell to store the result text */\n index: number;\n result: Cell<string>;\n },\n { allNotes: Note[] }\n>(\n (args, state) => {\n try {\n args.result.set(\n state.allNotes[args.index]?.content || \"No content found\",\n );\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\ntype Note = MentionableCharm & { content: string };\nconst editContentByIndex = handler<\n {\n /** The index of the note to edit */\n index: number;\n /** The new text content of the note */\n body: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allNotes: Cell<Note[]> }\n>(\n (args, state) => {\n try {\n const charms = state.allNotes.get();\n if (args.index < 0 || args.index >= charms.length) {\n args.result.set(`Error: Invalid index ${args.index}`);\n return;\n }\n\n state.allNotes.key(args.index).key(\"content\").set(args.body);\n args.result.set(`Updated note at index ${args.index}!`);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst navigateToNote = handler<\n {\n /** The index of the note to navigate to */\n index: number;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allCharms: Cell<MentionableCharm[]> }\n>(\n (args, state) => {\n try {\n const charms = state.allCharms.get();\n if (args.index < 0 || args.index >= charms.length) {\n args.result.set(`Error: Invalid index ${args.index}`);\n return;\n }\n\n const targetCharm = charms[args.index];\n args.result.set(`Navigating to note: ${targetCharm[NAME]}`);\n\n return navigateTo(state.allCharms.key(args.index));\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\ntype BacklinksIndex = {\n mentionable: MentionableCharm[];\n};\n\nexport default recipe<ChatbotNoteInput, ChatbotNoteResult>(\n \"Chatbot + Note\",\n ({ title, messages }) => {\n const allCharms = schemaifyWish<MentionableCharm[]>(\"#allCharms\", []);\n const index = schemaifyWish<BacklinksIndex>(\"#default/backlinksIndex\", {\n mentionable: [],\n });\n const mentionable = schemaifyWish<MentionableCharm[]>(\n \"#mentionable\",\n [],\n );\n\n const list = cell<ListItem[]>([]);\n\n const tools = {\n searchWeb: {\n pattern: searchWeb,\n },\n readWebpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n addListItem: {\n handler: addListItem({ list }),\n },\n readListItems: {\n handler: readListItems({ list }),\n },\n listMentionable: {\n description:\n \"List all mentionable items titles (read the body with readNoteByIndex).\",\n handler: listMentionable({ mentionable }),\n },\n readContentByIndex: {\n description:\n \"Read the content of a mentionable by its index in the listMentionable() list (if possible)\",\n handler: readContentByIndex({\n allNotes: mentionable as unknown as OpaqueRef<Note[]>,\n }),\n },\n editContentByIndex: {\n description:\n \"Edit the content of a mentionable by its index in the listMentionable() list (if possible)\",\n handler: editContentByIndex({\n allNotes: mentionable as unknown as OpaqueRef<Note[]>,\n }),\n },\n navigateToNote: {\n description:\n \"Navigate to a mentionable by its index in the listMentionable() list.\",\n handler: navigateToNote({\n allCharms: allCharms as unknown as OpaqueRef<MentionableCharm[]>,\n }),\n },\n newNote: {\n description: \"Create a new note instance\",\n handler: newNote({\n allCharms: allCharms as unknown as OpaqueRef<MentionableCharm[]>,\n index: index as unknown as OpaqueRef<any>,\n }),\n },\n };\n\n const chat = Chat({ messages, tools });\n\n return {\n [NAME]: title,\n chat,\n messages,\n list,\n // Expose sub-charms as mentionable targets\n mentionable: [chat as unknown as MentionableCharm],\n };\n },\n);\n"}}}}},"of:baedreigtneejbjjxp5wvwpi5ahhnizfrd3segw2wa65tr3kz4skkioivye":{"application/json":{"ba4jcbe6lhascuaamj4pt3au6qldwcuut5knjff64mrr6b5d7uqda6nf4":{"is":{"value":{"name":"/common-tools.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMTool,\n Cell,\n compileAndRun,\n computed,\n derive,\n fetchData,\n fetchProgram,\n handler,\n ifElse,\n navigateTo,\n recipe,\n} from \"commontools\";\n\n///// COMMON TOOLS (get it?) ////\n\n/**\n * Calculate the result of a mathematical expression.\n * Supports +, -, *, /, and parentheses.\n */\ntype CalculatorRequest = {\n /** The mathematical expression to evaluate. */\n expression: string;\n /** The base to use for the calculation. */\n base?: number;\n};\n\nexport const calculator = recipe<\n CalculatorRequest,\n string | { error: string }\n>(({ expression, base }) => {\n return derive({ expression, base }, ({ expression, base }) => {\n const sanitized = expression.replace(/[^0-9+\\-*/().\\s]/g, \"\");\n let sanitizedBase = Number(base);\n if (\n Number.isNaN(sanitizedBase) || sanitizedBase < 2 || sanitizedBase > 36\n ) {\n sanitizedBase = 10;\n }\n let result;\n try {\n result = Function(\n `\"use strict\"; return Number(${sanitized}).toString(${sanitizedBase})`,\n )();\n } catch (error) {\n result = { error: (error as any)?.message || \"<error>\" };\n }\n return result;\n });\n});\n\n/** Add an item to the list. */\ntype AddListItemRequest = {\n /** The item to add to the list. */\n item: string;\n result: Cell<string>;\n};\n\n/** Read all items from the list. */\ntype ReadListItemsRequest = {\n result: Cell<string>;\n};\n\nexport type ListItem = {\n title: string;\n};\n\nexport const addListItem = handler<\n AddListItemRequest,\n { list: Cell<ListItem[]> }\n>(\n (args, state) => {\n try {\n state.list.push({ title: args.item });\n args.result.set(`${state.list.get().length} items`);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nexport const readListItems = handler<\n ReadListItemsRequest,\n { list: ListItem[] }\n>(\n (args, state) => {\n try {\n const items = state.list;\n if (items.length === 0) {\n args.result.set(\"The list is empty\");\n } else {\n const itemList = items.map((item, index) =>\n `${index + 1}. ${item.title}`\n ).join(\"\\n\");\n args.result.set(`List items (${items.length} total):\\n${itemList}`);\n }\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\n/** Search the web for information. */\ntype SearchQuery = {\n /** The query to search the web for. */\n query: string;\n};\n\ntype SearchWebResult = {\n results: {\n title: string;\n url: string;\n description: string;\n }[];\n};\n\nexport const searchWeb = recipe<\n SearchQuery,\n SearchWebResult | { error: string }\n>(({ query }) => {\n const { result, error } = fetchData<SearchWebResult>({\n url: \"/api/agent-tools/web-search\",\n mode: \"json\",\n options: {\n method: \"POST\",\n headers: {\n \"Content-Type\": \"application/json\",\n },\n body: {\n query,\n max_results: 5,\n },\n },\n });\n\n // TODO(seefeld): Should we instead return { result, error }? Or allocate a\n // special [ERROR] for errors? Ideally this isn't specific to using recipes as\n // tools but a general pattern.\n return ifElse(error, { error }, result);\n});\n\n/** Read and extract content from a specific webpage URL. */\ntype ReadWebRequest = {\n /** The URL of the webpage to read and extract content from. */\n url: string;\n};\n\ntype ReadWebResult = {\n content: string;\n metadata: {\n title?: string;\n author?: string;\n date?: string;\n word_count: number;\n };\n};\n\nexport const readWebpage = recipe<\n ReadWebRequest,\n ReadWebResult | { error: string }\n>(({ url }) => {\n const { result, error } = fetchData<ReadWebResult>({\n url: \"/api/agent-tools/web-read\",\n mode: \"json\",\n options: {\n method: \"POST\",\n headers: {\n \"Content-Type\": \"application/json\",\n },\n body: {\n url,\n max_tokens: 4000,\n include_code: true,\n },\n },\n });\n\n return ifElse(error, { error }, result);\n});\n\ntype ToolsInput = {\n list: ListItem[];\n};\n\nexport default recipe<ToolsInput>(({ list }) => {\n const tools: Record<string, BuiltInLLMTool> = {\n search_web: {\n pattern: searchWeb,\n },\n read_webpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n addListItem: {\n handler: addListItem({ list }),\n },\n };\n\n return { tools, list };\n});\n\n/**\n * `fetchAndRunPattern({ url: \"https://...\", args: {} })`\n *\n * Instantiates patterns (e.g. from listPatternIndex) and returns the cell that\n * contains the results. The instantiated pattern will keep running and updating\n * the cell. Pass the resulting cell to `navigateTo` to show the pattern's UI.\n *\n * Pass in arguments to initialize the pattern. It's especially useful to pass\n * in links to other cells as `{ \"@link\": \"/of:bafe.../path/to/data\" }`.\n */\ntype FetchAndRunPatternInput = {\n url: string;\n args: Cell<any>;\n};\nexport const fetchAndRunPattern = recipe<FetchAndRunPatternInput>(\n ({ url, args }) => {\n const { pending: _fetchPending, result: program, error: _fetchError } =\n fetchProgram({ url });\n\n // Use derive to safely handle when program is undefined/pending\n const compileParams = derive(program, (p) => ({\n files: p?.files ?? [],\n main: p?.main ?? \"\",\n input: args,\n }));\n\n const { pending, result, error } = compileAndRun(compileParams);\n\n return ifElse(\n computed(() => pending || (!result && !error)),\n undefined,\n {\n cell: result,\n error,\n },\n );\n },\n);\n\n/**\n * `navigateTo({ cell: { \"@link\": \"/of:xyz\" } })` - Navigates to that cell's UI\n *\n * Especially useful after instantiating a pattern with fetchAndRunPattern:\n * Pass the \"@link\" you get at `cell` to navigate to the pattern's view.\n */\ntype NavigateToPatternInput = { cell: Cell<any> }; // Hack to steer LLM\nexport const navigateToPattern = recipe<NavigateToPatternInput>(\n ({ cell }) => {\n const success = navigateTo(cell);\n\n return ifElse(success, { success }, undefined);\n },\n);\n\n/**\n * `listPatternIndex()` - Returns the index of patterns.\n *\n * Useful as input to fetchAndRun.\n */\ntype ListPatternIndexInput = Record<string, never>;\n\nexport const listPatternIndex = recipe<ListPatternIndexInput>(\n ({ _ }) => {\n const { pending, result } = fetchData({\n url: \"/api/patterns/index.md\",\n mode: \"text\",\n });\n return ifElse(computed(() => pending || !result), undefined, { result });\n },\n);\n"}}}}}}},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcalfxe2jvsqvjribvflyw2wnt2mcdrz5nltmwrsyruywqxy6jr4ty":{}},"signature":{"/":{"bytes":"ZfLe93D+H8qjttQL2T6kJNS8EEc3nrA/5PvUwiGXHe2IYq1iMEz56ilpk5/A86h9EC4OfxE5zLP91OI0z/v2DA"}}}}	61978	
16:19:04.875
{"invocation":{"cmd":"/memory/transact","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"changes":{"of:baedreict32xtwzbqigicopudxcssjko2bwk4zd7gesc5mmjsbdpvhmdqfm":{"application/json":{"ba4jcbc2322scbsjpq2pzg3oz2jwicrkobfdhfl7wrjufjiexpdsh7z54":{"is":{"value":{"id":"ba4jcangkm4fwnvsvwriopn2eksgl2pw3le5z2nlgngk4rtymlnplerms","program":{"main":"/omnibox-fab.tsx","mainExport":"default","files":[{"/":{"link@1":{"path":[],"id":"of:baedreignulkoniv6bqvhwwl7at4efzs7i5xur2tqemluwq5iht6qnqxzru"}}},{"/":{"link@1":{"path":[],"id":"of:baedreicok4yomy5gg6tsbm7casghssw7tlononxmoh3gc2q3jrvmga2w6e"}}},{"/":{"link@1":{"path":[],"id":"of:baedreice26d6uzgi7bgacm4xeg66jrmoikbgcbmjcr3bx32uv2ny4rkura"}}},{"/":{"link@1":{"path":[],"id":"of:baedreibzmkkckv4hhxqvnczj6kib6v35dy6gehdvlq3a7qnxyikdo24fmm"}}},{"/":{"link@1":{"path":[],"id":"of:baedreibdc6duqtzsoo37muxgk3koc3e3rn5r7hpekk475sh3ynr7lrum5m"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiex7jhy763pxyqsjweectvisrqfqewg7styx5pccfc4jfbalc6p7a"}}},{"/":{"link@1":{"path":[],"id":"of:baedreicqcx6fwpm7y2arowaucy5jiisfryqmufpy2upgqe3crfahybbmme"}}},{"/":{"link@1":{"path":[],"id":"of:baedreihk72qcaltem6t7wnsrvkcvtuwtznicxecnb3gpmch7yymbytteze"}}},{"/":{"link@1":{"path":[],"id":"of:baedreigye5bum2yaeehgkzy6mni7dc37crl7swusp4cjlhwhazf4upfala"}}}]}}}}}},"of:baedreignulkoniv6bqvhwwl7at4efzs7i5xur2tqemluwq5iht6qnqxzru":{"application/json":{"ba4jcavrpdavgpg23capcshflk7dfwohnn3rqvjd2a2qs6swfu7zjiehs":{"is":{"value":{"name":"/default-app.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n handler,\n NAME,\n navigateTo,\n recipe,\n str,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chatbot from \"./chatbot.tsx\";\nimport ChatbotOutliner from \"./chatbot-outliner.tsx\";\nimport { default as Note } from \"./note.tsx\";\nimport BacklinksIndex, { type MentionableCharm } from \"./backlinks-index.tsx\";\nimport ChatList from \"./chatbot-list-view.tsx\";\nimport OmniboxFAB from \"./omnibox-fab.tsx\";\n\ntype MinimalCharm = {\n [NAME]?: string;\n};\n\ntype CharmsListInput = void;\n\n// Recipe returns only UI, no data outputs (only symbol properties)\ninterface CharmsListOutput {\n [key: string]: unknown;\n backlinksIndex: {\n mentionable: MentionableCharm[];\n };\n sidebarUI: unknown;\n fabUI: unknown;\n}\n\nconst _visit = handler<\n Record<string, never>,\n { charm: Cell<MinimalCharm> }\n>((_, state) => {\n return navigateTo(state.charm);\n}, { proxy: true });\n\nconst removeCharm = handler<\n Record<string, never>,\n {\n charm: Cell<MinimalCharm>;\n allCharms: Cell<MinimalCharm[]>;\n }\n>((_, state) => {\n const allCharmsValue = state.allCharms.get();\n const index = allCharmsValue.findIndex((c: any) => state.charm.equals(c));\n\n if (index !== -1) {\n const charmListCopy = [...allCharmsValue];\n console.log(\"charmListCopy before\", charmListCopy.length);\n charmListCopy.splice(index, 1);\n console.log(\"charmListCopy after\", charmListCopy.length);\n state.allCharms.set(charmListCopy);\n }\n});\n\nconst toggleFab = handler<any, { fabExpanded: Cell<boolean> }>(\n (_, { fabExpanded }) => {\n fabExpanded.set(!fabExpanded.get());\n },\n);\n\nconst spawnChatList = handler<void, void>((_, __) => {\n return navigateTo(ChatList({\n selectedCharm: { charm: undefined },\n charmsList: [],\n }));\n});\n\nconst spawnChatbot = handler<void, void>((_, __) => {\n return navigateTo(Chatbot({\n messages: [],\n tools: undefined,\n }));\n});\n\nconst spawnChatbotOutliner = handler<void, void>((_, __) => {\n return navigateTo(ChatbotOutliner({\n title: \"Chatbot Outliner\",\n expandChat: false,\n messages: [],\n outline: {\n root: { body: \"\", children: [], attachments: [] },\n },\n }));\n});\n\nconst spawnNote = handler<void, void>((_, __) => {\n return navigateTo(Note({\n title: \"New Note\",\n content: \"\",\n }));\n});\n\nexport default recipe<CharmsListInput, CharmsListOutput>(\n \"DefaultCharmList\",\n (_) => {\n const { allCharms } = wish<{ allCharms: MentionableCharm[] }>(\"/\");\n const index = BacklinksIndex({ allCharms });\n\n const fab = OmniboxFAB({\n mentionable: index.mentionable as unknown as Cell<MentionableCharm[]>,\n });\n\n return {\n backlinksIndex: index,\n [NAME]: str`DefaultCharmList (${allCharms.length})`,\n [UI]: (\n <ct-screen>\n <ct-keybind\n code=\"KeyN\"\n alt\n preventDefault\n onct-keybind={spawnChatList()}\n />\n <ct-keybind\n code=\"KeyO\"\n meta\n preventDefault\n onct-keybind={toggleFab({ fabExpanded: fab.fabExpanded })}\n />\n <ct-keybind\n code=\"KeyO\"\n ctrl\n preventDefault\n onct-keybind={toggleFab({ fabExpanded: fab.fabExpanded })}\n />\n\n <ct-toolbar slot=\"header\" sticky>\n <div slot=\"start\">\n <ct-button\n onClick={spawnChatList()}\n >\n üìÇ Chat List\n </ct-button>\n <ct-button\n onClick={spawnChatbot()}\n >\n üí¨ Chatbot\n </ct-button>\n <ct-button\n onClick={spawnChatbotOutliner()}\n >\n üìù Chatbot Outliner\n </ct-button>\n <ct-button\n onClick={spawnNote()}\n >\n üìÑ Note\n </ct-button>\n </div>\n </ct-toolbar>\n\n <ct-vscroll flex showScrollbar>\n <ct-vstack gap=\"4\" padding=\"6\">\n <style>\n {`\n .pattern-link {\n cursor: pointer;\n color: inherit;\n text-decoration: none;\n }\n .pattern-link:hover {\n text-decoration: underline;\n }\n `}\n </style>\n <h2>Pages</h2>\n\n <ct-table full-width hover>\n <tbody>\n {allCharms.map((charm) => (\n <tr>\n <td>\n <ct-cell-context $cell={charm}>\n <ct-cell-link $cell={charm} />\n </ct-cell-context>\n </td>\n <td>\n <ct-button\n size=\"sm\"\n variant=\"ghost\"\n onClick={removeCharm({ charm, allCharms })}\n >\n üóëÔ∏è\n </ct-button>\n </td>\n </tr>\n ))}\n </tbody>\n </ct-table>\n </ct-vstack>\n </ct-vscroll>\n </ct-screen>\n ),\n sidebarUI: undefined,\n fabUI: fab[UI],\n };\n },\n);\n"}}}}},"of:baedreicok4yomy5gg6tsbm7casghssw7tlononxmoh3gc2q3jrvmga2w6e":{"application/json":{"ba4jcb7wfj5o4tdbxmlkgvmmw4kkjxfqj2pvpge42ikz6gpfzeivqb7tq":{"is":{"value":{"name":"/chatbot.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n computed,\n Default,\n fetchData,\n generateObject,\n handler,\n llmDialog,\n NAME,\n pattern,\n patternTool,\n Stream,\n UI,\n VNode,\n wish,\n} from \"commontools\";\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\n\nfunction schemaifyWish<T>(path: string) {\n return wish<T>(path);\n}\n\nconst sendMessage = handler<\n {\n detail: {\n text: string;\n attachments: Array<PromptAttachment>;\n mentions: Array<any>;\n message: string; // Backward compatibility\n };\n },\n {\n addMessage: Stream<BuiltInLLMMessage>;\n }\n>((event, { addMessage }) => {\n const { text } = event.detail;\n\n // Send the message as-is. Any markdown links like [name](/of:...)\n // are just text that the LLM can parse and use with addAttachment() tool.\n addMessage.send({\n role: \"user\",\n content: [{ type: \"text\" as const, text }],\n });\n});\n\nconst clearChat = handler(\n (\n _: never,\n { messages, pending }: {\n messages: Cell<Array<BuiltInLLMMessage>>;\n pending: Cell<boolean | undefined>;\n },\n ) => {\n messages.set([]);\n pending.set(false);\n },\n);\n\ntype ChatInput = {\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n tools?: any;\n theme?: any;\n system?: string;\n};\n\ntype PromptAttachment = {\n id: string;\n name: string;\n type: \"file\" | \"clipboard\" | \"mention\";\n data?: any; // File | Blob | string\n charm?: any;\n removable?: boolean; // Whether this attachment can be removed\n};\n\ntype ChatOutput = {\n messages: Array<BuiltInLLMMessage>;\n pending: boolean | undefined;\n addMessage: Stream<BuiltInLLMMessage>;\n clearChat: Stream<void>;\n cancelGeneration: Stream<void>;\n title?: string;\n pinnedCells: Array<PromptAttachment>;\n tools: any;\n ui: {\n chatLog: VNode;\n promptInput: VNode;\n attachmentsAndTools: VNode;\n };\n};\n\nexport const TitleGenerator = pattern<\n { model?: string; messages: Array<BuiltInLLMMessage> }\n>(({ model, messages }) => {\n const previewMessage = computed(() => {\n if (!messages || messages.length === 0) return \"\";\n\n const firstMessage = messages[0];\n\n if (!firstMessage) return \"\";\n\n return JSON.stringify(firstMessage);\n });\n\n const { result } = generateObject({\n system:\n \"Generate at most a 3-word title based on the following content, respond with NOTHING but the literal title text.\",\n prompt: previewMessage,\n model,\n schema: {\n type: \"object\",\n properties: {\n title: {\n type: \"string\",\n description: \"The title of the chat\",\n },\n },\n required: [\"title\"],\n },\n });\n\n const title = computed(() => {\n return result?.title || \"Untitled Chat\";\n });\n\n return title;\n});\n\nconst listMentionable = pattern<\n { mentionable: Array<MentionableCharm> },\n { result: Array<{ label: string; cell: Cell<unknown> }> }\n>(\n ({ mentionable }) => {\n const result = mentionable.map((charm) => ({\n label: charm[NAME]!,\n cell: charm,\n }));\n return { result };\n },\n);\n\nconst listRecent = pattern<\n { recentCharms: Array<MentionableCharm> },\n { result: Array<{ label: string; cell: Cell<unknown> }> }\n>(\n ({ recentCharms }) => {\n const namesList = recentCharms.map((charm) => ({\n label: charm[NAME]!,\n cell: charm,\n }));\n return { result: namesList };\n },\n);\n\nexport default pattern<ChatInput, ChatOutput>(\n ({ messages, tools, theme, system }) => {\n const model = Cell.of<string>(\"anthropic:claude-sonnet-4-5\");\n const mentionable = schemaifyWish<MentionableCharm[]>(\"#mentionable\");\n const recentCharms = schemaifyWish<MentionableCharm[]>(\"#recent\");\n\n const assistantTools = {\n listMentionable: patternTool(listMentionable, { mentionable }),\n listRecent: patternTool(listRecent, { recentCharms }),\n };\n\n // Merge static and assistant tools\n const mergedTools = computed(() => ({\n ...tools,\n ...assistantTools,\n }));\n\n const latest = computed(() => recentCharms[0]);\n const latestName = computed(() => recentCharms[0]?.[NAME]);\n\n const {\n addMessage,\n cancelGeneration,\n pending,\n flattenedTools,\n pinnedCells,\n } = llmDialog(\n {\n system: computed(() => {\n return system ?? \"You are a polite but efficient assistant.\";\n }),\n messages,\n tools: mergedTools,\n model,\n context: computed(() => ({\n [latestName]: latest,\n })),\n },\n );\n\n const { result } = fetchData({\n url: \"/api/ai/llm/models\",\n mode: \"json\",\n });\n\n const items = computed(() => {\n if (!result) return [];\n const items = Object.keys(result as any).map((key) => ({\n label: key,\n value: key,\n }));\n return items;\n });\n\n const title = TitleGenerator({ model, messages });\n\n const promptInput = (\n <ct-prompt-input\n slot=\"footer\"\n placeholder=\"Ask the LLM a question...\"\n pending={pending}\n $mentionable={mentionable}\n modelItems={items}\n $model={model}\n onct-send={sendMessage({ addMessage })}\n onct-stop={cancelGeneration}\n />\n );\n\n const chatLog = (\n <ct-vscroll\n style=\"padding: 1rem;\"\n flex\n showScrollbar\n fadeEdges\n snapToBottom\n >\n <ct-chat\n theme={theme}\n $messages={messages}\n pending={pending}\n tools={flattenedTools}\n />\n </ct-vscroll>\n );\n\n const attachmentsAndTools = (\n <ct-hstack align=\"center\" gap=\"1\">\n <ct-cell-context $cell={pinnedCells}>\n <ct-attachments-bar pinnedCells={pinnedCells} />\n </ct-cell-context>\n <ct-tools-chip tools={flattenedTools} />\n <ct-button\n variant=\"pill\"\n type=\"button\"\n title=\"Clear chat\"\n onClick={clearChat({\n messages,\n pending,\n })}\n >\n Clear\n </ct-button>\n </ct-hstack>\n );\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <ct-vstack slot=\"header\">\n <ct-heading level={4}>{title}</ct-heading>\n {attachmentsAndTools}\n </ct-vstack>\n\n {chatLog}\n\n {promptInput}\n </ct-screen>\n ),\n messages,\n pending,\n addMessage,\n clearChat: clearChat({\n messages,\n pending,\n }),\n cancelGeneration,\n title,\n pinnedCells,\n tools: flattenedTools,\n ui: {\n chatLog,\n promptInput,\n attachmentsAndTools,\n },\n };\n },\n);\n"}}}}},"of:baedreice26d6uzgi7bgacm4xeg66jrmoikbgcbmjcr3bx32uv2ny4rkura":{"application/json":{"ba4jcaoa7y4n26vjypsqctnh3tbuvqsxtgd4f52ucoghj2ipsvpgqfwhv":{"is":{"value":{"name":"/chatbot-outliner.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n Default,\n derive,\n handler,\n ifElse,\n JSONSchema,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot.tsx\";\nimport { MentionableCharm } from \"./backlinks-index.tsx\";\n\ntype Charm = any;\n\ntype OutlinerNode = {\n body: Default<string, \"\">;\n children: Default<OutlinerNode[], []>;\n attachments: Default<OpaqueRef<any>[], []>;\n};\n\ntype Outliner = {\n root: OutlinerNode;\n};\n\ntype PageResult = {\n outline: Default<\n Outliner,\n { root: { body: \"\"; children: []; attachments: [] } }\n >;\n};\n\nexport type PageInput = {\n outline: Outliner;\n};\n\nconst handleCharmLinkClick = handler<\n {\n detail: {\n charm: Cell<Charm>;\n };\n },\n Record<string, never>\n>(({ detail }, _) => {\n return navigateTo(detail.charm);\n});\n\nfunction getMentionable() {\n return derive<MentionableCharm[], MentionableCharm[]>(\n wish<MentionableCharm[]>(\"#mentionable\"),\n (i) => i,\n );\n}\n\nexport const Page = recipe<PageInput>(\n \"Page\",\n ({ outline }) => {\n const mentionable = getMentionable();\n\n return {\n [NAME]: \"Page\",\n [UI]: (\n <ct-outliner\n $value={outline as any}\n $mentionable={mentionable}\n oncharm-link-click={handleCharmLinkClick({})}\n />\n ),\n outline,\n };\n },\n);\n\ntype LLMTestInput = {\n title?: Cell<Default<string, \"LLM Test\">>;\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n expandChat?: Cell<Default<boolean, false>>;\n outline?: Default<\n Outliner,\n { root: { body: \"Untitled Page\"; children: []; attachments: [] } }\n >;\n};\n\ntype LLMTestResult = {\n messages: Default<Array<BuiltInLLMMessage>, []>;\n};\n\n// put a node at the end of the outline (by appending to root.children)\nconst appendOutlinerNode = handler<\n {\n /** The text content/title of the outliner node to be appended */\n body: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { outline: Cell<Outliner> }\n>(\n (args, state) => {\n try {\n (state.outline.key(\"root\").key(\"children\")).push({\n body: args.body,\n children: [],\n attachments: [],\n });\n\n args.result.set(\n `${state.outline.key(\"root\").key(\"children\").get().length} nodes`,\n );\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nexport default recipe<LLMTestInput, LLMTestResult>(\n \"Outliner\",\n ({ title, expandChat, messages, outline }) => {\n const tools = {\n appendOutlinerNode: {\n description: \"Add a new outliner node.\",\n inputSchema: {\n type: \"object\",\n properties: {\n body: {\n type: \"string\",\n description: \"The title of the new node.\",\n },\n },\n required: [\"body\"],\n } as JSONSchema,\n handler: appendOutlinerNode({ outline }),\n },\n };\n\n const chat = Chat({ messages, tools });\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <ct-hstack justify=\"between\" slot=\"header\">\n <div></div>\n <div>\n <ct-checkbox $checked={expandChat}>Show Chat</ct-checkbox>\n </div>\n </ct-hstack>\n\n <ct-autolayout tabNames={[\"Chat\", \"Tools\"]}>\n <ct-screen>\n <div slot=\"header\">\n <ct-input\n $value={title}\n placeholder=\"Enter title...\"\n />\n </div>\n\n <ct-vscroll flex showScrollbar fadeEdges snapToBottom>\n <ct-vstack data-label=\"Tools\">\n <Page outline={outline} />\n </ct-vstack>\n </ct-vscroll>\n </ct-screen>\n\n {ifElse(\n expandChat,\n chat,\n null,\n )}\n </ct-autolayout>\n </ct-screen>\n ),\n messages,\n };\n },\n);\n"}}}}},"of:baedreibzmkkckv4hhxqvnczj6kib6v35dy6gehdvlq3a7qnxyikdo24fmm":{"application/json":{"ba4jcafrl4cgpkh2miyxuivdttapd55fp5jflkve5e2vwzwpxg7yymzr5":{"is":{"value":{"name":"/note.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n cell,\n type Default,\n derive,\n generateText,\n handler,\n NAME,\n navigateTo,\n patternTool,\n recipe,\n str,\n Stream,\n UI,\n wish,\n} from \"commontools\";\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\ntype Input = {\n title?: Cell<Default<string, \"Untitled Note\">>;\n content?: Cell<Default<string, \"\">>;\n};\n\n/** Represents a small #note a user took to remember some text. */\ntype Output = {\n mentioned: Default<Array<MentionableCharm>, []>;\n backlinks: MentionableCharm[];\n\n content: Default<string, \"\">;\n grep: Stream<{ query: string }>;\n translate: Stream<{ language: string }>;\n editContent: Stream<{ detail: { value: string } }>;\n};\n\nconst _updateTitle = handler<\n { detail: { value: string } },\n { title: Cell<string> }\n>(\n (event, state) => {\n state.title.set(event.detail?.value ?? \"\");\n },\n);\n\nconst _updateContent = handler<\n { detail: { value: string } },\n { content: Cell<string> }\n>(\n (event, state) => {\n state.content.set(event.detail?.value ?? \"\");\n },\n);\n\nconst handleCharmLinkClick = handler<\n {\n detail: {\n charm: Cell<MentionableCharm>;\n };\n },\n Record<string, never>\n>(({ detail }, _) => {\n return navigateTo(detail.charm);\n});\n\nconst handleNewBacklink = handler<\n {\n detail: {\n text: string;\n charmId: any;\n charm: Cell<MentionableCharm>;\n navigate: boolean;\n };\n },\n {\n mentionable: Cell<MentionableCharm[]>;\n }\n>(({ detail }, { mentionable }) => {\n console.log(\"new charm\", detail.text, detail.charmId);\n\n if (detail.navigate) {\n return navigateTo(detail.charm);\n } else {\n mentionable.push(detail.charm as unknown as MentionableCharm);\n }\n});\n\n/** This edits the content */\nconst handleEditContent = handler<\n { detail: { value: string }; result?: Cell<string> },\n { content: Cell<string> }\n>(\n ({ detail, result }, { content }) => {\n content.set(detail.value);\n result?.set(\"test!\");\n },\n);\n\nconst handleCharmLinkClicked = handler<void, { charm: Cell<MentionableCharm> }>(\n (_, { charm }) => {\n return navigateTo(charm);\n },\n);\n\nfunction schemaifyWish<T>(path: string, def: T) {\n return derive(wish<T>(path) as T, (i) => i ?? def);\n}\n\nconst Note = recipe<Input, Output>(\n \"Note\",\n ({ title, content }) => {\n const mentionable = schemaifyWish<MentionableCharm[]>(\n \"#mentionable\",\n [],\n );\n const mentioned = cell<MentionableCharm[]>([]);\n\n // populated in backlinks-index.tsx\n const backlinks = cell<MentionableCharm[]>([]);\n\n // The only way to serialize a pattern, apparently?\n const pattern = derive(undefined, () => JSON.stringify(Note));\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <div slot=\"header\">\n <ct-input\n $value={title}\n placeholder=\"Enter title...\"\n />\n </div>\n\n <ct-code-editor\n $value={content}\n $mentionable={mentionable}\n $mentioned={mentioned}\n $pattern={pattern}\n onbacklink-click={handleCharmLinkClick({})}\n onbacklink-create={handleNewBacklink({ mentionable })}\n language=\"text/markdown\"\n theme=\"light\"\n wordWrap\n tabIndent\n lineNumbers\n />\n\n <ct-hstack slot=\"footer\">\n {backlinks?.map((charm) => (\n <ct-button\n onClick={handleCharmLinkClicked({ charm })}\n >\n {charm?.[NAME]}\n </ct-button>\n ))}\n </ct-hstack>\n </ct-screen>\n ),\n title,\n content,\n mentioned,\n backlinks,\n grep: patternTool(\n ({ query, content }: { query: string; content: string }) => {\n return derive({ query, content }, ({ query, content }) => {\n return content.split(\"\\n\").filter((c) => c.includes(query));\n });\n },\n { content },\n ),\n translate: patternTool(\n (\n { language, content }: {\n language: string;\n content: string;\n },\n ) => {\n const result = generateText({\n system: str`Translate the content to ${language}.`,\n prompt: str`<to_translate>${content}</to_translate>`,\n });\n\n return derive(result, ({ pending, result }) => {\n if (pending) return undefined;\n if (result == null) return \"Error occured\";\n return result;\n });\n },\n { content },\n ),\n editContent: handleEditContent({ content }),\n };\n },\n);\n\nexport default Note;\n"}}}}},"of:baedreibdc6duqtzsoo37muxgk3koc3e3rn5r7hpekk475sh3ynr7lrum5m":{"application/json":{"ba4jcblhupc4usu2z3x7p7n6vavilvlvsrh3y7szwji32nc4ypaymfvf3":{"is":{"value":{"name":"/backlinks-index.tsx","contents":"/// <cts-enable />\nimport { Cell, derive, lift, NAME, OpaqueRef, recipe, UI } from \"commontools\";\n\nexport type MentionableCharm = {\n [NAME]?: string;\n mentioned: MentionableCharm[];\n backlinks: MentionableCharm[];\n};\n\nexport type WriteableBacklinks = {\n mentioned: WriteableBacklinks[];\n backlinks: Cell<WriteableBacklinks[]>;\n};\n\ntype Input = {\n allCharms: MentionableCharm[];\n};\n\ntype Output = {\n mentionable: MentionableCharm[];\n};\n\nconst computeIndex = lift<\n { allCharms: WriteableBacklinks[] },\n void\n>(\n ({ allCharms }) => {\n const cs = allCharms ?? [];\n\n for (const c of cs) {\n c.backlinks?.set([]);\n }\n\n for (const c of cs) {\n const mentions = c.mentioned ?? [];\n for (const m of mentions) {\n m?.backlinks?.push(c);\n }\n }\n },\n);\n\n/**\n * BacklinksIndex builds a map of backlinks across all charms and exposes a\n * unified mentionable list for consumers like editors.\n *\n * Behavior:\n * - Backlinks are computed by scanning each charm's `mentioned` list and\n * mapping mention target -> list of source charms.\n * - Mentionable list is a union of:\n * - every charm in `allCharms`\n * - any items a charm exports via a `mentionable` property\n * (either an array of charms or a Cell of such an array)\n *\n * The backlinks map is keyed by a charm's `content` value (falling back to\n * its `[NAME]`). This mirrors how existing note patterns identify notes when\n * computing backlinks locally.\n */\nconst BacklinksIndex = recipe<Input, Output>(\n \"BacklinksIndex\",\n ({ allCharms }) => {\n computeIndex({\n allCharms: allCharms as unknown as OpaqueRef<WriteableBacklinks[]>,\n });\n\n // Compute mentionable list from allCharms reactively\n const mentionable = derive(allCharms, (charmList) => {\n const cs = charmList ?? [];\n const out: MentionableCharm[] = [];\n for (const c of cs) {\n out.push(c);\n const exported = (c as unknown as {\n mentionable?: MentionableCharm[] | { get?: () => MentionableCharm[] };\n }).mentionable;\n if (Array.isArray(exported)) {\n for (const m of exported) if (m) out.push(m);\n } else if (exported && typeof (exported as any).get === \"function\") {\n const arr = (exported as { get: () => MentionableCharm[] }).get() ??\n [];\n for (const m of arr) if (m) out.push(m);\n }\n }\n return out;\n });\n\n return {\n [NAME]: \"BacklinksIndex\",\n [UI]: undefined,\n mentionable,\n };\n },\n);\n\nexport default BacklinksIndex;\n"}}}}},"of:baedreiex7jhy763pxyqsjweectvisrqfqewg7styx5pccfc4jfbalc6p7a":{"application/json":{"ba4jcbzkrfj6yclmglvmxi2qrdamuawdb3fapshh7ig7aw77r5cbonznm":{"is":{"value":{"name":"/chatbot-list-view.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n Default,\n derive,\n handler,\n ID,\n ifElse,\n lift,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n toSchema,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot-note-composed.tsx\";\nimport { ListItem } from \"./common-tools.tsx\";\n\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\ntype CharmEntry = {\n [ID]: string; // randomId is a string\n local_id: string; // same as ID but easier to access\n charm: any;\n};\n\ntype Input = {\n selectedCharm: Default<{ charm: any }, { charm: undefined }>;\n charmsList: Default<CharmEntry[], []>;\n theme?: {\n accentColor: Cell<Default<string, \"#3b82f6\">>;\n fontFace: Cell<Default<string, \"system-ui, -apple-system, sans-serif\">>;\n borderRadius: Cell<Default<string, \"0.5rem\">>;\n };\n};\n\ntype Output = {\n selectedCharm: Default<{ charm: any }, { charm: undefined }>;\n // Expose a mentionable list aggregated from local chat entries\n // Returned as an opaque ref to an array (not a Cell), suitable for\n // upstream aggregators that read exported mentionables.\n mentionable?: MentionableCharm[];\n};\n\nconst removeChat = handler<\n unknown,\n {\n charmsList: Cell<CharmEntry[]>;\n id: string;\n selectedCharm: Cell<Default<{ charm: any }, { charm: undefined }>>;\n }\n>(\n (\n _,\n { charmsList, id, selectedCharm },\n ) => {\n const list = charmsList.get();\n const index = list.findIndex((entry) => entry.local_id === id);\n if (index === -1) return;\n\n const removed = list[index];\n const next = [...list];\n next.splice(index, 1);\n charmsList.set(next);\n\n // If we removed the currently selected charm, choose a new selection.\n const current = selectedCharm.get();\n if (current?.charm === removed.charm) {\n const replacement = next[index] ?? next[index - 1];\n if (replacement) {\n selectedCharm.set({ charm: replacement.charm });\n } else {\n selectedCharm.set({ charm: undefined as unknown as any });\n }\n }\n },\n);\n\n// this will be called whenever charm or selectedCharm changes\n// pass isInitialized to make sure we dont call this each time\n// we change selectedCharm, otherwise creates a loop\nconst storeCharm = lift(\n toSchema<{\n charm: any;\n selectedCharm: Cell<Default<{ charm: any }, { charm: undefined }>>;\n charmsList: Cell<CharmEntry[]>;\n allCharms: Cell<MentionableCharm[]>;\n theme?: {\n accentColor: Default<string, \"#3b82f6\">;\n fontFace: Default<string, \"system-ui, -apple-system, sans-serif\">;\n borderRadius: Default<string, \"0.5rem\">;\n };\n isInitialized: Cell<boolean>;\n }>(),\n undefined,\n ({ charm, selectedCharm, charmsList, isInitialized, allCharms: _ }) => { // Not including `allCharms` is a compile error...\n if (!isInitialized.get()) {\n console.log(\n \"storeCharm storing charm:\",\n charm,\n );\n selectedCharm.set({ charm });\n\n // create the chat charm with a custom name including a random suffix\n const randomId = Math.random().toString(36).substring(2, 10); // Random 8-char string\n charmsList.push({ [ID]: randomId, local_id: randomId, charm });\n\n isInitialized.set(true);\n return charm;\n } else {\n console.log(\"storeCharm: already initialized\");\n }\n return undefined;\n },\n);\n\nconst populateChatList = lift(\n toSchema<{\n charmsList: CharmEntry[];\n allCharms: Cell<any[]>;\n selectedCharm: Cell<{ charm: any }>;\n }>(),\n undefined,\n (\n { charmsList, allCharms, selectedCharm },\n ) => {\n if (charmsList.length === 0) {\n const isInitialized = Cell.of(false);\n return storeCharm({\n charm: Chat({\n title: \"New Chat\",\n messages: [],\n }),\n selectedCharm,\n charmsList,\n allCharms,\n isInitialized: isInitialized as unknown as Cell<boolean>,\n });\n }\n\n return charmsList;\n },\n);\n\nconst createChatRecipe = handler<\n unknown,\n {\n selectedCharm: Cell<{ charm: any }>;\n charmsList: Cell<CharmEntry[]>;\n allCharms: Cell<MentionableCharm[]>;\n }\n>(\n (_, { selectedCharm, charmsList, allCharms }) => {\n const isInitialized = Cell.of(false);\n\n const charm = Chat({\n title: \"New Chat\",\n messages: [],\n });\n // store the charm ref in a cell (pass isInitialized to prevent recursive calls)\n return storeCharm({\n charm,\n selectedCharm,\n charmsList: charmsList as unknown as OpaqueRef<CharmEntry[]>,\n allCharms,\n isInitialized: isInitialized as unknown as Cell<boolean>,\n });\n },\n);\n\nconst selectCharm = handler<\n unknown,\n { selectedCharm: Cell<{ charm: any }>; charm: any }\n>(\n (_, { selectedCharm, charm }) => {\n console.log(\"selectCharm: updating selectedCharm to \", charm);\n selectedCharm.set({ charm });\n return selectedCharm;\n },\n);\n\nconst logCharmsList = lift<\n { charmsList: Cell<CharmEntry[]> },\n Cell<CharmEntry[]>\n>(\n ({ charmsList }) => {\n console.log(\"logCharmsList: \", charmsList.get());\n return charmsList;\n },\n);\n\nconst _handleCharmLinkClicked = handler(\n (_: any, { charm }: { charm: Cell<MentionableCharm> }) => {\n return navigateTo(charm);\n },\n);\n\nconst _merge = lift(\n (\n { allCharms, charmsList }: { allCharms: any[]; charmsList: CharmEntry[] },\n ) => {\n return [...charmsList.map((c) => c.charm), ...allCharms];\n },\n);\n\nconst getSelectedCharm = lift<\n { entry: { charm: any | undefined } },\n {\n chat: unknown;\n list: ListItem[];\n } | undefined\n>(\n ({ entry }) => {\n return entry?.charm;\n },\n);\n\nconst getCharmName = lift(({ charm }: { charm: any }) => {\n return charm?.[NAME] || \"Unknown\";\n});\n\nconst extractLocalMentionable = lift<\n { list: CharmEntry[] },\n MentionableCharm[]\n>(({ list }) => {\n const out: MentionableCharm[] = [];\n for (const entry of list) {\n const c = entry.charm;\n out.push(c.chat);\n }\n return out;\n});\n\n// create the named cell inside the recipe body, so we do it just once\nexport default recipe<Input, Output>(\n \"Launcher\",\n ({ selectedCharm, charmsList, theme }) => {\n const allCharms = derive<MentionableCharm[], MentionableCharm[]>(\n wish<MentionableCharm[]>(\"#allCharms\"),\n (c) => c ?? [],\n );\n logCharmsList({ charmsList: charmsList as unknown as Cell<CharmEntry[]> });\n\n populateChatList({\n selectedCharm: selectedCharm as unknown as Cell<\n Pick<CharmEntry, \"charm\">\n >,\n charmsList,\n allCharms,\n });\n\n const selected = getSelectedCharm({ entry: selectedCharm });\n\n // Aggregate mentionables from the local charms list so that this\n // container exposes its child chat charms as mention targets.\n const localMentionable = extractLocalMentionable({ list: charmsList });\n\n const localTheme = theme ?? {\n accentColor: Cell.of(\"#3b82f6\"),\n fontFace: Cell.of(\"system-ui, -apple-system, sans-serif\"),\n borderRadius: Cell.of(\"0.5rem\"),\n };\n\n return {\n [NAME]: \"Launcher\",\n [UI]: (\n <ct-theme theme={localTheme as any}>\n <ct-screen>\n <div slot=\"header\">\n <ct-toolbar dense sticky>\n <div slot=\"start\">\n <ct-button\n id=\"new-chat-btn\"\n onClick={createChatRecipe({\n selectedCharm,\n charmsList,\n allCharms,\n })}\n >\n Create New Chat\n <ct-kbd>alt+N</ct-kbd>\n </ct-button>\n </div>\n </ct-toolbar>\n\n {/* Keyboard shortcuts */}\n <ct-keybind\n code=\"KeyN\"\n alt\n preventDefault\n onct-keybind={createChatRecipe({\n selectedCharm,\n charmsList,\n allCharms,\n })}\n />\n </div>\n <ct-autolayout\n leftOpen\n rightOpen={false}\n >\n {/* workaround: this seems to correctly start the sub-recipes on a refresh while directly rendering does not */}\n {/* this should be fixed after the builder-refactor (DX1) */}\n <ct-screen>\n <ct-render $cell={selected.chat} />\n </ct-screen>\n\n <aside slot=\"left\">\n <div>\n <ct-heading level={3}>Chat List</ct-heading>\n </div>\n <div role=\"list\">\n {charmsList.map((charmEntry) => (\n <ct-list-item\n onct-activate={selectCharm({\n selectedCharm,\n charm: charmEntry.charm,\n })}\n >\n <span>{getCharmName({ charm: charmEntry.charm })}</span>\n <span slot=\"meta\">{charmEntry.local_id}</span>\n <ct-button\n slot=\"actions\"\n size=\"sm\"\n title=\"Delete Chat\"\n variant=\"destructive\"\n onClick={removeChat({\n charmsList: charmsList as unknown as OpaqueRef<\n CharmEntry[]\n >,\n id: charmEntry.local_id,\n selectedCharm: selectedCharm as unknown as OpaqueRef<\n Default<{ charm: any }, { charm: undefined }>\n >,\n })}\n >\n üóëÔ∏è\n </ct-button>\n </ct-list-item>\n ))}\n </div>\n </aside>\n\n <aside slot=\"right\">\n {ifElse(\n selected,\n <>\n <ct-ct-collapsible>\n <ct-heading slot=\"trigger\" level={5} no-margin>\n List\n </ct-heading>\n <ct-list $value={selected.list} />\n </ct-ct-collapsible>\n </>,\n null,\n )}\n <ct-collapsible>\n <ct-heading slot=\"trigger\" level={5} no-margin>\n Theme\n </ct-heading>\n <ct-vstack style=\"padding: 0.5rem 0; gap: 0.5rem;\">\n <ct-vstack>\n <ct-text>Font Family</ct-text>\n <ct-select\n items={[\n {\n label: \"System\",\n value: \"system-ui, -apple-system, sans-serif\",\n },\n {\n label: \"Monospace\",\n value: \"ui-monospace, Consolas, monospace\",\n },\n {\n label: \"Serif\",\n value: \"Georgia, Times, serif\",\n },\n {\n label: \"Sans Serif\",\n value: \"Arial, Helvetica, sans-serif\",\n },\n ]}\n $value={localTheme.fontFace}\n />\n </ct-vstack>\n\n <ct-vstack>\n <ct-text>Accent Color</ct-text>\n <ct-select\n items={[\n { label: \"Blue\", value: \"#3b82f6\" },\n { label: \"Purple\", value: \"#8b5cf6\" },\n { label: \"Green\", value: \"#10b981\" },\n { label: \"Red\", value: \"#ef4444\" },\n { label: \"Orange\", value: \"#f97316\" },\n { label: \"Pink\", value: \"#ec4899\" },\n { label: \"Indigo\", value: \"#6366f1\" },\n { label: \"Teal\", value: \"#14b8a6\" },\n ]}\n $value={localTheme.accentColor}\n />\n </ct-vstack>\n\n <ct-vstack>\n <ct-text>Border Radius</ct-text>\n <ct-select\n items={[\n { label: \"None\", value: \"0px\" },\n { label: \"Small\", value: \"0.25rem\" },\n { label: \"Medium\", value: \"0.5rem\" },\n { label: \"Large\", value: \"0.75rem\" },\n { label: \"Extra Large\", value: \"1rem\" },\n { label: \"Rounded\", value: \"1.5rem\" },\n ]}\n $value={localTheme.borderRadius}\n />\n </ct-vstack>\n </ct-vstack>\n </ct-collapsible>\n </aside>\n </ct-autolayout>\n </ct-screen>\n </ct-theme>\n ),\n selectedCharm,\n charmsList,\n // Expose the aggregated mentionables for parent-level indexing.\n mentionable: localMentionable,\n };\n },\n);\n"}}}}},"of:baedreicqcx6fwpm7y2arowaucy5jiisfryqmufpy2upgqe3crfahybbmme":{"application/json":{"ba4jcbxx5pkfhci7kdxcdgfhiqpmz4yi5oebe4pbkdzopdn33qpw3yvbz":{"is":{"value":{"name":"/omnibox-fab.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n computed,\n handler,\n ifElse,\n NAME,\n pattern,\n patternTool,\n UI,\n} from \"commontools\";\nimport Chatbot from \"./chatbot.tsx\";\nimport {\n calculator,\n fetchAndRunPattern,\n listPatternIndex,\n navigateToPattern,\n readWebpage,\n searchWeb,\n} from \"./common-tools.tsx\";\nimport { MentionableCharm } from \"./backlinks-index.tsx\";\n\ninterface OmniboxFABInput {\n mentionable: Cell<MentionableCharm[]>;\n}\n\nconst toggle = handler<any, { value: Cell<boolean> }>((_, { value }) => {\n value.set(!value.get());\n});\n\nconst closeFab = handler<any, { fabExpanded: Cell<boolean> }>(\n (_, { fabExpanded }) => {\n fabExpanded.set(false);\n },\n);\n\nconst dismissPeek = handler<\n any,\n { peekDismissedIndex: Cell<number>; assistantMessageCount: number }\n>((_, { peekDismissedIndex, assistantMessageCount }) => {\n // Store the current assistant message count so we know which message was dismissed\n peekDismissedIndex.set(assistantMessageCount);\n});\n\nexport default pattern<OmniboxFABInput>(\n (_) => {\n const omnibot = Chatbot({\n system:\n \"You are a polite but efficient assistant. Think Star Trek computer - helpful and professional without unnecessary conversation. Let your actions speak for themselves.\\n\\nTool usage priority:\\n- For patterns: listPatternIndex first\\n- For existing pages/notes/content: listRecent or listMentionable to identify what they're referencing\\n- Attach relevant items to conversation after instantiation/retrieval if they support ongoing tasks\\n- Remove attachments when no longer relevant\\n- Search web only as last resort when nothing exists in the space\\n\\nBe matter-of-fact. Prefer action to explanation.\",\n tools: {\n searchWeb: {\n pattern: searchWeb,\n },\n readWebpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n fetchAndRunPattern: patternTool(fetchAndRunPattern),\n listPatternIndex: patternTool(listPatternIndex),\n navigateTo: patternTool(navigateToPattern),\n },\n });\n\n const fabExpanded = Cell.of(false);\n const showHistory = Cell.of(false);\n const peekDismissedIndex = Cell.of(-1); // Track which message index was dismissed\n\n // Derive assistant message count for dismiss tracking\n const assistantMessageCount = computed(() => {\n return omnibot.messages.filter((m) => m.role === \"assistant\").length;\n });\n\n // Derive latest assistant message for peek\n const latestAssistantMessage = computed(() => {\n if (!omnibot.messages || omnibot.messages.length === 0) return null;\n\n for (let i = omnibot.messages.length - 1; i >= 0; i--) {\n const msg = omnibot.messages[i];\n if (msg.role === \"assistant\") {\n const content = typeof msg.content === \"string\"\n ? msg.content\n : msg.content.map((part: any) => {\n if (part.type === \"text\") return part.text;\n return \"\";\n }).join(\"\");\n\n return content;\n }\n }\n return null;\n });\n\n return {\n [NAME]: \"OmniboxFAB\",\n messages: omnibot.messages,\n [UI]: (\n <ct-fab\n expanded={computed(() => fabExpanded.get())}\n variant=\"primary\"\n position=\"bottom-right\"\n pending={omnibot.pending}\n $previewMessage={latestAssistantMessage}\n onct-fab-backdrop-click={closeFab({ fabExpanded })}\n onct-fab-escape={closeFab({ fabExpanded })}\n onClick={toggle({ value: fabExpanded })}\n >\n <div style=\"width: 100%; display: flex; flex-direction: column; max-height: 580px;\">\n {/* Chevron at top - the \"handle\" for the drawer */}\n <div style=\"border-bottom: 1px solid #e5e5e5; flex-shrink: 0;\">\n <ct-chevron-button\n expanded={computed(() => showHistory.get())}\n loading={omnibot.pending}\n onct-toggle={toggle({ value: showHistory })}\n />\n </div>\n\n <div\n style={computed(() => {\n const show = showHistory.get();\n return `flex: ${\n show ? \"1\" : \"0\"\n }; min-height: 0; display: flex; flex-direction: column; opacity: ${\n show ? \"1\" : \"0\"\n }; max-height: ${\n show ? \"480px\" : \"0\"\n }; overflow: hidden; transition: opacity 300ms ease, max-height 400ms cubic-bezier(0.34, 1.56, 0.64, 1), flex 400ms cubic-bezier(0.34, 1.56, 0.64, 1); pointer-events: ${\n show ? \"auto\" : \"none\"\n };`;\n })}\n >\n <div style=\"padding: .25rem; flex-shrink: 0;\">\n {omnibot.ui.attachmentsAndTools}\n </div>\n <div style=\"flex: 1; overflow-y: auto; min-height: 0;\">\n <ct-cell-context $cell={omnibot}>\n {omnibot.ui.chatLog}\n </ct-cell-context>\n </div>\n </div>\n\n {ifElse(\n computed(() => {\n const show = showHistory.get();\n const dismissedIdx = peekDismissedIndex.get();\n return !show && latestAssistantMessage &&\n assistantMessageCount !== dismissedIdx;\n }),\n <div style=\"margin: .5rem; margin-bottom: 0; padding: 0; flex-shrink: 0; position: relative;\">\n <ct-button\n variant=\"ghost\"\n size=\"icon\"\n onClick={dismissPeek({\n peekDismissedIndex,\n assistantMessageCount,\n })}\n style=\"position: absolute; top: 0px; right: 0px; z-index: 1; font-size: 16px;\"\n title=\"Dismiss\"\n >\n √ó\n </ct-button>\n <div\n onClick={toggle({ value: showHistory })}\n style=\"cursor: pointer;\"\n >\n <ct-cell-context $cell={latestAssistantMessage}>\n <ct-chat-message\n role=\"assistant\"\n compact\n content={latestAssistantMessage}\n pending={omnibot.pending}\n />\n </ct-cell-context>\n </div>\n </div>,\n null,\n )}\n\n {/* Prompt input - always at bottom */}\n <div style=\"padding: 0.5rem; flex-shrink: 0;\">\n {omnibot.ui.promptInput}\n </div>\n </div>\n </ct-fab>\n ),\n fabExpanded,\n };\n },\n);\n"}}}}},"of:baedreihk72qcaltem6t7wnsrvkcvtuwtznicxecnb3gpmch7yymbytteze":{"application/json":{"ba4jcb4yyznjng3r7dy4jvujyphncqasxotiyi6wyawsghi2wb2xeopvl":{"is":{"value":{"name":"/chatbot-note-composed.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n cell,\n Default,\n derive,\n handler,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot.tsx\";\nimport Note from \"./note.tsx\";\nimport {\n addListItem,\n calculator,\n ListItem,\n readListItems,\n readWebpage,\n searchWeb,\n} from \"./common-tools.tsx\";\n\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\n\nfunction schemaifyWish<T>(path: string, def: T) {\n return derive(wish<T>(path), (i) => i ?? def);\n}\n\ntype ChatbotNoteInput = {\n title?: Cell<Default<string, \"LLM Test\">>;\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n};\n\ntype ChatbotNoteResult = {\n messages: Default<Array<BuiltInLLMMessage>, []>;\n chat: any;\n list: Default<ListItem[], []>;\n // Optional: expose sub-charms as mentionable targets\n mentionable?: MentionableCharm[];\n};\n\nconst newNote = handler<\n {\n /** The text content of the note */\n title: string;\n content?: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allCharms: Cell<MentionableCharm[]>; index: any }\n>(\n (args, _) => {\n try {\n const n = Note({\n title: args.title,\n content: args.content ?? \"\",\n });\n\n args.result.set(\n `Created note ${args.title}`,\n );\n\n // TODO(bf): we have to navigate here until DX1 lands\n // then we go back to pushing to allCharms\n return navigateTo(n);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst listMentionable = handler<\n {\n /** A cell to store the result text */\n result: Cell<string>;\n },\n { mentionable: MentionableCharm[] }\n>(\n (args, state) => {\n try {\n const namesList = state.mentionable.map((charm) => charm[NAME]);\n args.result.set(JSON.stringify(namesList));\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst readContentByIndex = handler<\n {\n /** A cell to store the result text */\n index: number;\n result: Cell<string>;\n },\n { allNotes: Note[] }\n>(\n (args, state) => {\n try {\n args.result.set(\n state.allNotes[args.index]?.content || \"No content found\",\n );\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\ntype Note = MentionableCharm & { content: string };\nconst editContentByIndex = handler<\n {\n /** The index of the note to edit */\n index: number;\n /** The new text content of the note */\n body: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allNotes: Cell<Note[]> }\n>(\n (args, state) => {\n try {\n const charms = state.allNotes.get();\n if (args.index < 0 || args.index >= charms.length) {\n args.result.set(`Error: Invalid index ${args.index}`);\n return;\n }\n\n state.allNotes.key(args.index).key(\"content\").set(args.body);\n args.result.set(`Updated note at index ${args.index}!`);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst navigateToNote = handler<\n {\n /** The index of the note to navigate to */\n index: number;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allCharms: Cell<MentionableCharm[]> }\n>(\n (args, state) => {\n try {\n const charms = state.allCharms.get();\n if (args.index < 0 || args.index >= charms.length) {\n args.result.set(`Error: Invalid index ${args.index}`);\n return;\n }\n\n const targetCharm = charms[args.index];\n args.result.set(`Navigating to note: ${targetCharm[NAME]}`);\n\n return navigateTo(state.allCharms.key(args.index));\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\ntype BacklinksIndex = {\n mentionable: MentionableCharm[];\n};\n\nexport default recipe<ChatbotNoteInput, ChatbotNoteResult>(\n \"Chatbot + Note\",\n ({ title, messages }) => {\n const allCharms = schemaifyWish<MentionableCharm[]>(\"#allCharms\", []);\n const index = schemaifyWish<BacklinksIndex>(\"#default/backlinksIndex\", {\n mentionable: [],\n });\n const mentionable = schemaifyWish<MentionableCharm[]>(\n \"#mentionable\",\n [],\n );\n\n const list = cell<ListItem[]>([]);\n\n const tools = {\n searchWeb: {\n pattern: searchWeb,\n },\n readWebpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n addListItem: {\n handler: addListItem({ list }),\n },\n readListItems: {\n handler: readListItems({ list }),\n },\n listMentionable: {\n description:\n \"List all mentionable items titles (read the body with readNoteByIndex).\",\n handler: listMentionable({ mentionable }),\n },\n readContentByIndex: {\n description:\n \"Read the content of a mentionable by its index in the listMentionable() list (if possible)\",\n handler: readContentByIndex({\n allNotes: mentionable as unknown as OpaqueRef<Note[]>,\n }),\n },\n editContentByIndex: {\n description:\n \"Edit the content of a mentionable by its index in the listMentionable() list (if possible)\",\n handler: editContentByIndex({\n allNotes: mentionable as unknown as OpaqueRef<Note[]>,\n }),\n },\n navigateToNote: {\n description:\n \"Navigate to a mentionable by its index in the listMentionable() list.\",\n handler: navigateToNote({\n allCharms: allCharms as unknown as OpaqueRef<MentionableCharm[]>,\n }),\n },\n newNote: {\n description: \"Create a new note instance\",\n handler: newNote({\n allCharms: allCharms as unknown as OpaqueRef<MentionableCharm[]>,\n index: index as unknown as OpaqueRef<any>,\n }),\n },\n };\n\n const chat = Chat({ messages, tools });\n\n return {\n [NAME]: title,\n chat,\n messages,\n list,\n // Expose sub-charms as mentionable targets\n mentionable: [chat as unknown as MentionableCharm],\n };\n },\n);\n"}}}}},"of:baedreigye5bum2yaeehgkzy6mni7dc37crl7swusp4cjlhwhazf4upfala":{"application/json":{"ba4jcaj7dawodryrcikxfdsipbaium6srjm2su5sdvk7hsdmq6kajhuty":{"is":{"value":{"name":"/common-tools.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMTool,\n Cell,\n compileAndRun,\n computed,\n derive,\n fetchData,\n fetchProgram,\n handler,\n ifElse,\n navigateTo,\n recipe,\n} from \"commontools\";\n\n///// COMMON TOOLS (get it?) ////\n\n/**\n * Calculate the result of a mathematical expression.\n * Supports +, -, *, /, and parentheses.\n */\ntype CalculatorRequest = {\n /** The mathematical expression to evaluate. */\n expression: string;\n /** The base to use for the calculation. */\n base?: number;\n};\n\nexport const calculator = recipe<\n CalculatorRequest,\n string | { error: string }\n>(({ expression, base }) => {\n return derive({ expression, base }, ({ expression, base }) => {\n const sanitized = expression.replace(/[^0-9+\\-*/().\\s]/g, \"\");\n let sanitizedBase = Number(base);\n if (\n Number.isNaN(sanitizedBase) || sanitizedBase < 2 || sanitizedBase > 36\n ) {\n sanitizedBase = 10;\n }\n let result;\n try {\n result = Function(\n `\"use strict\"; return Number(${sanitized}).toString(${sanitizedBase})`,\n )();\n } catch (error) {\n result = { error: (error as any)?.message || \"<error>\" };\n }\n return result;\n });\n});\n\n/** Add an item to the list. */\ntype AddListItemRequest = {\n /** The item to add to the list. */\n item: string;\n result: Cell<string>;\n};\n\n/** Read all items from the list. */\ntype ReadListItemsRequest = {\n result: Cell<string>;\n};\n\nexport type ListItem = {\n title: string;\n};\n\nexport const addListItem = handler<\n AddListItemRequest,\n { list: Cell<ListItem[]> }\n>(\n (args, state) => {\n try {\n state.list.push({ title: args.item });\n args.result.set(`${state.list.get().length} items`);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nexport const readListItems = handler<\n ReadListItemsRequest,\n { list: ListItem[] }\n>(\n (args, state) => {\n try {\n const items = state.list;\n if (items.length === 0) {\n args.result.set(\"The list is empty\");\n } else {\n const itemList = items.map((item, index) =>\n `${index + 1}. ${item.title}`\n ).join(\"\\n\");\n args.result.set(`List items (${items.length} total):\\n${itemList}`);\n }\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\n/** Search the web for information. */\ntype SearchQuery = {\n /** The query to search the web for. */\n query: string;\n};\n\ntype SearchWebResult = {\n results: {\n title: string;\n url: string;\n description: string;\n }[];\n};\n\nexport const searchWeb = recipe<\n SearchQuery,\n SearchWebResult | { error: string }\n>(({ query }) => {\n const { result, error } = fetchData<SearchWebResult>({\n url: \"/api/agent-tools/web-search\",\n mode: \"json\",\n options: {\n method: \"POST\",\n headers: {\n \"Content-Type\": \"application/json\",\n },\n body: {\n query,\n max_results: 5,\n },\n },\n });\n\n // TODO(seefeld): Should we instead return { result, error }? Or allocate a\n // special [ERROR] for errors? Ideally this isn't specific to using recipes as\n // tools but a general pattern.\n return ifElse(error, { error }, result);\n});\n\n/** Read and extract content from a specific webpage URL. */\ntype ReadWebRequest = {\n /** The URL of the webpage to read and extract content from. */\n url: string;\n};\n\ntype ReadWebResult = {\n content: string;\n metadata: {\n title?: string;\n author?: string;\n date?: string;\n word_count: number;\n };\n};\n\nexport const readWebpage = recipe<\n ReadWebRequest,\n ReadWebResult | { error: string }\n>(({ url }) => {\n const { result, error } = fetchData<ReadWebResult>({\n url: \"/api/agent-tools/web-read\",\n mode: \"json\",\n options: {\n method: \"POST\",\n headers: {\n \"Content-Type\": \"application/json\",\n },\n body: {\n url,\n max_tokens: 4000,\n include_code: true,\n },\n },\n });\n\n return ifElse(error, { error }, result);\n});\n\ntype ToolsInput = {\n list: ListItem[];\n};\n\nexport default recipe<ToolsInput>(({ list }) => {\n const tools: Record<string, BuiltInLLMTool> = {\n search_web: {\n pattern: searchWeb,\n },\n read_webpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n addListItem: {\n handler: addListItem({ list }),\n },\n };\n\n return { tools, list };\n});\n\n/**\n * `fetchAndRunPattern({ url: \"https://...\", args: {} })`\n *\n * Instantiates patterns (e.g. from listPatternIndex) and returns the cell that\n * contains the results. The instantiated pattern will keep running and updating\n * the cell. Pass the resulting cell to `navigateTo` to show the pattern's UI.\n *\n * Pass in arguments to initialize the pattern. It's especially useful to pass\n * in links to other cells as `{ \"@link\": \"/of:bafe.../path/to/data\" }`.\n */\ntype FetchAndRunPatternInput = {\n url: string;\n args: Cell<any>;\n};\nexport const fetchAndRunPattern = recipe<FetchAndRunPatternInput>(\n ({ url, args }) => {\n const { pending: _fetchPending, result: program, error: _fetchError } =\n fetchProgram({ url });\n\n // Use derive to safely handle when program is undefined/pending\n const compileParams = derive(program, (p) => ({\n files: p?.files ?? [],\n main: p?.main ?? \"\",\n input: args,\n }));\n\n const { pending, result, error } = compileAndRun(compileParams);\n\n return ifElse(\n computed(() => pending || (!result && !error)),\n undefined,\n {\n cell: result,\n error,\n },\n );\n },\n);\n\n/**\n * `navigateTo({ cell: { \"@link\": \"/of:xyz\" } })` - Navigates to that cell's UI\n *\n * Especially useful after instantiating a pattern with fetchAndRunPattern:\n * Pass the \"@link\" you get at `cell` to navigate to the pattern's view.\n */\ntype NavigateToPatternInput = { cell: Cell<any> }; // Hack to steer LLM\nexport const navigateToPattern = recipe<NavigateToPatternInput>(\n ({ cell }) => {\n const success = navigateTo(cell);\n\n return ifElse(success, { success }, undefined);\n },\n);\n\n/**\n * `listPatternIndex()` - Returns the index of patterns.\n *\n * Useful as input to fetchAndRun.\n */\ntype ListPatternIndexInput = Record<string, never>;\n\nexport const listPatternIndex = recipe<ListPatternIndexInput>(\n ({ _ }) => {\n const { pending, result } = fetchData({\n url: \"/api/patterns/index.md\",\n mode: \"text\",\n });\n return ifElse(computed(() => pending || !result), undefined, { result });\n },\n);\n"}}}}}}},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcbdphpn2q2i2xpemk6ppk4mhwt37i3fjmudeb76e5mir6j3z7ge7p":{}},"signature":{"/":{"bytes":"YREskRZlLIjG21NWGcOvySOEd236H4fEqQN6b/LUwT1ndgvBQ5hJeXae8t4/74l+WuPwbDrdhYLw69W04SDsCg"}}}}	61974	
16:19:04.876
{"invocation":{"cmd":"/memory/transact","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"changes":{"of:baedreieyiogei24j2gp74jdnq7a2rfz3epxrpr2m7a3377pouo2b6irjrq":{"application/json":{"ba4jcbdtulsfp5h2u4q4jjz4zjo5gwvk5hvswfmhvlvuwrlbojo2r556q":{"is":{"value":{"id":"ba4jcau46w7evsb4pb5lwv2bvsq4tckgi2grr4rqpph6g6actgrcdgtuy","program":{"main":"/chatbot.tsx","mainExport":"default","files":[{"/":{"link@1":{"path":[],"id":"of:baedreibjqrr4zlu2er6g35vj4mwlrxbxqdmmaqjw6otrt22qcb5fyilbai"}}},{"/":{"link@1":{"path":[],"id":"of:baedreid7bzj4uicsmdnk22mjlnjym3dqon7f7khyhx6xqbnacbnlov5bke"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiba66vxbnad4nwimspodl3ltfhcslgxczkgiawiqepd5lolqnbqne"}}},{"/":{"link@1":{"path":[],"id":"of:baedreick2gycexiujczwzpllpskjgsb5qmrucstl6xnrwctl2emxfpwiiu"}}},{"/":{"link@1":{"path":[],"id":"of:baedreibqen7jkaosqutvpkb7zykntkttjboqboc67iag5wwrmaxok4gbje"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiagkv73fscz42qr5xzxwryzuymomgh3dy2t7lriqqcnifomwvrnsa"}}},{"/":{"link@1":{"path":[],"id":"of:baedreic7noxehkifivzuq24uujwbqsclxy72vll7pwhluzbausro3h2vze"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiebaipoghmik7rdpgroyn4fvz6tykutknj6i3z5ppi26meuqarsvy"}}},{"/":{"link@1":{"path":[],"id":"of:baedreidv65y2ckzqj5m6j2enkxeor5ywizljplzl5qhnkgqem6frf5s6m4"}}}]}}}}}},"of:baedreibjqrr4zlu2er6g35vj4mwlrxbxqdmmaqjw6otrt22qcb5fyilbai":{"application/json":{"ba4jcbxxivwtmc626jz7u2cr5hblhx4tx66otikpaal2bd2z4quvb4fio":{"is":{"value":{"name":"/default-app.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n handler,\n NAME,\n navigateTo,\n recipe,\n str,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chatbot from \"./chatbot.tsx\";\nimport ChatbotOutliner from \"./chatbot-outliner.tsx\";\nimport { default as Note } from \"./note.tsx\";\nimport BacklinksIndex, { type MentionableCharm } from \"./backlinks-index.tsx\";\nimport ChatList from \"./chatbot-list-view.tsx\";\nimport OmniboxFAB from \"./omnibox-fab.tsx\";\n\ntype MinimalCharm = {\n [NAME]?: string;\n};\n\ntype CharmsListInput = void;\n\n// Recipe returns only UI, no data outputs (only symbol properties)\ninterface CharmsListOutput {\n [key: string]: unknown;\n backlinksIndex: {\n mentionable: MentionableCharm[];\n };\n sidebarUI: unknown;\n fabUI: unknown;\n}\n\nconst _visit = handler<\n Record<string, never>,\n { charm: Cell<MinimalCharm> }\n>((_, state) => {\n return navigateTo(state.charm);\n}, { proxy: true });\n\nconst removeCharm = handler<\n Record<string, never>,\n {\n charm: Cell<MinimalCharm>;\n allCharms: Cell<MinimalCharm[]>;\n }\n>((_, state) => {\n const allCharmsValue = state.allCharms.get();\n const index = allCharmsValue.findIndex((c: any) => state.charm.equals(c));\n\n if (index !== -1) {\n const charmListCopy = [...allCharmsValue];\n console.log(\"charmListCopy before\", charmListCopy.length);\n charmListCopy.splice(index, 1);\n console.log(\"charmListCopy after\", charmListCopy.length);\n state.allCharms.set(charmListCopy);\n }\n});\n\nconst toggleFab = handler<any, { fabExpanded: Cell<boolean> }>(\n (_, { fabExpanded }) => {\n fabExpanded.set(!fabExpanded.get());\n },\n);\n\nconst spawnChatList = handler<void, void>((_, __) => {\n return navigateTo(ChatList({\n selectedCharm: { charm: undefined },\n charmsList: [],\n }));\n});\n\nconst spawnChatbot = handler<void, void>((_, __) => {\n return navigateTo(Chatbot({\n messages: [],\n tools: undefined,\n }));\n});\n\nconst spawnChatbotOutliner = handler<void, void>((_, __) => {\n return navigateTo(ChatbotOutliner({\n title: \"Chatbot Outliner\",\n expandChat: false,\n messages: [],\n outline: {\n root: { body: \"\", children: [], attachments: [] },\n },\n }));\n});\n\nconst spawnNote = handler<void, void>((_, __) => {\n return navigateTo(Note({\n title: \"New Note\",\n content: \"\",\n }));\n});\n\nexport default recipe<CharmsListInput, CharmsListOutput>(\n \"DefaultCharmList\",\n (_) => {\n const { allCharms } = wish<{ allCharms: MentionableCharm[] }>(\"/\");\n const index = BacklinksIndex({ allCharms });\n\n const fab = OmniboxFAB({\n mentionable: index.mentionable as unknown as Cell<MentionableCharm[]>,\n });\n\n return {\n backlinksIndex: index,\n [NAME]: str`DefaultCharmList (${allCharms.length})`,\n [UI]: (\n <ct-screen>\n <ct-keybind\n code=\"KeyN\"\n alt\n preventDefault\n onct-keybind={spawnChatList()}\n />\n <ct-keybind\n code=\"KeyO\"\n meta\n preventDefault\n onct-keybind={toggleFab({ fabExpanded: fab.fabExpanded })}\n />\n <ct-keybind\n code=\"KeyO\"\n ctrl\n preventDefault\n onct-keybind={toggleFab({ fabExpanded: fab.fabExpanded })}\n />\n\n <ct-toolbar slot=\"header\" sticky>\n <div slot=\"start\">\n <ct-button\n onClick={spawnChatList()}\n >\n üìÇ Chat List\n </ct-button>\n <ct-button\n onClick={spawnChatbot()}\n >\n üí¨ Chatbot\n </ct-button>\n <ct-button\n onClick={spawnChatbotOutliner()}\n >\n üìù Chatbot Outliner\n </ct-button>\n <ct-button\n onClick={spawnNote()}\n >\n üìÑ Note\n </ct-button>\n </div>\n </ct-toolbar>\n\n <ct-vscroll flex showScrollbar>\n <ct-vstack gap=\"4\" padding=\"6\">\n <style>\n {`\n .pattern-link {\n cursor: pointer;\n color: inherit;\n text-decoration: none;\n }\n .pattern-link:hover {\n text-decoration: underline;\n }\n `}\n </style>\n <h2>Pages</h2>\n\n <ct-table full-width hover>\n <tbody>\n {allCharms.map((charm) => (\n <tr>\n <td>\n <ct-cell-context $cell={charm}>\n <ct-cell-link $cell={charm} />\n </ct-cell-context>\n </td>\n <td>\n <ct-button\n size=\"sm\"\n variant=\"ghost\"\n onClick={removeCharm({ charm, allCharms })}\n >\n üóëÔ∏è\n </ct-button>\n </td>\n </tr>\n ))}\n </tbody>\n </ct-table>\n </ct-vstack>\n </ct-vscroll>\n </ct-screen>\n ),\n sidebarUI: undefined,\n fabUI: fab[UI],\n };\n },\n);\n"}}}}},"of:baedreid7bzj4uicsmdnk22mjlnjym3dqon7f7khyhx6xqbnacbnlov5bke":{"application/json":{"ba4jcb7grioxlaenm7o4xtl5rlq3lxhhi7px5siqpibef3n5fshqee33l":{"is":{"value":{"name":"/chatbot.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n computed,\n Default,\n fetchData,\n generateObject,\n handler,\n llmDialog,\n NAME,\n pattern,\n patternTool,\n Stream,\n UI,\n VNode,\n wish,\n} from \"commontools\";\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\n\nfunction schemaifyWish<T>(path: string) {\n return wish<T>(path);\n}\n\nconst sendMessage = handler<\n {\n detail: {\n text: string;\n attachments: Array<PromptAttachment>;\n mentions: Array<any>;\n message: string; // Backward compatibility\n };\n },\n {\n addMessage: Stream<BuiltInLLMMessage>;\n }\n>((event, { addMessage }) => {\n const { text } = event.detail;\n\n // Send the message as-is. Any markdown links like [name](/of:...)\n // are just text that the LLM can parse and use with addAttachment() tool.\n addMessage.send({\n role: \"user\",\n content: [{ type: \"text\" as const, text }],\n });\n});\n\nconst clearChat = handler(\n (\n _: never,\n { messages, pending }: {\n messages: Cell<Array<BuiltInLLMMessage>>;\n pending: Cell<boolean | undefined>;\n },\n ) => {\n messages.set([]);\n pending.set(false);\n },\n);\n\ntype ChatInput = {\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n tools?: any;\n theme?: any;\n system?: string;\n};\n\ntype PromptAttachment = {\n id: string;\n name: string;\n type: \"file\" | \"clipboard\" | \"mention\";\n data?: any; // File | Blob | string\n charm?: any;\n removable?: boolean; // Whether this attachment can be removed\n};\n\ntype ChatOutput = {\n messages: Array<BuiltInLLMMessage>;\n pending: boolean | undefined;\n addMessage: Stream<BuiltInLLMMessage>;\n clearChat: Stream<void>;\n cancelGeneration: Stream<void>;\n title?: string;\n pinnedCells: Array<PromptAttachment>;\n tools: any;\n ui: {\n chatLog: VNode;\n promptInput: VNode;\n attachmentsAndTools: VNode;\n };\n};\n\nexport const TitleGenerator = pattern<\n { model?: string; messages: Array<BuiltInLLMMessage> }\n>(({ model, messages }) => {\n const previewMessage = computed(() => {\n if (!messages || messages.length === 0) return \"\";\n\n const firstMessage = messages[0];\n\n if (!firstMessage) return \"\";\n\n return JSON.stringify(firstMessage);\n });\n\n const { result } = generateObject({\n system:\n \"Generate at most a 3-word title based on the following content, respond with NOTHING but the literal title text.\",\n prompt: previewMessage,\n model,\n schema: {\n type: \"object\",\n properties: {\n title: {\n type: \"string\",\n description: \"The title of the chat\",\n },\n },\n required: [\"title\"],\n },\n });\n\n const title = computed(() => {\n return result?.title || \"Untitled Chat\";\n });\n\n return title;\n});\n\nconst listMentionable = pattern<\n { mentionable: Array<MentionableCharm> },\n { result: Array<{ label: string; cell: Cell<unknown> }> }\n>(\n ({ mentionable }) => {\n const result = mentionable.map((charm) => ({\n label: charm[NAME]!,\n cell: charm,\n }));\n return { result };\n },\n);\n\nconst listRecent = pattern<\n { recentCharms: Array<MentionableCharm> },\n { result: Array<{ label: string; cell: Cell<unknown> }> }\n>(\n ({ recentCharms }) => {\n const namesList = recentCharms.map((charm) => ({\n label: charm[NAME]!,\n cell: charm,\n }));\n return { result: namesList };\n },\n);\n\nexport default pattern<ChatInput, ChatOutput>(\n ({ messages, tools, theme, system }) => {\n const model = Cell.of<string>(\"anthropic:claude-sonnet-4-5\");\n const mentionable = schemaifyWish<MentionableCharm[]>(\"#mentionable\");\n const recentCharms = schemaifyWish<MentionableCharm[]>(\"#recent\");\n\n const assistantTools = {\n listMentionable: patternTool(listMentionable, { mentionable }),\n listRecent: patternTool(listRecent, { recentCharms }),\n };\n\n // Merge static and assistant tools\n const mergedTools = computed(() => ({\n ...tools,\n ...assistantTools,\n }));\n\n const latest = computed(() => recentCharms[0]);\n const latestName = computed(() => recentCharms[0]?.[NAME]);\n\n const {\n addMessage,\n cancelGeneration,\n pending,\n flattenedTools,\n pinnedCells,\n } = llmDialog(\n {\n system: computed(() => {\n return system ?? \"You are a polite but efficient assistant.\";\n }),\n messages,\n tools: mergedTools,\n model,\n context: computed(() => ({\n [latestName]: latest,\n })),\n },\n );\n\n const { result } = fetchData({\n url: \"/api/ai/llm/models\",\n mode: \"json\",\n });\n\n const items = computed(() => {\n if (!result) return [];\n const items = Object.keys(result as any).map((key) => ({\n label: key,\n value: key,\n }));\n return items;\n });\n\n const title = TitleGenerator({ model, messages });\n\n const promptInput = (\n <ct-prompt-input\n slot=\"footer\"\n placeholder=\"Ask the LLM a question...\"\n pending={pending}\n $mentionable={mentionable}\n modelItems={items}\n $model={model}\n onct-send={sendMessage({ addMessage })}\n onct-stop={cancelGeneration}\n />\n );\n\n const chatLog = (\n <ct-vscroll\n style=\"padding: 1rem;\"\n flex\n showScrollbar\n fadeEdges\n snapToBottom\n >\n <ct-chat\n theme={theme}\n $messages={messages}\n pending={pending}\n tools={flattenedTools}\n />\n </ct-vscroll>\n );\n\n const attachmentsAndTools = (\n <ct-hstack align=\"center\" gap=\"1\">\n <ct-cell-context $cell={pinnedCells}>\n <ct-attachments-bar pinnedCells={pinnedCells} />\n </ct-cell-context>\n <ct-tools-chip tools={flattenedTools} />\n <ct-button\n variant=\"pill\"\n type=\"button\"\n title=\"Clear chat\"\n onClick={clearChat({\n messages,\n pending,\n })}\n >\n Clear\n </ct-button>\n </ct-hstack>\n );\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <ct-vstack slot=\"header\">\n <ct-heading level={4}>{title}</ct-heading>\n {attachmentsAndTools}\n </ct-vstack>\n\n {chatLog}\n\n {promptInput}\n </ct-screen>\n ),\n messages,\n pending,\n addMessage,\n clearChat: clearChat({\n messages,\n pending,\n }),\n cancelGeneration,\n title,\n pinnedCells,\n tools: flattenedTools,\n ui: {\n chatLog,\n promptInput,\n attachmentsAndTools,\n },\n };\n },\n);\n"}}}}},"of:baedreiba66vxbnad4nwimspodl3ltfhcslgxczkgiawiqepd5lolqnbqne":{"application/json":{"ba4jcahrblxwmcb463tjgiyonk4ushhgvqtqyq5mxctybfax5feeztyow":{"is":{"value":{"name":"/chatbot-outliner.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n Default,\n derive,\n handler,\n ifElse,\n JSONSchema,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot.tsx\";\nimport { MentionableCharm } from \"./backlinks-index.tsx\";\n\ntype Charm = any;\n\ntype OutlinerNode = {\n body: Default<string, \"\">;\n children: Default<OutlinerNode[], []>;\n attachments: Default<OpaqueRef<any>[], []>;\n};\n\ntype Outliner = {\n root: OutlinerNode;\n};\n\ntype PageResult = {\n outline: Default<\n Outliner,\n { root: { body: \"\"; children: []; attachments: [] } }\n >;\n};\n\nexport type PageInput = {\n outline: Outliner;\n};\n\nconst handleCharmLinkClick = handler<\n {\n detail: {\n charm: Cell<Charm>;\n };\n },\n Record<string, never>\n>(({ detail }, _) => {\n return navigateTo(detail.charm);\n});\n\nfunction getMentionable() {\n return derive<MentionableCharm[], MentionableCharm[]>(\n wish<MentionableCharm[]>(\"#mentionable\"),\n (i) => i,\n );\n}\n\nexport const Page = recipe<PageInput>(\n \"Page\",\n ({ outline }) => {\n const mentionable = getMentionable();\n\n return {\n [NAME]: \"Page\",\n [UI]: (\n <ct-outliner\n $value={outline as any}\n $mentionable={mentionable}\n oncharm-link-click={handleCharmLinkClick({})}\n />\n ),\n outline,\n };\n },\n);\n\ntype LLMTestInput = {\n title?: Cell<Default<string, \"LLM Test\">>;\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n expandChat?: Cell<Default<boolean, false>>;\n outline?: Default<\n Outliner,\n { root: { body: \"Untitled Page\"; children: []; attachments: [] } }\n >;\n};\n\ntype LLMTestResult = {\n messages: Default<Array<BuiltInLLMMessage>, []>;\n};\n\n// put a node at the end of the outline (by appending to root.children)\nconst appendOutlinerNode = handler<\n {\n /** The text content/title of the outliner node to be appended */\n body: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { outline: Cell<Outliner> }\n>(\n (args, state) => {\n try {\n (state.outline.key(\"root\").key(\"children\")).push({\n body: args.body,\n children: [],\n attachments: [],\n });\n\n args.result.set(\n `${state.outline.key(\"root\").key(\"children\").get().length} nodes`,\n );\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nexport default recipe<LLMTestInput, LLMTestResult>(\n \"Outliner\",\n ({ title, expandChat, messages, outline }) => {\n const tools = {\n appendOutlinerNode: {\n description: \"Add a new outliner node.\",\n inputSchema: {\n type: \"object\",\n properties: {\n body: {\n type: \"string\",\n description: \"The title of the new node.\",\n },\n },\n required: [\"body\"],\n } as JSONSchema,\n handler: appendOutlinerNode({ outline }),\n },\n };\n\n const chat = Chat({ messages, tools });\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <ct-hstack justify=\"between\" slot=\"header\">\n <div></div>\n <div>\n <ct-checkbox $checked={expandChat}>Show Chat</ct-checkbox>\n </div>\n </ct-hstack>\n\n <ct-autolayout tabNames={[\"Chat\", \"Tools\"]}>\n <ct-screen>\n <div slot=\"header\">\n <ct-input\n $value={title}\n placeholder=\"Enter title...\"\n />\n </div>\n\n <ct-vscroll flex showScrollbar fadeEdges snapToBottom>\n <ct-vstack data-label=\"Tools\">\n <Page outline={outline} />\n </ct-vstack>\n </ct-vscroll>\n </ct-screen>\n\n {ifElse(\n expandChat,\n chat,\n null,\n )}\n </ct-autolayout>\n </ct-screen>\n ),\n messages,\n };\n },\n);\n"}}}}},"of:baedreick2gycexiujczwzpllpskjgsb5qmrucstl6xnrwctl2emxfpwiiu":{"application/json":{"ba4jcainkphdja4apjpdqxsvpy5jdhaf6btz6cnifqerflg2faqo7c4mq":{"is":{"value":{"name":"/note.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n cell,\n type Default,\n derive,\n generateText,\n handler,\n NAME,\n navigateTo,\n patternTool,\n recipe,\n str,\n Stream,\n UI,\n wish,\n} from \"commontools\";\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\ntype Input = {\n title?: Cell<Default<string, \"Untitled Note\">>;\n content?: Cell<Default<string, \"\">>;\n};\n\n/** Represents a small #note a user took to remember some text. */\ntype Output = {\n mentioned: Default<Array<MentionableCharm>, []>;\n backlinks: MentionableCharm[];\n\n content: Default<string, \"\">;\n grep: Stream<{ query: string }>;\n translate: Stream<{ language: string }>;\n editContent: Stream<{ detail: { value: string } }>;\n};\n\nconst _updateTitle = handler<\n { detail: { value: string } },\n { title: Cell<string> }\n>(\n (event, state) => {\n state.title.set(event.detail?.value ?? \"\");\n },\n);\n\nconst _updateContent = handler<\n { detail: { value: string } },\n { content: Cell<string> }\n>(\n (event, state) => {\n state.content.set(event.detail?.value ?? \"\");\n },\n);\n\nconst handleCharmLinkClick = handler<\n {\n detail: {\n charm: Cell<MentionableCharm>;\n };\n },\n Record<string, never>\n>(({ detail }, _) => {\n return navigateTo(detail.charm);\n});\n\nconst handleNewBacklink = handler<\n {\n detail: {\n text: string;\n charmId: any;\n charm: Cell<MentionableCharm>;\n navigate: boolean;\n };\n },\n {\n mentionable: Cell<MentionableCharm[]>;\n }\n>(({ detail }, { mentionable }) => {\n console.log(\"new charm\", detail.text, detail.charmId);\n\n if (detail.navigate) {\n return navigateTo(detail.charm);\n } else {\n mentionable.push(detail.charm as unknown as MentionableCharm);\n }\n});\n\n/** This edits the content */\nconst handleEditContent = handler<\n { detail: { value: string }; result?: Cell<string> },\n { content: Cell<string> }\n>(\n ({ detail, result }, { content }) => {\n content.set(detail.value);\n result?.set(\"test!\");\n },\n);\n\nconst handleCharmLinkClicked = handler<void, { charm: Cell<MentionableCharm> }>(\n (_, { charm }) => {\n return navigateTo(charm);\n },\n);\n\nfunction schemaifyWish<T>(path: string, def: T) {\n return derive(wish<T>(path) as T, (i) => i ?? def);\n}\n\nconst Note = recipe<Input, Output>(\n \"Note\",\n ({ title, content }) => {\n const mentionable = schemaifyWish<MentionableCharm[]>(\n \"#mentionable\",\n [],\n );\n const mentioned = cell<MentionableCharm[]>([]);\n\n // populated in backlinks-index.tsx\n const backlinks = cell<MentionableCharm[]>([]);\n\n // The only way to serialize a pattern, apparently?\n const pattern = derive(undefined, () => JSON.stringify(Note));\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <div slot=\"header\">\n <ct-input\n $value={title}\n placeholder=\"Enter title...\"\n />\n </div>\n\n <ct-code-editor\n $value={content}\n $mentionable={mentionable}\n $mentioned={mentioned}\n $pattern={pattern}\n onbacklink-click={handleCharmLinkClick({})}\n onbacklink-create={handleNewBacklink({ mentionable })}\n language=\"text/markdown\"\n theme=\"light\"\n wordWrap\n tabIndent\n lineNumbers\n />\n\n <ct-hstack slot=\"footer\">\n {backlinks?.map((charm) => (\n <ct-button\n onClick={handleCharmLinkClicked({ charm })}\n >\n {charm?.[NAME]}\n </ct-button>\n ))}\n </ct-hstack>\n </ct-screen>\n ),\n title,\n content,\n mentioned,\n backlinks,\n grep: patternTool(\n ({ query, content }: { query: string; content: string }) => {\n return derive({ query, content }, ({ query, content }) => {\n return content.split(\"\\n\").filter((c) => c.includes(query));\n });\n },\n { content },\n ),\n translate: patternTool(\n (\n { language, content }: {\n language: string;\n content: string;\n },\n ) => {\n const result = generateText({\n system: str`Translate the content to ${language}.`,\n prompt: str`<to_translate>${content}</to_translate>`,\n });\n\n return derive(result, ({ pending, result }) => {\n if (pending) return undefined;\n if (result == null) return \"Error occured\";\n return result;\n });\n },\n { content },\n ),\n editContent: handleEditContent({ content }),\n };\n },\n);\n\nexport default Note;\n"}}}}},"of:baedreibqen7jkaosqutvpkb7zykntkttjboqboc67iag5wwrmaxok4gbje":{"application/json":{"ba4jcasdbrhmscujkmfg3ovdvexfm76d4dcozrflvarsfre5p6m6appkq":{"is":{"value":{"name":"/backlinks-index.tsx","contents":"/// <cts-enable />\nimport { Cell, derive, lift, NAME, OpaqueRef, recipe, UI } from \"commontools\";\n\nexport type MentionableCharm = {\n [NAME]?: string;\n mentioned: MentionableCharm[];\n backlinks: MentionableCharm[];\n};\n\nexport type WriteableBacklinks = {\n mentioned: WriteableBacklinks[];\n backlinks: Cell<WriteableBacklinks[]>;\n};\n\ntype Input = {\n allCharms: MentionableCharm[];\n};\n\ntype Output = {\n mentionable: MentionableCharm[];\n};\n\nconst computeIndex = lift<\n { allCharms: WriteableBacklinks[] },\n void\n>(\n ({ allCharms }) => {\n const cs = allCharms ?? [];\n\n for (const c of cs) {\n c.backlinks?.set([]);\n }\n\n for (const c of cs) {\n const mentions = c.mentioned ?? [];\n for (const m of mentions) {\n m?.backlinks?.push(c);\n }\n }\n },\n);\n\n/**\n * BacklinksIndex builds a map of backlinks across all charms and exposes a\n * unified mentionable list for consumers like editors.\n *\n * Behavior:\n * - Backlinks are computed by scanning each charm's `mentioned` list and\n * mapping mention target -> list of source charms.\n * - Mentionable list is a union of:\n * - every charm in `allCharms`\n * - any items a charm exports via a `mentionable` property\n * (either an array of charms or a Cell of such an array)\n *\n * The backlinks map is keyed by a charm's `content` value (falling back to\n * its `[NAME]`). This mirrors how existing note patterns identify notes when\n * computing backlinks locally.\n */\nconst BacklinksIndex = recipe<Input, Output>(\n \"BacklinksIndex\",\n ({ allCharms }) => {\n computeIndex({\n allCharms: allCharms as unknown as OpaqueRef<WriteableBacklinks[]>,\n });\n\n // Compute mentionable list from allCharms reactively\n const mentionable = derive(allCharms, (charmList) => {\n const cs = charmList ?? [];\n const out: MentionableCharm[] = [];\n for (const c of cs) {\n out.push(c);\n const exported = (c as unknown as {\n mentionable?: MentionableCharm[] | { get?: () => MentionableCharm[] };\n }).mentionable;\n if (Array.isArray(exported)) {\n for (const m of exported) if (m) out.push(m);\n } else if (exported && typeof (exported as any).get === \"function\") {\n const arr = (exported as { get: () => MentionableCharm[] }).get() ??\n [];\n for (const m of arr) if (m) out.push(m);\n }\n }\n return out;\n });\n\n return {\n [NAME]: \"BacklinksIndex\",\n [UI]: undefined,\n mentionable,\n };\n },\n);\n\nexport default BacklinksIndex;\n"}}}}},"of:baedreiagkv73fscz42qr5xzxwryzuymomgh3dy2t7lriqqcnifomwvrnsa":{"application/json":{"ba4jcap5cuwebfxmiw7gpnk7luwxpdw6ir7yh2yliulbus45rg7rt3m6k":{"is":{"value":{"name":"/chatbot-list-view.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n Default,\n derive,\n handler,\n ID,\n ifElse,\n lift,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n toSchema,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot-note-composed.tsx\";\nimport { ListItem } from \"./common-tools.tsx\";\n\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\ntype CharmEntry = {\n [ID]: string; // randomId is a string\n local_id: string; // same as ID but easier to access\n charm: any;\n};\n\ntype Input = {\n selectedCharm: Default<{ charm: any }, { charm: undefined }>;\n charmsList: Default<CharmEntry[], []>;\n theme?: {\n accentColor: Cell<Default<string, \"#3b82f6\">>;\n fontFace: Cell<Default<string, \"system-ui, -apple-system, sans-serif\">>;\n borderRadius: Cell<Default<string, \"0.5rem\">>;\n };\n};\n\ntype Output = {\n selectedCharm: Default<{ charm: any }, { charm: undefined }>;\n // Expose a mentionable list aggregated from local chat entries\n // Returned as an opaque ref to an array (not a Cell), suitable for\n // upstream aggregators that read exported mentionables.\n mentionable?: MentionableCharm[];\n};\n\nconst removeChat = handler<\n unknown,\n {\n charmsList: Cell<CharmEntry[]>;\n id: string;\n selectedCharm: Cell<Default<{ charm: any }, { charm: undefined }>>;\n }\n>(\n (\n _,\n { charmsList, id, selectedCharm },\n ) => {\n const list = charmsList.get();\n const index = list.findIndex((entry) => entry.local_id === id);\n if (index === -1) return;\n\n const removed = list[index];\n const next = [...list];\n next.splice(index, 1);\n charmsList.set(next);\n\n // If we removed the currently selected charm, choose a new selection.\n const current = selectedCharm.get();\n if (current?.charm === removed.charm) {\n const replacement = next[index] ?? next[index - 1];\n if (replacement) {\n selectedCharm.set({ charm: replacement.charm });\n } else {\n selectedCharm.set({ charm: undefined as unknown as any });\n }\n }\n },\n);\n\n// this will be called whenever charm or selectedCharm changes\n// pass isInitialized to make sure we dont call this each time\n// we change selectedCharm, otherwise creates a loop\nconst storeCharm = lift(\n toSchema<{\n charm: any;\n selectedCharm: Cell<Default<{ charm: any }, { charm: undefined }>>;\n charmsList: Cell<CharmEntry[]>;\n allCharms: Cell<MentionableCharm[]>;\n theme?: {\n accentColor: Default<string, \"#3b82f6\">;\n fontFace: Default<string, \"system-ui, -apple-system, sans-serif\">;\n borderRadius: Default<string, \"0.5rem\">;\n };\n isInitialized: Cell<boolean>;\n }>(),\n undefined,\n ({ charm, selectedCharm, charmsList, isInitialized, allCharms: _ }) => { // Not including `allCharms` is a compile error...\n if (!isInitialized.get()) {\n console.log(\n \"storeCharm storing charm:\",\n charm,\n );\n selectedCharm.set({ charm });\n\n // create the chat charm with a custom name including a random suffix\n const randomId = Math.random().toString(36).substring(2, 10); // Random 8-char string\n charmsList.push({ [ID]: randomId, local_id: randomId, charm });\n\n isInitialized.set(true);\n return charm;\n } else {\n console.log(\"storeCharm: already initialized\");\n }\n return undefined;\n },\n);\n\nconst populateChatList = lift(\n toSchema<{\n charmsList: CharmEntry[];\n allCharms: Cell<any[]>;\n selectedCharm: Cell<{ charm: any }>;\n }>(),\n undefined,\n (\n { charmsList, allCharms, selectedCharm },\n ) => {\n if (charmsList.length === 0) {\n const isInitialized = Cell.of(false);\n return storeCharm({\n charm: Chat({\n title: \"New Chat\",\n messages: [],\n }),\n selectedCharm,\n charmsList,\n allCharms,\n isInitialized: isInitialized as unknown as Cell<boolean>,\n });\n }\n\n return charmsList;\n },\n);\n\nconst createChatRecipe = handler<\n unknown,\n {\n selectedCharm: Cell<{ charm: any }>;\n charmsList: Cell<CharmEntry[]>;\n allCharms: Cell<MentionableCharm[]>;\n }\n>(\n (_, { selectedCharm, charmsList, allCharms }) => {\n const isInitialized = Cell.of(false);\n\n const charm = Chat({\n title: \"New Chat\",\n messages: [],\n });\n // store the charm ref in a cell (pass isInitialized to prevent recursive calls)\n return storeCharm({\n charm,\n selectedCharm,\n charmsList: charmsList as unknown as OpaqueRef<CharmEntry[]>,\n allCharms,\n isInitialized: isInitialized as unknown as Cell<boolean>,\n });\n },\n);\n\nconst selectCharm = handler<\n unknown,\n { selectedCharm: Cell<{ charm: any }>; charm: any }\n>(\n (_, { selectedCharm, charm }) => {\n console.log(\"selectCharm: updating selectedCharm to \", charm);\n selectedCharm.set({ charm });\n return selectedCharm;\n },\n);\n\nconst logCharmsList = lift<\n { charmsList: Cell<CharmEntry[]> },\n Cell<CharmEntry[]>\n>(\n ({ charmsList }) => {\n console.log(\"logCharmsList: \", charmsList.get());\n return charmsList;\n },\n);\n\nconst _handleCharmLinkClicked = handler(\n (_: any, { charm }: { charm: Cell<MentionableCharm> }) => {\n return navigateTo(charm);\n },\n);\n\nconst _merge = lift(\n (\n { allCharms, charmsList }: { allCharms: any[]; charmsList: CharmEntry[] },\n ) => {\n return [...charmsList.map((c) => c.charm), ...allCharms];\n },\n);\n\nconst getSelectedCharm = lift<\n { entry: { charm: any | undefined } },\n {\n chat: unknown;\n list: ListItem[];\n } | undefined\n>(\n ({ entry }) => {\n return entry?.charm;\n },\n);\n\nconst getCharmName = lift(({ charm }: { charm: any }) => {\n return charm?.[NAME] || \"Unknown\";\n});\n\nconst extractLocalMentionable = lift<\n { list: CharmEntry[] },\n MentionableCharm[]\n>(({ list }) => {\n const out: MentionableCharm[] = [];\n for (const entry of list) {\n const c = entry.charm;\n out.push(c.chat);\n }\n return out;\n});\n\n// create the named cell inside the recipe body, so we do it just once\nexport default recipe<Input, Output>(\n \"Launcher\",\n ({ selectedCharm, charmsList, theme }) => {\n const allCharms = derive<MentionableCharm[], MentionableCharm[]>(\n wish<MentionableCharm[]>(\"#allCharms\"),\n (c) => c ?? [],\n );\n logCharmsList({ charmsList: charmsList as unknown as Cell<CharmEntry[]> });\n\n populateChatList({\n selectedCharm: selectedCharm as unknown as Cell<\n Pick<CharmEntry, \"charm\">\n >,\n charmsList,\n allCharms,\n });\n\n const selected = getSelectedCharm({ entry: selectedCharm });\n\n // Aggregate mentionables from the local charms list so that this\n // container exposes its child chat charms as mention targets.\n const localMentionable = extractLocalMentionable({ list: charmsList });\n\n const localTheme = theme ?? {\n accentColor: Cell.of(\"#3b82f6\"),\n fontFace: Cell.of(\"system-ui, -apple-system, sans-serif\"),\n borderRadius: Cell.of(\"0.5rem\"),\n };\n\n return {\n [NAME]: \"Launcher\",\n [UI]: (\n <ct-theme theme={localTheme as any}>\n <ct-screen>\n <div slot=\"header\">\n <ct-toolbar dense sticky>\n <div slot=\"start\">\n <ct-button\n id=\"new-chat-btn\"\n onClick={createChatRecipe({\n selectedCharm,\n charmsList,\n allCharms,\n })}\n >\n Create New Chat\n <ct-kbd>alt+N</ct-kbd>\n </ct-button>\n </div>\n </ct-toolbar>\n\n {/* Keyboard shortcuts */}\n <ct-keybind\n code=\"KeyN\"\n alt\n preventDefault\n onct-keybind={createChatRecipe({\n selectedCharm,\n charmsList,\n allCharms,\n })}\n />\n </div>\n <ct-autolayout\n leftOpen\n rightOpen={false}\n >\n {/* workaround: this seems to correctly start the sub-recipes on a refresh while directly rendering does not */}\n {/* this should be fixed after the builder-refactor (DX1) */}\n <ct-screen>\n <ct-render $cell={selected.chat} />\n </ct-screen>\n\n <aside slot=\"left\">\n <div>\n <ct-heading level={3}>Chat List</ct-heading>\n </div>\n <div role=\"list\">\n {charmsList.map((charmEntry) => (\n <ct-list-item\n onct-activate={selectCharm({\n selectedCharm,\n charm: charmEntry.charm,\n })}\n >\n <span>{getCharmName({ charm: charmEntry.charm })}</span>\n <span slot=\"meta\">{charmEntry.local_id}</span>\n <ct-button\n slot=\"actions\"\n size=\"sm\"\n title=\"Delete Chat\"\n variant=\"destructive\"\n onClick={removeChat({\n charmsList: charmsList as unknown as OpaqueRef<\n CharmEntry[]\n >,\n id: charmEntry.local_id,\n selectedCharm: selectedCharm as unknown as OpaqueRef<\n Default<{ charm: any }, { charm: undefined }>\n >,\n })}\n >\n üóëÔ∏è\n </ct-button>\n </ct-list-item>\n ))}\n </div>\n </aside>\n\n <aside slot=\"right\">\n {ifElse(\n selected,\n <>\n <ct-ct-collapsible>\n <ct-heading slot=\"trigger\" level={5} no-margin>\n List\n </ct-heading>\n <ct-list $value={selected.list} />\n </ct-ct-collapsible>\n </>,\n null,\n )}\n <ct-collapsible>\n <ct-heading slot=\"trigger\" level={5} no-margin>\n Theme\n </ct-heading>\n <ct-vstack style=\"padding: 0.5rem 0; gap: 0.5rem;\">\n <ct-vstack>\n <ct-text>Font Family</ct-text>\n <ct-select\n items={[\n {\n label: \"System\",\n value: \"system-ui, -apple-system, sans-serif\",\n },\n {\n label: \"Monospace\",\n value: \"ui-monospace, Consolas, monospace\",\n },\n {\n label: \"Serif\",\n value: \"Georgia, Times, serif\",\n },\n {\n label: \"Sans Serif\",\n value: \"Arial, Helvetica, sans-serif\",\n },\n ]}\n $value={localTheme.fontFace}\n />\n </ct-vstack>\n\n <ct-vstack>\n <ct-text>Accent Color</ct-text>\n <ct-select\n items={[\n { label: \"Blue\", value: \"#3b82f6\" },\n { label: \"Purple\", value: \"#8b5cf6\" },\n { label: \"Green\", value: \"#10b981\" },\n { label: \"Red\", value: \"#ef4444\" },\n { label: \"Orange\", value: \"#f97316\" },\n { label: \"Pink\", value: \"#ec4899\" },\n { label: \"Indigo\", value: \"#6366f1\" },\n { label: \"Teal\", value: \"#14b8a6\" },\n ]}\n $value={localTheme.accentColor}\n />\n </ct-vstack>\n\n <ct-vstack>\n <ct-text>Border Radius</ct-text>\n <ct-select\n items={[\n { label: \"None\", value: \"0px\" },\n { label: \"Small\", value: \"0.25rem\" },\n { label: \"Medium\", value: \"0.5rem\" },\n { label: \"Large\", value: \"0.75rem\" },\n { label: \"Extra Large\", value: \"1rem\" },\n { label: \"Rounded\", value: \"1.5rem\" },\n ]}\n $value={localTheme.borderRadius}\n />\n </ct-vstack>\n </ct-vstack>\n </ct-collapsible>\n </aside>\n </ct-autolayout>\n </ct-screen>\n </ct-theme>\n ),\n selectedCharm,\n charmsList,\n // Expose the aggregated mentionables for parent-level indexing.\n mentionable: localMentionable,\n };\n },\n);\n"}}}}},"of:baedreic7noxehkifivzuq24uujwbqsclxy72vll7pwhluzbausro3h2vze":{"application/json":{"ba4jcbm35tlesj5uqlj2uipq2akeewnnenslazh5qvsex754hol6fdj7j":{"is":{"value":{"name":"/omnibox-fab.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n computed,\n handler,\n ifElse,\n NAME,\n pattern,\n patternTool,\n UI,\n} from \"commontools\";\nimport Chatbot from \"./chatbot.tsx\";\nimport {\n calculator,\n fetchAndRunPattern,\n listPatternIndex,\n navigateToPattern,\n readWebpage,\n searchWeb,\n} from \"./common-tools.tsx\";\nimport { MentionableCharm } from \"./backlinks-index.tsx\";\n\ninterface OmniboxFABInput {\n mentionable: Cell<MentionableCharm[]>;\n}\n\nconst toggle = handler<any, { value: Cell<boolean> }>((_, { value }) => {\n value.set(!value.get());\n});\n\nconst closeFab = handler<any, { fabExpanded: Cell<boolean> }>(\n (_, { fabExpanded }) => {\n fabExpanded.set(false);\n },\n);\n\nconst dismissPeek = handler<\n any,\n { peekDismissedIndex: Cell<number>; assistantMessageCount: number }\n>((_, { peekDismissedIndex, assistantMessageCount }) => {\n // Store the current assistant message count so we know which message was dismissed\n peekDismissedIndex.set(assistantMessageCount);\n});\n\nexport default pattern<OmniboxFABInput>(\n (_) => {\n const omnibot = Chatbot({\n system:\n \"You are a polite but efficient assistant. Think Star Trek computer - helpful and professional without unnecessary conversation. Let your actions speak for themselves.\\n\\nTool usage priority:\\n- For patterns: listPatternIndex first\\n- For existing pages/notes/content: listRecent or listMentionable to identify what they're referencing\\n- Attach relevant items to conversation after instantiation/retrieval if they support ongoing tasks\\n- Remove attachments when no longer relevant\\n- Search web only as last resort when nothing exists in the space\\n\\nBe matter-of-fact. Prefer action to explanation.\",\n tools: {\n searchWeb: {\n pattern: searchWeb,\n },\n readWebpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n fetchAndRunPattern: patternTool(fetchAndRunPattern),\n listPatternIndex: patternTool(listPatternIndex),\n navigateTo: patternTool(navigateToPattern),\n },\n });\n\n const fabExpanded = Cell.of(false);\n const showHistory = Cell.of(false);\n const peekDismissedIndex = Cell.of(-1); // Track which message index was dismissed\n\n // Derive assistant message count for dismiss tracking\n const assistantMessageCount = computed(() => {\n return omnibot.messages.filter((m) => m.role === \"assistant\").length;\n });\n\n // Derive latest assistant message for peek\n const latestAssistantMessage = computed(() => {\n if (!omnibot.messages || omnibot.messages.length === 0) return null;\n\n for (let i = omnibot.messages.length - 1; i >= 0; i--) {\n const msg = omnibot.messages[i];\n if (msg.role === \"assistant\") {\n const content = typeof msg.content === \"string\"\n ? msg.content\n : msg.content.map((part: any) => {\n if (part.type === \"text\") return part.text;\n return \"\";\n }).join(\"\");\n\n return content;\n }\n }\n return null;\n });\n\n return {\n [NAME]: \"OmniboxFAB\",\n messages: omnibot.messages,\n [UI]: (\n <ct-fab\n expanded={computed(() => fabExpanded.get())}\n variant=\"primary\"\n position=\"bottom-right\"\n pending={omnibot.pending}\n $previewMessage={latestAssistantMessage}\n onct-fab-backdrop-click={closeFab({ fabExpanded })}\n onct-fab-escape={closeFab({ fabExpanded })}\n onClick={toggle({ value: fabExpanded })}\n >\n <div style=\"width: 100%; display: flex; flex-direction: column; max-height: 580px;\">\n {/* Chevron at top - the \"handle\" for the drawer */}\n <div style=\"border-bottom: 1px solid #e5e5e5; flex-shrink: 0;\">\n <ct-chevron-button\n expanded={computed(() => showHistory.get())}\n loading={omnibot.pending}\n onct-toggle={toggle({ value: showHistory })}\n />\n </div>\n\n <div\n style={computed(() => {\n const show = showHistory.get();\n return `flex: ${\n show ? \"1\" : \"0\"\n }; min-height: 0; display: flex; flex-direction: column; opacity: ${\n show ? \"1\" : \"0\"\n }; max-height: ${\n show ? \"480px\" : \"0\"\n }; overflow: hidden; transition: opacity 300ms ease, max-height 400ms cubic-bezier(0.34, 1.56, 0.64, 1), flex 400ms cubic-bezier(0.34, 1.56, 0.64, 1); pointer-events: ${\n show ? \"auto\" : \"none\"\n };`;\n })}\n >\n <div style=\"padding: .25rem; flex-shrink: 0;\">\n {omnibot.ui.attachmentsAndTools}\n </div>\n <div style=\"flex: 1; overflow-y: auto; min-height: 0;\">\n <ct-cell-context $cell={omnibot}>\n {omnibot.ui.chatLog}\n </ct-cell-context>\n </div>\n </div>\n\n {ifElse(\n computed(() => {\n const show = showHistory.get();\n const dismissedIdx = peekDismissedIndex.get();\n return !show && latestAssistantMessage &&\n assistantMessageCount !== dismissedIdx;\n }),\n <div style=\"margin: .5rem; margin-bottom: 0; padding: 0; flex-shrink: 0; position: relative;\">\n <ct-button\n variant=\"ghost\"\n size=\"icon\"\n onClick={dismissPeek({\n peekDismissedIndex,\n assistantMessageCount,\n })}\n style=\"position: absolute; top: 0px; right: 0px; z-index: 1; font-size: 16px;\"\n title=\"Dismiss\"\n >\n √ó\n </ct-button>\n <div\n onClick={toggle({ value: showHistory })}\n style=\"cursor: pointer;\"\n >\n <ct-cell-context $cell={latestAssistantMessage}>\n <ct-chat-message\n role=\"assistant\"\n compact\n content={latestAssistantMessage}\n pending={omnibot.pending}\n />\n </ct-cell-context>\n </div>\n </div>,\n null,\n )}\n\n {/* Prompt input - always at bottom */}\n <div style=\"padding: 0.5rem; flex-shrink: 0;\">\n {omnibot.ui.promptInput}\n </div>\n </div>\n </ct-fab>\n ),\n fabExpanded,\n };\n },\n);\n"}}}}},"of:baedreiebaipoghmik7rdpgroyn4fvz6tykutknj6i3z5ppi26meuqarsvy":{"application/json":{"ba4jcboyuitkaymz2e6doympuc7cuungcygynrzphfuddojgvehdu573l":{"is":{"value":{"name":"/chatbot-note-composed.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n cell,\n Default,\n derive,\n handler,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot.tsx\";\nimport Note from \"./note.tsx\";\nimport {\n addListItem,\n calculator,\n ListItem,\n readListItems,\n readWebpage,\n searchWeb,\n} from \"./common-tools.tsx\";\n\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\n\nfunction schemaifyWish<T>(path: string, def: T) {\n return derive(wish<T>(path), (i) => i ?? def);\n}\n\ntype ChatbotNoteInput = {\n title?: Cell<Default<string, \"LLM Test\">>;\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n};\n\ntype ChatbotNoteResult = {\n messages: Default<Array<BuiltInLLMMessage>, []>;\n chat: any;\n list: Default<ListItem[], []>;\n // Optional: expose sub-charms as mentionable targets\n mentionable?: MentionableCharm[];\n};\n\nconst newNote = handler<\n {\n /** The text content of the note */\n title: string;\n content?: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allCharms: Cell<MentionableCharm[]>; index: any }\n>(\n (args, _) => {\n try {\n const n = Note({\n title: args.title,\n content: args.content ?? \"\",\n });\n\n args.result.set(\n `Created note ${args.title}`,\n );\n\n // TODO(bf): we have to navigate here until DX1 lands\n // then we go back to pushing to allCharms\n return navigateTo(n);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst listMentionable = handler<\n {\n /** A cell to store the result text */\n result: Cell<string>;\n },\n { mentionable: MentionableCharm[] }\n>(\n (args, state) => {\n try {\n const namesList = state.mentionable.map((charm) => charm[NAME]);\n args.result.set(JSON.stringify(namesList));\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst readContentByIndex = handler<\n {\n /** A cell to store the result text */\n index: number;\n result: Cell<string>;\n },\n { allNotes: Note[] }\n>(\n (args, state) => {\n try {\n args.result.set(\n state.allNotes[args.index]?.content || \"No content found\",\n );\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\ntype Note = MentionableCharm & { content: string };\nconst editContentByIndex = handler<\n {\n /** The index of the note to edit */\n index: number;\n /** The new text content of the note */\n body: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allNotes: Cell<Note[]> }\n>(\n (args, state) => {\n try {\n const charms = state.allNotes.get();\n if (args.index < 0 || args.index >= charms.length) {\n args.result.set(`Error: Invalid index ${args.index}`);\n return;\n }\n\n state.allNotes.key(args.index).key(\"content\").set(args.body);\n args.result.set(`Updated note at index ${args.index}!`);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst navigateToNote = handler<\n {\n /** The index of the note to navigate to */\n index: number;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allCharms: Cell<MentionableCharm[]> }\n>(\n (args, state) => {\n try {\n const charms = state.allCharms.get();\n if (args.index < 0 || args.index >= charms.length) {\n args.result.set(`Error: Invalid index ${args.index}`);\n return;\n }\n\n const targetCharm = charms[args.index];\n args.result.set(`Navigating to note: ${targetCharm[NAME]}`);\n\n return navigateTo(state.allCharms.key(args.index));\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\ntype BacklinksIndex = {\n mentionable: MentionableCharm[];\n};\n\nexport default recipe<ChatbotNoteInput, ChatbotNoteResult>(\n \"Chatbot + Note\",\n ({ title, messages }) => {\n const allCharms = schemaifyWish<MentionableCharm[]>(\"#allCharms\", []);\n const index = schemaifyWish<BacklinksIndex>(\"#default/backlinksIndex\", {\n mentionable: [],\n });\n const mentionable = schemaifyWish<MentionableCharm[]>(\n \"#mentionable\",\n [],\n );\n\n const list = cell<ListItem[]>([]);\n\n const tools = {\n searchWeb: {\n pattern: searchWeb,\n },\n readWebpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n addListItem: {\n handler: addListItem({ list }),\n },\n readListItems: {\n handler: readListItems({ list }),\n },\n listMentionable: {\n description:\n \"List all mentionable items titles (read the body with readNoteByIndex).\",\n handler: listMentionable({ mentionable }),\n },\n readContentByIndex: {\n description:\n \"Read the content of a mentionable by its index in the listMentionable() list (if possible)\",\n handler: readContentByIndex({\n allNotes: mentionable as unknown as OpaqueRef<Note[]>,\n }),\n },\n editContentByIndex: {\n description:\n \"Edit the content of a mentionable by its index in the listMentionable() list (if possible)\",\n handler: editContentByIndex({\n allNotes: mentionable as unknown as OpaqueRef<Note[]>,\n }),\n },\n navigateToNote: {\n description:\n \"Navigate to a mentionable by its index in the listMentionable() list.\",\n handler: navigateToNote({\n allCharms: allCharms as unknown as OpaqueRef<MentionableCharm[]>,\n }),\n },\n newNote: {\n description: \"Create a new note instance\",\n handler: newNote({\n allCharms: allCharms as unknown as OpaqueRef<MentionableCharm[]>,\n index: index as unknown as OpaqueRef<any>,\n }),\n },\n };\n\n const chat = Chat({ messages, tools });\n\n return {\n [NAME]: title,\n chat,\n messages,\n list,\n // Expose sub-charms as mentionable targets\n mentionable: [chat as unknown as MentionableCharm],\n };\n },\n);\n"}}}}},"of:baedreidv65y2ckzqj5m6j2enkxeor5ywizljplzl5qhnkgqem6frf5s6m4":{"application/json":{"ba4jcbxzhlqhvdp4wbaclhf3dadwdrhhgj3ru5n6mgc6uivlfve4ry7zb":{"is":{"value":{"name":"/common-tools.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMTool,\n Cell,\n compileAndRun,\n computed,\n derive,\n fetchData,\n fetchProgram,\n handler,\n ifElse,\n navigateTo,\n recipe,\n} from \"commontools\";\n\n///// COMMON TOOLS (get it?) ////\n\n/**\n * Calculate the result of a mathematical expression.\n * Supports +, -, *, /, and parentheses.\n */\ntype CalculatorRequest = {\n /** The mathematical expression to evaluate. */\n expression: string;\n /** The base to use for the calculation. */\n base?: number;\n};\n\nexport const calculator = recipe<\n CalculatorRequest,\n string | { error: string }\n>(({ expression, base }) => {\n return derive({ expression, base }, ({ expression, base }) => {\n const sanitized = expression.replace(/[^0-9+\\-*/().\\s]/g, \"\");\n let sanitizedBase = Number(base);\n if (\n Number.isNaN(sanitizedBase) || sanitizedBase < 2 || sanitizedBase > 36\n ) {\n sanitizedBase = 10;\n }\n let result;\n try {\n result = Function(\n `\"use strict\"; return Number(${sanitized}).toString(${sanitizedBase})`,\n )();\n } catch (error) {\n result = { error: (error as any)?.message || \"<error>\" };\n }\n return result;\n });\n});\n\n/** Add an item to the list. */\ntype AddListItemRequest = {\n /** The item to add to the list. */\n item: string;\n result: Cell<string>;\n};\n\n/** Read all items from the list. */\ntype ReadListItemsRequest = {\n result: Cell<string>;\n};\n\nexport type ListItem = {\n title: string;\n};\n\nexport const addListItem = handler<\n AddListItemRequest,\n { list: Cell<ListItem[]> }\n>(\n (args, state) => {\n try {\n state.list.push({ title: args.item });\n args.result.set(`${state.list.get().length} items`);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nexport const readListItems = handler<\n ReadListItemsRequest,\n { list: ListItem[] }\n>(\n (args, state) => {\n try {\n const items = state.list;\n if (items.length === 0) {\n args.result.set(\"The list is empty\");\n } else {\n const itemList = items.map((item, index) =>\n `${index + 1}. ${item.title}`\n ).join(\"\\n\");\n args.result.set(`List items (${items.length} total):\\n${itemList}`);\n }\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\n/** Search the web for information. */\ntype SearchQuery = {\n /** The query to search the web for. */\n query: string;\n};\n\ntype SearchWebResult = {\n results: {\n title: string;\n url: string;\n description: string;\n }[];\n};\n\nexport const searchWeb = recipe<\n SearchQuery,\n SearchWebResult | { error: string }\n>(({ query }) => {\n const { result, error } = fetchData<SearchWebResult>({\n url: \"/api/agent-tools/web-search\",\n mode: \"json\",\n options: {\n method: \"POST\",\n headers: {\n \"Content-Type\": \"application/json\",\n },\n body: {\n query,\n max_results: 5,\n },\n },\n });\n\n // TODO(seefeld): Should we instead return { result, error }? Or allocate a\n // special [ERROR] for errors? Ideally this isn't specific to using recipes as\n // tools but a general pattern.\n return ifElse(error, { error }, result);\n});\n\n/** Read and extract content from a specific webpage URL. */\ntype ReadWebRequest = {\n /** The URL of the webpage to read and extract content from. */\n url: string;\n};\n\ntype ReadWebResult = {\n content: string;\n metadata: {\n title?: string;\n author?: string;\n date?: string;\n word_count: number;\n };\n};\n\nexport const readWebpage = recipe<\n ReadWebRequest,\n ReadWebResult | { error: string }\n>(({ url }) => {\n const { result, error } = fetchData<ReadWebResult>({\n url: \"/api/agent-tools/web-read\",\n mode: \"json\",\n options: {\n method: \"POST\",\n headers: {\n \"Content-Type\": \"application/json\",\n },\n body: {\n url,\n max_tokens: 4000,\n include_code: true,\n },\n },\n });\n\n return ifElse(error, { error }, result);\n});\n\ntype ToolsInput = {\n list: ListItem[];\n};\n\nexport default recipe<ToolsInput>(({ list }) => {\n const tools: Record<string, BuiltInLLMTool> = {\n search_web: {\n pattern: searchWeb,\n },\n read_webpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n addListItem: {\n handler: addListItem({ list }),\n },\n };\n\n return { tools, list };\n});\n\n/**\n * `fetchAndRunPattern({ url: \"https://...\", args: {} })`\n *\n * Instantiates patterns (e.g. from listPatternIndex) and returns the cell that\n * contains the results. The instantiated pattern will keep running and updating\n * the cell. Pass the resulting cell to `navigateTo` to show the pattern's UI.\n *\n * Pass in arguments to initialize the pattern. It's especially useful to pass\n * in links to other cells as `{ \"@link\": \"/of:bafe.../path/to/data\" }`.\n */\ntype FetchAndRunPatternInput = {\n url: string;\n args: Cell<any>;\n};\nexport const fetchAndRunPattern = recipe<FetchAndRunPatternInput>(\n ({ url, args }) => {\n const { pending: _fetchPending, result: program, error: _fetchError } =\n fetchProgram({ url });\n\n // Use derive to safely handle when program is undefined/pending\n const compileParams = derive(program, (p) => ({\n files: p?.files ?? [],\n main: p?.main ?? \"\",\n input: args,\n }));\n\n const { pending, result, error } = compileAndRun(compileParams);\n\n return ifElse(\n computed(() => pending || (!result && !error)),\n undefined,\n {\n cell: result,\n error,\n },\n );\n },\n);\n\n/**\n * `navigateTo({ cell: { \"@link\": \"/of:xyz\" } })` - Navigates to that cell's UI\n *\n * Especially useful after instantiating a pattern with fetchAndRunPattern:\n * Pass the \"@link\" you get at `cell` to navigate to the pattern's view.\n */\ntype NavigateToPatternInput = { cell: Cell<any> }; // Hack to steer LLM\nexport const navigateToPattern = recipe<NavigateToPatternInput>(\n ({ cell }) => {\n const success = navigateTo(cell);\n\n return ifElse(success, { success }, undefined);\n },\n);\n\n/**\n * `listPatternIndex()` - Returns the index of patterns.\n *\n * Useful as input to fetchAndRun.\n */\ntype ListPatternIndexInput = Record<string, never>;\n\nexport const listPatternIndex = recipe<ListPatternIndexInput>(\n ({ _ }) => {\n const { pending, result } = fetchData({\n url: \"/api/patterns/index.md\",\n mode: \"text\",\n });\n return ifElse(computed(() => pending || !result), undefined, { result });\n },\n);\n"}}}}}}},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcbbe2vxsag3ddiszdwbwusvmry45vxsway54iprrf2nhvbedakbel":{}},"signature":{"/":{"bytes":"SAigUKvySdqc/TQ7ABMt88zpFoJi5/qm1QDNT6MBwqPPx+mqnFWkRSZO4sPVQtUUgp6BVUSfnDtYZxrzKyB3Cw"}}}}	61970	
16:19:04.877
{"invocation":{"cmd":"/memory/transact","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"changes":{"of:baedreiekywlhi6tvmqi2jrcfq4jp3ruua5wttrti2x6lpdwjkqgjvbtxxy":{"application/json":{"ba4jcbzl4sangytinfrabwo5434wtrrwbvw5tqjk457j7mqmcpiieewy5":{"is":{"value":{"id":"ba4jcbvdr4rwr7kcj7zi2x5vus6pknr5qoy2fuxsvrpfiixdcvms4idvp","program":{"main":"/chatbot.tsx","mainExport":"TitleGenerator","files":[{"/":{"link@1":{"path":[],"id":"of:baedreihr5o4kcdziujw7ym3xumdkt2drpkowjf4iiw6cm7kpuosf7hozoe"}}},{"/":{"link@1":{"path":[],"id":"of:baedreihbn6cikeffzr7puiouswzsrw5whxidv5jostmshbjmfdf2n3x7ay"}}},{"/":{"link@1":{"path":[],"id":"of:baedreihuhsa2cz7anhp74gn6jd6iq3kfyzp7uta7ezv2c6bmvmcwp3ue3y"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiah2s3kdgrxh2i77eeevoz6rknydeto3ntzgrzbz3nvuyswi6d62m"}}},{"/":{"link@1":{"path":[],"id":"of:baedreiazdhfqkzdugzbf7jchfkrq7dytf3ra7thui55fguttkbj4i6xxfq"}}},{"/":{"link@1":{"path":[],"id":"of:baedreifgxfcvhrbghbqn2kdbd74mj5ubmh6eldd4gffjkhxdwtxiflz5gq"}}},{"/":{"link@1":{"path":[],"id":"of:baedreifbqgbd2k623ykkusp5mqeoikhndwqifhjiloawthv3bwn3ywllqe"}}},{"/":{"link@1":{"path":[],"id":"of:baedreia5wxeg3rebnb7uxjtlg3liw6bp2h4ieyxtylobfm4qzi6tpezepu"}}},{"/":{"link@1":{"path":[],"id":"of:baedreihgqkymxkzwei3njgwyu3zirsmtnhz25zyylksj7crb23ta3hobwe"}}}]}}}}}},"of:baedreihr5o4kcdziujw7ym3xumdkt2drpkowjf4iiw6cm7kpuosf7hozoe":{"application/json":{"ba4jcaqipecrur55tz2atb7ytqvtpcbzll6mrgw7vukngxjh7o7ko4vxg":{"is":{"value":{"name":"/default-app.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n handler,\n NAME,\n navigateTo,\n recipe,\n str,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chatbot from \"./chatbot.tsx\";\nimport ChatbotOutliner from \"./chatbot-outliner.tsx\";\nimport { default as Note } from \"./note.tsx\";\nimport BacklinksIndex, { type MentionableCharm } from \"./backlinks-index.tsx\";\nimport ChatList from \"./chatbot-list-view.tsx\";\nimport OmniboxFAB from \"./omnibox-fab.tsx\";\n\ntype MinimalCharm = {\n [NAME]?: string;\n};\n\ntype CharmsListInput = void;\n\n// Recipe returns only UI, no data outputs (only symbol properties)\ninterface CharmsListOutput {\n [key: string]: unknown;\n backlinksIndex: {\n mentionable: MentionableCharm[];\n };\n sidebarUI: unknown;\n fabUI: unknown;\n}\n\nconst _visit = handler<\n Record<string, never>,\n { charm: Cell<MinimalCharm> }\n>((_, state) => {\n return navigateTo(state.charm);\n}, { proxy: true });\n\nconst removeCharm = handler<\n Record<string, never>,\n {\n charm: Cell<MinimalCharm>;\n allCharms: Cell<MinimalCharm[]>;\n }\n>((_, state) => {\n const allCharmsValue = state.allCharms.get();\n const index = allCharmsValue.findIndex((c: any) => state.charm.equals(c));\n\n if (index !== -1) {\n const charmListCopy = [...allCharmsValue];\n console.log(\"charmListCopy before\", charmListCopy.length);\n charmListCopy.splice(index, 1);\n console.log(\"charmListCopy after\", charmListCopy.length);\n state.allCharms.set(charmListCopy);\n }\n});\n\nconst toggleFab = handler<any, { fabExpanded: Cell<boolean> }>(\n (_, { fabExpanded }) => {\n fabExpanded.set(!fabExpanded.get());\n },\n);\n\nconst spawnChatList = handler<void, void>((_, __) => {\n return navigateTo(ChatList({\n selectedCharm: { charm: undefined },\n charmsList: [],\n }));\n});\n\nconst spawnChatbot = handler<void, void>((_, __) => {\n return navigateTo(Chatbot({\n messages: [],\n tools: undefined,\n }));\n});\n\nconst spawnChatbotOutliner = handler<void, void>((_, __) => {\n return navigateTo(ChatbotOutliner({\n title: \"Chatbot Outliner\",\n expandChat: false,\n messages: [],\n outline: {\n root: { body: \"\", children: [], attachments: [] },\n },\n }));\n});\n\nconst spawnNote = handler<void, void>((_, __) => {\n return navigateTo(Note({\n title: \"New Note\",\n content: \"\",\n }));\n});\n\nexport default recipe<CharmsListInput, CharmsListOutput>(\n \"DefaultCharmList\",\n (_) => {\n const { allCharms } = wish<{ allCharms: MentionableCharm[] }>(\"/\");\n const index = BacklinksIndex({ allCharms });\n\n const fab = OmniboxFAB({\n mentionable: index.mentionable as unknown as Cell<MentionableCharm[]>,\n });\n\n return {\n backlinksIndex: index,\n [NAME]: str`DefaultCharmList (${allCharms.length})`,\n [UI]: (\n <ct-screen>\n <ct-keybind\n code=\"KeyN\"\n alt\n preventDefault\n onct-keybind={spawnChatList()}\n />\n <ct-keybind\n code=\"KeyO\"\n meta\n preventDefault\n onct-keybind={toggleFab({ fabExpanded: fab.fabExpanded })}\n />\n <ct-keybind\n code=\"KeyO\"\n ctrl\n preventDefault\n onct-keybind={toggleFab({ fabExpanded: fab.fabExpanded })}\n />\n\n <ct-toolbar slot=\"header\" sticky>\n <div slot=\"start\">\n <ct-button\n onClick={spawnChatList()}\n >\n üìÇ Chat List\n </ct-button>\n <ct-button\n onClick={spawnChatbot()}\n >\n üí¨ Chatbot\n </ct-button>\n <ct-button\n onClick={spawnChatbotOutliner()}\n >\n üìù Chatbot Outliner\n </ct-button>\n <ct-button\n onClick={spawnNote()}\n >\n üìÑ Note\n </ct-button>\n </div>\n </ct-toolbar>\n\n <ct-vscroll flex showScrollbar>\n <ct-vstack gap=\"4\" padding=\"6\">\n <style>\n {`\n .pattern-link {\n cursor: pointer;\n color: inherit;\n text-decoration: none;\n }\n .pattern-link:hover {\n text-decoration: underline;\n }\n `}\n </style>\n <h2>Pages</h2>\n\n <ct-table full-width hover>\n <tbody>\n {allCharms.map((charm) => (\n <tr>\n <td>\n <ct-cell-context $cell={charm}>\n <ct-cell-link $cell={charm} />\n </ct-cell-context>\n </td>\n <td>\n <ct-button\n size=\"sm\"\n variant=\"ghost\"\n onClick={removeCharm({ charm, allCharms })}\n >\n üóëÔ∏è\n </ct-button>\n </td>\n </tr>\n ))}\n </tbody>\n </ct-table>\n </ct-vstack>\n </ct-vscroll>\n </ct-screen>\n ),\n sidebarUI: undefined,\n fabUI: fab[UI],\n };\n },\n);\n"}}}}},"of:baedreihbn6cikeffzr7puiouswzsrw5whxidv5jostmshbjmfdf2n3x7ay":{"application/json":{"ba4jcaudc37ams6scfdsmg5hzuknsfbbjmwaag4ctg2nne5gaakgve3ol":{"is":{"value":{"name":"/chatbot.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n computed,\n Default,\n fetchData,\n generateObject,\n handler,\n llmDialog,\n NAME,\n pattern,\n patternTool,\n Stream,\n UI,\n VNode,\n wish,\n} from \"commontools\";\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\n\nfunction schemaifyWish<T>(path: string) {\n return wish<T>(path);\n}\n\nconst sendMessage = handler<\n {\n detail: {\n text: string;\n attachments: Array<PromptAttachment>;\n mentions: Array<any>;\n message: string; // Backward compatibility\n };\n },\n {\n addMessage: Stream<BuiltInLLMMessage>;\n }\n>((event, { addMessage }) => {\n const { text } = event.detail;\n\n // Send the message as-is. Any markdown links like [name](/of:...)\n // are just text that the LLM can parse and use with addAttachment() tool.\n addMessage.send({\n role: \"user\",\n content: [{ type: \"text\" as const, text }],\n });\n});\n\nconst clearChat = handler(\n (\n _: never,\n { messages, pending }: {\n messages: Cell<Array<BuiltInLLMMessage>>;\n pending: Cell<boolean | undefined>;\n },\n ) => {\n messages.set([]);\n pending.set(false);\n },\n);\n\ntype ChatInput = {\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n tools?: any;\n theme?: any;\n system?: string;\n};\n\ntype PromptAttachment = {\n id: string;\n name: string;\n type: \"file\" | \"clipboard\" | \"mention\";\n data?: any; // File | Blob | string\n charm?: any;\n removable?: boolean; // Whether this attachment can be removed\n};\n\ntype ChatOutput = {\n messages: Array<BuiltInLLMMessage>;\n pending: boolean | undefined;\n addMessage: Stream<BuiltInLLMMessage>;\n clearChat: Stream<void>;\n cancelGeneration: Stream<void>;\n title?: string;\n pinnedCells: Array<PromptAttachment>;\n tools: any;\n ui: {\n chatLog: VNode;\n promptInput: VNode;\n attachmentsAndTools: VNode;\n };\n};\n\nexport const TitleGenerator = pattern<\n { model?: string; messages: Array<BuiltInLLMMessage> }\n>(({ model, messages }) => {\n const previewMessage = computed(() => {\n if (!messages || messages.length === 0) return \"\";\n\n const firstMessage = messages[0];\n\n if (!firstMessage) return \"\";\n\n return JSON.stringify(firstMessage);\n });\n\n const { result } = generateObject({\n system:\n \"Generate at most a 3-word title based on the following content, respond with NOTHING but the literal title text.\",\n prompt: previewMessage,\n model,\n schema: {\n type: \"object\",\n properties: {\n title: {\n type: \"string\",\n description: \"The title of the chat\",\n },\n },\n required: [\"title\"],\n },\n });\n\n const title = computed(() => {\n return result?.title || \"Untitled Chat\";\n });\n\n return title;\n});\n\nconst listMentionable = pattern<\n { mentionable: Array<MentionableCharm> },\n { result: Array<{ label: string; cell: Cell<unknown> }> }\n>(\n ({ mentionable }) => {\n const result = mentionable.map((charm) => ({\n label: charm[NAME]!,\n cell: charm,\n }));\n return { result };\n },\n);\n\nconst listRecent = pattern<\n { recentCharms: Array<MentionableCharm> },\n { result: Array<{ label: string; cell: Cell<unknown> }> }\n>(\n ({ recentCharms }) => {\n const namesList = recentCharms.map((charm) => ({\n label: charm[NAME]!,\n cell: charm,\n }));\n return { result: namesList };\n },\n);\n\nexport default pattern<ChatInput, ChatOutput>(\n ({ messages, tools, theme, system }) => {\n const model = Cell.of<string>(\"anthropic:claude-sonnet-4-5\");\n const mentionable = schemaifyWish<MentionableCharm[]>(\"#mentionable\");\n const recentCharms = schemaifyWish<MentionableCharm[]>(\"#recent\");\n\n const assistantTools = {\n listMentionable: patternTool(listMentionable, { mentionable }),\n listRecent: patternTool(listRecent, { recentCharms }),\n };\n\n // Merge static and assistant tools\n const mergedTools = computed(() => ({\n ...tools,\n ...assistantTools,\n }));\n\n const latest = computed(() => recentCharms[0]);\n const latestName = computed(() => recentCharms[0]?.[NAME]);\n\n const {\n addMessage,\n cancelGeneration,\n pending,\n flattenedTools,\n pinnedCells,\n } = llmDialog(\n {\n system: computed(() => {\n return system ?? \"You are a polite but efficient assistant.\";\n }),\n messages,\n tools: mergedTools,\n model,\n context: computed(() => ({\n [latestName]: latest,\n })),\n },\n );\n\n const { result } = fetchData({\n url: \"/api/ai/llm/models\",\n mode: \"json\",\n });\n\n const items = computed(() => {\n if (!result) return [];\n const items = Object.keys(result as any).map((key) => ({\n label: key,\n value: key,\n }));\n return items;\n });\n\n const title = TitleGenerator({ model, messages });\n\n const promptInput = (\n <ct-prompt-input\n slot=\"footer\"\n placeholder=\"Ask the LLM a question...\"\n pending={pending}\n $mentionable={mentionable}\n modelItems={items}\n $model={model}\n onct-send={sendMessage({ addMessage })}\n onct-stop={cancelGeneration}\n />\n );\n\n const chatLog = (\n <ct-vscroll\n style=\"padding: 1rem;\"\n flex\n showScrollbar\n fadeEdges\n snapToBottom\n >\n <ct-chat\n theme={theme}\n $messages={messages}\n pending={pending}\n tools={flattenedTools}\n />\n </ct-vscroll>\n );\n\n const attachmentsAndTools = (\n <ct-hstack align=\"center\" gap=\"1\">\n <ct-cell-context $cell={pinnedCells}>\n <ct-attachments-bar pinnedCells={pinnedCells} />\n </ct-cell-context>\n <ct-tools-chip tools={flattenedTools} />\n <ct-button\n variant=\"pill\"\n type=\"button\"\n title=\"Clear chat\"\n onClick={clearChat({\n messages,\n pending,\n })}\n >\n Clear\n </ct-button>\n </ct-hstack>\n );\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <ct-vstack slot=\"header\">\n <ct-heading level={4}>{title}</ct-heading>\n {attachmentsAndTools}\n </ct-vstack>\n\n {chatLog}\n\n {promptInput}\n </ct-screen>\n ),\n messages,\n pending,\n addMessage,\n clearChat: clearChat({\n messages,\n pending,\n }),\n cancelGeneration,\n title,\n pinnedCells,\n tools: flattenedTools,\n ui: {\n chatLog,\n promptInput,\n attachmentsAndTools,\n },\n };\n },\n);\n"}}}}},"of:baedreihuhsa2cz7anhp74gn6jd6iq3kfyzp7uta7ezv2c6bmvmcwp3ue3y":{"application/json":{"ba4jcabct4nekqo7omshdwvtypdafotjzppjhzypee3goyhuetfsxiaie":{"is":{"value":{"name":"/chatbot-outliner.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n Default,\n derive,\n handler,\n ifElse,\n JSONSchema,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot.tsx\";\nimport { MentionableCharm } from \"./backlinks-index.tsx\";\n\ntype Charm = any;\n\ntype OutlinerNode = {\n body: Default<string, \"\">;\n children: Default<OutlinerNode[], []>;\n attachments: Default<OpaqueRef<any>[], []>;\n};\n\ntype Outliner = {\n root: OutlinerNode;\n};\n\ntype PageResult = {\n outline: Default<\n Outliner,\n { root: { body: \"\"; children: []; attachments: [] } }\n >;\n};\n\nexport type PageInput = {\n outline: Outliner;\n};\n\nconst handleCharmLinkClick = handler<\n {\n detail: {\n charm: Cell<Charm>;\n };\n },\n Record<string, never>\n>(({ detail }, _) => {\n return navigateTo(detail.charm);\n});\n\nfunction getMentionable() {\n return derive<MentionableCharm[], MentionableCharm[]>(\n wish<MentionableCharm[]>(\"#mentionable\"),\n (i) => i,\n );\n}\n\nexport const Page = recipe<PageInput>(\n \"Page\",\n ({ outline }) => {\n const mentionable = getMentionable();\n\n return {\n [NAME]: \"Page\",\n [UI]: (\n <ct-outliner\n $value={outline as any}\n $mentionable={mentionable}\n oncharm-link-click={handleCharmLinkClick({})}\n />\n ),\n outline,\n };\n },\n);\n\ntype LLMTestInput = {\n title?: Cell<Default<string, \"LLM Test\">>;\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n expandChat?: Cell<Default<boolean, false>>;\n outline?: Default<\n Outliner,\n { root: { body: \"Untitled Page\"; children: []; attachments: [] } }\n >;\n};\n\ntype LLMTestResult = {\n messages: Default<Array<BuiltInLLMMessage>, []>;\n};\n\n// put a node at the end of the outline (by appending to root.children)\nconst appendOutlinerNode = handler<\n {\n /** The text content/title of the outliner node to be appended */\n body: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { outline: Cell<Outliner> }\n>(\n (args, state) => {\n try {\n (state.outline.key(\"root\").key(\"children\")).push({\n body: args.body,\n children: [],\n attachments: [],\n });\n\n args.result.set(\n `${state.outline.key(\"root\").key(\"children\").get().length} nodes`,\n );\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nexport default recipe<LLMTestInput, LLMTestResult>(\n \"Outliner\",\n ({ title, expandChat, messages, outline }) => {\n const tools = {\n appendOutlinerNode: {\n description: \"Add a new outliner node.\",\n inputSchema: {\n type: \"object\",\n properties: {\n body: {\n type: \"string\",\n description: \"The title of the new node.\",\n },\n },\n required: [\"body\"],\n } as JSONSchema,\n handler: appendOutlinerNode({ outline }),\n },\n };\n\n const chat = Chat({ messages, tools });\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <ct-hstack justify=\"between\" slot=\"header\">\n <div></div>\n <div>\n <ct-checkbox $checked={expandChat}>Show Chat</ct-checkbox>\n </div>\n </ct-hstack>\n\n <ct-autolayout tabNames={[\"Chat\", \"Tools\"]}>\n <ct-screen>\n <div slot=\"header\">\n <ct-input\n $value={title}\n placeholder=\"Enter title...\"\n />\n </div>\n\n <ct-vscroll flex showScrollbar fadeEdges snapToBottom>\n <ct-vstack data-label=\"Tools\">\n <Page outline={outline} />\n </ct-vstack>\n </ct-vscroll>\n </ct-screen>\n\n {ifElse(\n expandChat,\n chat,\n null,\n )}\n </ct-autolayout>\n </ct-screen>\n ),\n messages,\n };\n },\n);\n"}}}}},"of:baedreiah2s3kdgrxh2i77eeevoz6rknydeto3ntzgrzbz3nvuyswi6d62m":{"application/json":{"ba4jcakpmhwgank7qkwkgj2jpn4owe5hibohxkew43p6g276muvetb55r":{"is":{"value":{"name":"/note.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n cell,\n type Default,\n derive,\n generateText,\n handler,\n NAME,\n navigateTo,\n patternTool,\n recipe,\n str,\n Stream,\n UI,\n wish,\n} from \"commontools\";\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\ntype Input = {\n title?: Cell<Default<string, \"Untitled Note\">>;\n content?: Cell<Default<string, \"\">>;\n};\n\n/** Represents a small #note a user took to remember some text. */\ntype Output = {\n mentioned: Default<Array<MentionableCharm>, []>;\n backlinks: MentionableCharm[];\n\n content: Default<string, \"\">;\n grep: Stream<{ query: string }>;\n translate: Stream<{ language: string }>;\n editContent: Stream<{ detail: { value: string } }>;\n};\n\nconst _updateTitle = handler<\n { detail: { value: string } },\n { title: Cell<string> }\n>(\n (event, state) => {\n state.title.set(event.detail?.value ?? \"\");\n },\n);\n\nconst _updateContent = handler<\n { detail: { value: string } },\n { content: Cell<string> }\n>(\n (event, state) => {\n state.content.set(event.detail?.value ?? \"\");\n },\n);\n\nconst handleCharmLinkClick = handler<\n {\n detail: {\n charm: Cell<MentionableCharm>;\n };\n },\n Record<string, never>\n>(({ detail }, _) => {\n return navigateTo(detail.charm);\n});\n\nconst handleNewBacklink = handler<\n {\n detail: {\n text: string;\n charmId: any;\n charm: Cell<MentionableCharm>;\n navigate: boolean;\n };\n },\n {\n mentionable: Cell<MentionableCharm[]>;\n }\n>(({ detail }, { mentionable }) => {\n console.log(\"new charm\", detail.text, detail.charmId);\n\n if (detail.navigate) {\n return navigateTo(detail.charm);\n } else {\n mentionable.push(detail.charm as unknown as MentionableCharm);\n }\n});\n\n/** This edits the content */\nconst handleEditContent = handler<\n { detail: { value: string }; result?: Cell<string> },\n { content: Cell<string> }\n>(\n ({ detail, result }, { content }) => {\n content.set(detail.value);\n result?.set(\"test!\");\n },\n);\n\nconst handleCharmLinkClicked = handler<void, { charm: Cell<MentionableCharm> }>(\n (_, { charm }) => {\n return navigateTo(charm);\n },\n);\n\nfunction schemaifyWish<T>(path: string, def: T) {\n return derive(wish<T>(path) as T, (i) => i ?? def);\n}\n\nconst Note = recipe<Input, Output>(\n \"Note\",\n ({ title, content }) => {\n const mentionable = schemaifyWish<MentionableCharm[]>(\n \"#mentionable\",\n [],\n );\n const mentioned = cell<MentionableCharm[]>([]);\n\n // populated in backlinks-index.tsx\n const backlinks = cell<MentionableCharm[]>([]);\n\n // The only way to serialize a pattern, apparently?\n const pattern = derive(undefined, () => JSON.stringify(Note));\n\n return {\n [NAME]: title,\n [UI]: (\n <ct-screen>\n <div slot=\"header\">\n <ct-input\n $value={title}\n placeholder=\"Enter title...\"\n />\n </div>\n\n <ct-code-editor\n $value={content}\n $mentionable={mentionable}\n $mentioned={mentioned}\n $pattern={pattern}\n onbacklink-click={handleCharmLinkClick({})}\n onbacklink-create={handleNewBacklink({ mentionable })}\n language=\"text/markdown\"\n theme=\"light\"\n wordWrap\n tabIndent\n lineNumbers\n />\n\n <ct-hstack slot=\"footer\">\n {backlinks?.map((charm) => (\n <ct-button\n onClick={handleCharmLinkClicked({ charm })}\n >\n {charm?.[NAME]}\n </ct-button>\n ))}\n </ct-hstack>\n </ct-screen>\n ),\n title,\n content,\n mentioned,\n backlinks,\n grep: patternTool(\n ({ query, content }: { query: string; content: string }) => {\n return derive({ query, content }, ({ query, content }) => {\n return content.split(\"\\n\").filter((c) => c.includes(query));\n });\n },\n { content },\n ),\n translate: patternTool(\n (\n { language, content }: {\n language: string;\n content: string;\n },\n ) => {\n const result = generateText({\n system: str`Translate the content to ${language}.`,\n prompt: str`<to_translate>${content}</to_translate>`,\n });\n\n return derive(result, ({ pending, result }) => {\n if (pending) return undefined;\n if (result == null) return \"Error occured\";\n return result;\n });\n },\n { content },\n ),\n editContent: handleEditContent({ content }),\n };\n },\n);\n\nexport default Note;\n"}}}}},"of:baedreiazdhfqkzdugzbf7jchfkrq7dytf3ra7thui55fguttkbj4i6xxfq":{"application/json":{"ba4jca3v4mait5tjgymb46suzsyrvarkrx4azb6apnfqmzqpqpg4r3ldm":{"is":{"value":{"name":"/backlinks-index.tsx","contents":"/// <cts-enable />\nimport { Cell, derive, lift, NAME, OpaqueRef, recipe, UI } from \"commontools\";\n\nexport type MentionableCharm = {\n [NAME]?: string;\n mentioned: MentionableCharm[];\n backlinks: MentionableCharm[];\n};\n\nexport type WriteableBacklinks = {\n mentioned: WriteableBacklinks[];\n backlinks: Cell<WriteableBacklinks[]>;\n};\n\ntype Input = {\n allCharms: MentionableCharm[];\n};\n\ntype Output = {\n mentionable: MentionableCharm[];\n};\n\nconst computeIndex = lift<\n { allCharms: WriteableBacklinks[] },\n void\n>(\n ({ allCharms }) => {\n const cs = allCharms ?? [];\n\n for (const c of cs) {\n c.backlinks?.set([]);\n }\n\n for (const c of cs) {\n const mentions = c.mentioned ?? [];\n for (const m of mentions) {\n m?.backlinks?.push(c);\n }\n }\n },\n);\n\n/**\n * BacklinksIndex builds a map of backlinks across all charms and exposes a\n * unified mentionable list for consumers like editors.\n *\n * Behavior:\n * - Backlinks are computed by scanning each charm's `mentioned` list and\n * mapping mention target -> list of source charms.\n * - Mentionable list is a union of:\n * - every charm in `allCharms`\n * - any items a charm exports via a `mentionable` property\n * (either an array of charms or a Cell of such an array)\n *\n * The backlinks map is keyed by a charm's `content` value (falling back to\n * its `[NAME]`). This mirrors how existing note patterns identify notes when\n * computing backlinks locally.\n */\nconst BacklinksIndex = recipe<Input, Output>(\n \"BacklinksIndex\",\n ({ allCharms }) => {\n computeIndex({\n allCharms: allCharms as unknown as OpaqueRef<WriteableBacklinks[]>,\n });\n\n // Compute mentionable list from allCharms reactively\n const mentionable = derive(allCharms, (charmList) => {\n const cs = charmList ?? [];\n const out: MentionableCharm[] = [];\n for (const c of cs) {\n out.push(c);\n const exported = (c as unknown as {\n mentionable?: MentionableCharm[] | { get?: () => MentionableCharm[] };\n }).mentionable;\n if (Array.isArray(exported)) {\n for (const m of exported) if (m) out.push(m);\n } else if (exported && typeof (exported as any).get === \"function\") {\n const arr = (exported as { get: () => MentionableCharm[] }).get() ??\n [];\n for (const m of arr) if (m) out.push(m);\n }\n }\n return out;\n });\n\n return {\n [NAME]: \"BacklinksIndex\",\n [UI]: undefined,\n mentionable,\n };\n },\n);\n\nexport default BacklinksIndex;\n"}}}}},"of:baedreifgxfcvhrbghbqn2kdbd74mj5ubmh6eldd4gffjkhxdwtxiflz5gq":{"application/json":{"ba4jcamslgggauyge4bdcq5agcigdbausdxtdwfyqkx6iooe2fhkpytmw":{"is":{"value":{"name":"/chatbot-list-view.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n Default,\n derive,\n handler,\n ID,\n ifElse,\n lift,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n toSchema,\n UI,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot-note-composed.tsx\";\nimport { ListItem } from \"./common-tools.tsx\";\n\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\ntype CharmEntry = {\n [ID]: string; // randomId is a string\n local_id: string; // same as ID but easier to access\n charm: any;\n};\n\ntype Input = {\n selectedCharm: Default<{ charm: any }, { charm: undefined }>;\n charmsList: Default<CharmEntry[], []>;\n theme?: {\n accentColor: Cell<Default<string, \"#3b82f6\">>;\n fontFace: Cell<Default<string, \"system-ui, -apple-system, sans-serif\">>;\n borderRadius: Cell<Default<string, \"0.5rem\">>;\n };\n};\n\ntype Output = {\n selectedCharm: Default<{ charm: any }, { charm: undefined }>;\n // Expose a mentionable list aggregated from local chat entries\n // Returned as an opaque ref to an array (not a Cell), suitable for\n // upstream aggregators that read exported mentionables.\n mentionable?: MentionableCharm[];\n};\n\nconst removeChat = handler<\n unknown,\n {\n charmsList: Cell<CharmEntry[]>;\n id: string;\n selectedCharm: Cell<Default<{ charm: any }, { charm: undefined }>>;\n }\n>(\n (\n _,\n { charmsList, id, selectedCharm },\n ) => {\n const list = charmsList.get();\n const index = list.findIndex((entry) => entry.local_id === id);\n if (index === -1) return;\n\n const removed = list[index];\n const next = [...list];\n next.splice(index, 1);\n charmsList.set(next);\n\n // If we removed the currently selected charm, choose a new selection.\n const current = selectedCharm.get();\n if (current?.charm === removed.charm) {\n const replacement = next[index] ?? next[index - 1];\n if (replacement) {\n selectedCharm.set({ charm: replacement.charm });\n } else {\n selectedCharm.set({ charm: undefined as unknown as any });\n }\n }\n },\n);\n\n// this will be called whenever charm or selectedCharm changes\n// pass isInitialized to make sure we dont call this each time\n// we change selectedCharm, otherwise creates a loop\nconst storeCharm = lift(\n toSchema<{\n charm: any;\n selectedCharm: Cell<Default<{ charm: any }, { charm: undefined }>>;\n charmsList: Cell<CharmEntry[]>;\n allCharms: Cell<MentionableCharm[]>;\n theme?: {\n accentColor: Default<string, \"#3b82f6\">;\n fontFace: Default<string, \"system-ui, -apple-system, sans-serif\">;\n borderRadius: Default<string, \"0.5rem\">;\n };\n isInitialized: Cell<boolean>;\n }>(),\n undefined,\n ({ charm, selectedCharm, charmsList, isInitialized, allCharms: _ }) => { // Not including `allCharms` is a compile error...\n if (!isInitialized.get()) {\n console.log(\n \"storeCharm storing charm:\",\n charm,\n );\n selectedCharm.set({ charm });\n\n // create the chat charm with a custom name including a random suffix\n const randomId = Math.random().toString(36).substring(2, 10); // Random 8-char string\n charmsList.push({ [ID]: randomId, local_id: randomId, charm });\n\n isInitialized.set(true);\n return charm;\n } else {\n console.log(\"storeCharm: already initialized\");\n }\n return undefined;\n },\n);\n\nconst populateChatList = lift(\n toSchema<{\n charmsList: CharmEntry[];\n allCharms: Cell<any[]>;\n selectedCharm: Cell<{ charm: any }>;\n }>(),\n undefined,\n (\n { charmsList, allCharms, selectedCharm },\n ) => {\n if (charmsList.length === 0) {\n const isInitialized = Cell.of(false);\n return storeCharm({\n charm: Chat({\n title: \"New Chat\",\n messages: [],\n }),\n selectedCharm,\n charmsList,\n allCharms,\n isInitialized: isInitialized as unknown as Cell<boolean>,\n });\n }\n\n return charmsList;\n },\n);\n\nconst createChatRecipe = handler<\n unknown,\n {\n selectedCharm: Cell<{ charm: any }>;\n charmsList: Cell<CharmEntry[]>;\n allCharms: Cell<MentionableCharm[]>;\n }\n>(\n (_, { selectedCharm, charmsList, allCharms }) => {\n const isInitialized = Cell.of(false);\n\n const charm = Chat({\n title: \"New Chat\",\n messages: [],\n });\n // store the charm ref in a cell (pass isInitialized to prevent recursive calls)\n return storeCharm({\n charm,\n selectedCharm,\n charmsList: charmsList as unknown as OpaqueRef<CharmEntry[]>,\n allCharms,\n isInitialized: isInitialized as unknown as Cell<boolean>,\n });\n },\n);\n\nconst selectCharm = handler<\n unknown,\n { selectedCharm: Cell<{ charm: any }>; charm: any }\n>(\n (_, { selectedCharm, charm }) => {\n console.log(\"selectCharm: updating selectedCharm to \", charm);\n selectedCharm.set({ charm });\n return selectedCharm;\n },\n);\n\nconst logCharmsList = lift<\n { charmsList: Cell<CharmEntry[]> },\n Cell<CharmEntry[]>\n>(\n ({ charmsList }) => {\n console.log(\"logCharmsList: \", charmsList.get());\n return charmsList;\n },\n);\n\nconst _handleCharmLinkClicked = handler(\n (_: any, { charm }: { charm: Cell<MentionableCharm> }) => {\n return navigateTo(charm);\n },\n);\n\nconst _merge = lift(\n (\n { allCharms, charmsList }: { allCharms: any[]; charmsList: CharmEntry[] },\n ) => {\n return [...charmsList.map((c) => c.charm), ...allCharms];\n },\n);\n\nconst getSelectedCharm = lift<\n { entry: { charm: any | undefined } },\n {\n chat: unknown;\n list: ListItem[];\n } | undefined\n>(\n ({ entry }) => {\n return entry?.charm;\n },\n);\n\nconst getCharmName = lift(({ charm }: { charm: any }) => {\n return charm?.[NAME] || \"Unknown\";\n});\n\nconst extractLocalMentionable = lift<\n { list: CharmEntry[] },\n MentionableCharm[]\n>(({ list }) => {\n const out: MentionableCharm[] = [];\n for (const entry of list) {\n const c = entry.charm;\n out.push(c.chat);\n }\n return out;\n});\n\n// create the named cell inside the recipe body, so we do it just once\nexport default recipe<Input, Output>(\n \"Launcher\",\n ({ selectedCharm, charmsList, theme }) => {\n const allCharms = derive<MentionableCharm[], MentionableCharm[]>(\n wish<MentionableCharm[]>(\"#allCharms\"),\n (c) => c ?? [],\n );\n logCharmsList({ charmsList: charmsList as unknown as Cell<CharmEntry[]> });\n\n populateChatList({\n selectedCharm: selectedCharm as unknown as Cell<\n Pick<CharmEntry, \"charm\">\n >,\n charmsList,\n allCharms,\n });\n\n const selected = getSelectedCharm({ entry: selectedCharm });\n\n // Aggregate mentionables from the local charms list so that this\n // container exposes its child chat charms as mention targets.\n const localMentionable = extractLocalMentionable({ list: charmsList });\n\n const localTheme = theme ?? {\n accentColor: Cell.of(\"#3b82f6\"),\n fontFace: Cell.of(\"system-ui, -apple-system, sans-serif\"),\n borderRadius: Cell.of(\"0.5rem\"),\n };\n\n return {\n [NAME]: \"Launcher\",\n [UI]: (\n <ct-theme theme={localTheme as any}>\n <ct-screen>\n <div slot=\"header\">\n <ct-toolbar dense sticky>\n <div slot=\"start\">\n <ct-button\n id=\"new-chat-btn\"\n onClick={createChatRecipe({\n selectedCharm,\n charmsList,\n allCharms,\n })}\n >\n Create New Chat\n <ct-kbd>alt+N</ct-kbd>\n </ct-button>\n </div>\n </ct-toolbar>\n\n {/* Keyboard shortcuts */}\n <ct-keybind\n code=\"KeyN\"\n alt\n preventDefault\n onct-keybind={createChatRecipe({\n selectedCharm,\n charmsList,\n allCharms,\n })}\n />\n </div>\n <ct-autolayout\n leftOpen\n rightOpen={false}\n >\n {/* workaround: this seems to correctly start the sub-recipes on a refresh while directly rendering does not */}\n {/* this should be fixed after the builder-refactor (DX1) */}\n <ct-screen>\n <ct-render $cell={selected.chat} />\n </ct-screen>\n\n <aside slot=\"left\">\n <div>\n <ct-heading level={3}>Chat List</ct-heading>\n </div>\n <div role=\"list\">\n {charmsList.map((charmEntry) => (\n <ct-list-item\n onct-activate={selectCharm({\n selectedCharm,\n charm: charmEntry.charm,\n })}\n >\n <span>{getCharmName({ charm: charmEntry.charm })}</span>\n <span slot=\"meta\">{charmEntry.local_id}</span>\n <ct-button\n slot=\"actions\"\n size=\"sm\"\n title=\"Delete Chat\"\n variant=\"destructive\"\n onClick={removeChat({\n charmsList: charmsList as unknown as OpaqueRef<\n CharmEntry[]\n >,\n id: charmEntry.local_id,\n selectedCharm: selectedCharm as unknown as OpaqueRef<\n Default<{ charm: any }, { charm: undefined }>\n >,\n })}\n >\n üóëÔ∏è\n </ct-button>\n </ct-list-item>\n ))}\n </div>\n </aside>\n\n <aside slot=\"right\">\n {ifElse(\n selected,\n <>\n <ct-ct-collapsible>\n <ct-heading slot=\"trigger\" level={5} no-margin>\n List\n </ct-heading>\n <ct-list $value={selected.list} />\n </ct-ct-collapsible>\n </>,\n null,\n )}\n <ct-collapsible>\n <ct-heading slot=\"trigger\" level={5} no-margin>\n Theme\n </ct-heading>\n <ct-vstack style=\"padding: 0.5rem 0; gap: 0.5rem;\">\n <ct-vstack>\n <ct-text>Font Family</ct-text>\n <ct-select\n items={[\n {\n label: \"System\",\n value: \"system-ui, -apple-system, sans-serif\",\n },\n {\n label: \"Monospace\",\n value: \"ui-monospace, Consolas, monospace\",\n },\n {\n label: \"Serif\",\n value: \"Georgia, Times, serif\",\n },\n {\n label: \"Sans Serif\",\n value: \"Arial, Helvetica, sans-serif\",\n },\n ]}\n $value={localTheme.fontFace}\n />\n </ct-vstack>\n\n <ct-vstack>\n <ct-text>Accent Color</ct-text>\n <ct-select\n items={[\n { label: \"Blue\", value: \"#3b82f6\" },\n { label: \"Purple\", value: \"#8b5cf6\" },\n { label: \"Green\", value: \"#10b981\" },\n { label: \"Red\", value: \"#ef4444\" },\n { label: \"Orange\", value: \"#f97316\" },\n { label: \"Pink\", value: \"#ec4899\" },\n { label: \"Indigo\", value: \"#6366f1\" },\n { label: \"Teal\", value: \"#14b8a6\" },\n ]}\n $value={localTheme.accentColor}\n />\n </ct-vstack>\n\n <ct-vstack>\n <ct-text>Border Radius</ct-text>\n <ct-select\n items={[\n { label: \"None\", value: \"0px\" },\n { label: \"Small\", value: \"0.25rem\" },\n { label: \"Medium\", value: \"0.5rem\" },\n { label: \"Large\", value: \"0.75rem\" },\n { label: \"Extra Large\", value: \"1rem\" },\n { label: \"Rounded\", value: \"1.5rem\" },\n ]}\n $value={localTheme.borderRadius}\n />\n </ct-vstack>\n </ct-vstack>\n </ct-collapsible>\n </aside>\n </ct-autolayout>\n </ct-screen>\n </ct-theme>\n ),\n selectedCharm,\n charmsList,\n // Expose the aggregated mentionables for parent-level indexing.\n mentionable: localMentionable,\n };\n },\n);\n"}}}}},"of:baedreifbqgbd2k623ykkusp5mqeoikhndwqifhjiloawthv3bwn3ywllqe":{"application/json":{"ba4jcbudggupfsx37kvjpe3dboqtlbjn727nm55blalsgrhs5gnnqaqut":{"is":{"value":{"name":"/omnibox-fab.tsx","contents":"/// <cts-enable />\nimport {\n Cell,\n computed,\n handler,\n ifElse,\n NAME,\n pattern,\n patternTool,\n UI,\n} from \"commontools\";\nimport Chatbot from \"./chatbot.tsx\";\nimport {\n calculator,\n fetchAndRunPattern,\n listPatternIndex,\n navigateToPattern,\n readWebpage,\n searchWeb,\n} from \"./common-tools.tsx\";\nimport { MentionableCharm } from \"./backlinks-index.tsx\";\n\ninterface OmniboxFABInput {\n mentionable: Cell<MentionableCharm[]>;\n}\n\nconst toggle = handler<any, { value: Cell<boolean> }>((_, { value }) => {\n value.set(!value.get());\n});\n\nconst closeFab = handler<any, { fabExpanded: Cell<boolean> }>(\n (_, { fabExpanded }) => {\n fabExpanded.set(false);\n },\n);\n\nconst dismissPeek = handler<\n any,\n { peekDismissedIndex: Cell<number>; assistantMessageCount: number }\n>((_, { peekDismissedIndex, assistantMessageCount }) => {\n // Store the current assistant message count so we know which message was dismissed\n peekDismissedIndex.set(assistantMessageCount);\n});\n\nexport default pattern<OmniboxFABInput>(\n (_) => {\n const omnibot = Chatbot({\n system:\n \"You are a polite but efficient assistant. Think Star Trek computer - helpful and professional without unnecessary conversation. Let your actions speak for themselves.\\n\\nTool usage priority:\\n- For patterns: listPatternIndex first\\n- For existing pages/notes/content: listRecent or listMentionable to identify what they're referencing\\n- Attach relevant items to conversation after instantiation/retrieval if they support ongoing tasks\\n- Remove attachments when no longer relevant\\n- Search web only as last resort when nothing exists in the space\\n\\nBe matter-of-fact. Prefer action to explanation.\",\n tools: {\n searchWeb: {\n pattern: searchWeb,\n },\n readWebpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n fetchAndRunPattern: patternTool(fetchAndRunPattern),\n listPatternIndex: patternTool(listPatternIndex),\n navigateTo: patternTool(navigateToPattern),\n },\n });\n\n const fabExpanded = Cell.of(false);\n const showHistory = Cell.of(false);\n const peekDismissedIndex = Cell.of(-1); // Track which message index was dismissed\n\n // Derive assistant message count for dismiss tracking\n const assistantMessageCount = computed(() => {\n return omnibot.messages.filter((m) => m.role === \"assistant\").length;\n });\n\n // Derive latest assistant message for peek\n const latestAssistantMessage = computed(() => {\n if (!omnibot.messages || omnibot.messages.length === 0) return null;\n\n for (let i = omnibot.messages.length - 1; i >= 0; i--) {\n const msg = omnibot.messages[i];\n if (msg.role === \"assistant\") {\n const content = typeof msg.content === \"string\"\n ? msg.content\n : msg.content.map((part: any) => {\n if (part.type === \"text\") return part.text;\n return \"\";\n }).join(\"\");\n\n return content;\n }\n }\n return null;\n });\n\n return {\n [NAME]: \"OmniboxFAB\",\n messages: omnibot.messages,\n [UI]: (\n <ct-fab\n expanded={computed(() => fabExpanded.get())}\n variant=\"primary\"\n position=\"bottom-right\"\n pending={omnibot.pending}\n $previewMessage={latestAssistantMessage}\n onct-fab-backdrop-click={closeFab({ fabExpanded })}\n onct-fab-escape={closeFab({ fabExpanded })}\n onClick={toggle({ value: fabExpanded })}\n >\n <div style=\"width: 100%; display: flex; flex-direction: column; max-height: 580px;\">\n {/* Chevron at top - the \"handle\" for the drawer */}\n <div style=\"border-bottom: 1px solid #e5e5e5; flex-shrink: 0;\">\n <ct-chevron-button\n expanded={computed(() => showHistory.get())}\n loading={omnibot.pending}\n onct-toggle={toggle({ value: showHistory })}\n />\n </div>\n\n <div\n style={computed(() => {\n const show = showHistory.get();\n return `flex: ${\n show ? \"1\" : \"0\"\n }; min-height: 0; display: flex; flex-direction: column; opacity: ${\n show ? \"1\" : \"0\"\n }; max-height: ${\n show ? \"480px\" : \"0\"\n }; overflow: hidden; transition: opacity 300ms ease, max-height 400ms cubic-bezier(0.34, 1.56, 0.64, 1), flex 400ms cubic-bezier(0.34, 1.56, 0.64, 1); pointer-events: ${\n show ? \"auto\" : \"none\"\n };`;\n })}\n >\n <div style=\"padding: .25rem; flex-shrink: 0;\">\n {omnibot.ui.attachmentsAndTools}\n </div>\n <div style=\"flex: 1; overflow-y: auto; min-height: 0;\">\n <ct-cell-context $cell={omnibot}>\n {omnibot.ui.chatLog}\n </ct-cell-context>\n </div>\n </div>\n\n {ifElse(\n computed(() => {\n const show = showHistory.get();\n const dismissedIdx = peekDismissedIndex.get();\n return !show && latestAssistantMessage &&\n assistantMessageCount !== dismissedIdx;\n }),\n <div style=\"margin: .5rem; margin-bottom: 0; padding: 0; flex-shrink: 0; position: relative;\">\n <ct-button\n variant=\"ghost\"\n size=\"icon\"\n onClick={dismissPeek({\n peekDismissedIndex,\n assistantMessageCount,\n })}\n style=\"position: absolute; top: 0px; right: 0px; z-index: 1; font-size: 16px;\"\n title=\"Dismiss\"\n >\n √ó\n </ct-button>\n <div\n onClick={toggle({ value: showHistory })}\n style=\"cursor: pointer;\"\n >\n <ct-cell-context $cell={latestAssistantMessage}>\n <ct-chat-message\n role=\"assistant\"\n compact\n content={latestAssistantMessage}\n pending={omnibot.pending}\n />\n </ct-cell-context>\n </div>\n </div>,\n null,\n )}\n\n {/* Prompt input - always at bottom */}\n <div style=\"padding: 0.5rem; flex-shrink: 0;\">\n {omnibot.ui.promptInput}\n </div>\n </div>\n </ct-fab>\n ),\n fabExpanded,\n };\n },\n);\n"}}}}},"of:baedreia5wxeg3rebnb7uxjtlg3liw6bp2h4ieyxtylobfm4qzi6tpezepu":{"application/json":{"ba4jcblmdwzskvrjcxjzi26eipiqh4wxla522nqph6aeluicwcl54gtgb":{"is":{"value":{"name":"/chatbot-note-composed.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMMessage,\n Cell,\n cell,\n Default,\n derive,\n handler,\n NAME,\n navigateTo,\n OpaqueRef,\n recipe,\n wish,\n} from \"commontools\";\n\nimport Chat from \"./chatbot.tsx\";\nimport Note from \"./note.tsx\";\nimport {\n addListItem,\n calculator,\n ListItem,\n readListItems,\n readWebpage,\n searchWeb,\n} from \"./common-tools.tsx\";\n\nimport { type MentionableCharm } from \"./backlinks-index.tsx\";\n\nfunction schemaifyWish<T>(path: string, def: T) {\n return derive(wish<T>(path), (i) => i ?? def);\n}\n\ntype ChatbotNoteInput = {\n title?: Cell<Default<string, \"LLM Test\">>;\n messages?: Cell<Default<Array<BuiltInLLMMessage>, []>>;\n};\n\ntype ChatbotNoteResult = {\n messages: Default<Array<BuiltInLLMMessage>, []>;\n chat: any;\n list: Default<ListItem[], []>;\n // Optional: expose sub-charms as mentionable targets\n mentionable?: MentionableCharm[];\n};\n\nconst newNote = handler<\n {\n /** The text content of the note */\n title: string;\n content?: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allCharms: Cell<MentionableCharm[]>; index: any }\n>(\n (args, _) => {\n try {\n const n = Note({\n title: args.title,\n content: args.content ?? \"\",\n });\n\n args.result.set(\n `Created note ${args.title}`,\n );\n\n // TODO(bf): we have to navigate here until DX1 lands\n // then we go back to pushing to allCharms\n return navigateTo(n);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst listMentionable = handler<\n {\n /** A cell to store the result text */\n result: Cell<string>;\n },\n { mentionable: MentionableCharm[] }\n>(\n (args, state) => {\n try {\n const namesList = state.mentionable.map((charm) => charm[NAME]);\n args.result.set(JSON.stringify(namesList));\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst readContentByIndex = handler<\n {\n /** A cell to store the result text */\n index: number;\n result: Cell<string>;\n },\n { allNotes: Note[] }\n>(\n (args, state) => {\n try {\n args.result.set(\n state.allNotes[args.index]?.content || \"No content found\",\n );\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\ntype Note = MentionableCharm & { content: string };\nconst editContentByIndex = handler<\n {\n /** The index of the note to edit */\n index: number;\n /** The new text content of the note */\n body: string;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allNotes: Cell<Note[]> }\n>(\n (args, state) => {\n try {\n const charms = state.allNotes.get();\n if (args.index < 0 || args.index >= charms.length) {\n args.result.set(`Error: Invalid index ${args.index}`);\n return;\n }\n\n state.allNotes.key(args.index).key(\"content\").set(args.body);\n args.result.set(`Updated note at index ${args.index}!`);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nconst navigateToNote = handler<\n {\n /** The index of the note to navigate to */\n index: number;\n /** A cell to store the result message indicating success or error */\n result: Cell<string>;\n },\n { allCharms: Cell<MentionableCharm[]> }\n>(\n (args, state) => {\n try {\n const charms = state.allCharms.get();\n if (args.index < 0 || args.index >= charms.length) {\n args.result.set(`Error: Invalid index ${args.index}`);\n return;\n }\n\n const targetCharm = charms[args.index];\n args.result.set(`Navigating to note: ${targetCharm[NAME]}`);\n\n return navigateTo(state.allCharms.key(args.index));\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\ntype BacklinksIndex = {\n mentionable: MentionableCharm[];\n};\n\nexport default recipe<ChatbotNoteInput, ChatbotNoteResult>(\n \"Chatbot + Note\",\n ({ title, messages }) => {\n const allCharms = schemaifyWish<MentionableCharm[]>(\"#allCharms\", []);\n const index = schemaifyWish<BacklinksIndex>(\"#default/backlinksIndex\", {\n mentionable: [],\n });\n const mentionable = schemaifyWish<MentionableCharm[]>(\n \"#mentionable\",\n [],\n );\n\n const list = cell<ListItem[]>([]);\n\n const tools = {\n searchWeb: {\n pattern: searchWeb,\n },\n readWebpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n addListItem: {\n handler: addListItem({ list }),\n },\n readListItems: {\n handler: readListItems({ list }),\n },\n listMentionable: {\n description:\n \"List all mentionable items titles (read the body with readNoteByIndex).\",\n handler: listMentionable({ mentionable }),\n },\n readContentByIndex: {\n description:\n \"Read the content of a mentionable by its index in the listMentionable() list (if possible)\",\n handler: readContentByIndex({\n allNotes: mentionable as unknown as OpaqueRef<Note[]>,\n }),\n },\n editContentByIndex: {\n description:\n \"Edit the content of a mentionable by its index in the listMentionable() list (if possible)\",\n handler: editContentByIndex({\n allNotes: mentionable as unknown as OpaqueRef<Note[]>,\n }),\n },\n navigateToNote: {\n description:\n \"Navigate to a mentionable by its index in the listMentionable() list.\",\n handler: navigateToNote({\n allCharms: allCharms as unknown as OpaqueRef<MentionableCharm[]>,\n }),\n },\n newNote: {\n description: \"Create a new note instance\",\n handler: newNote({\n allCharms: allCharms as unknown as OpaqueRef<MentionableCharm[]>,\n index: index as unknown as OpaqueRef<any>,\n }),\n },\n };\n\n const chat = Chat({ messages, tools });\n\n return {\n [NAME]: title,\n chat,\n messages,\n list,\n // Expose sub-charms as mentionable targets\n mentionable: [chat as unknown as MentionableCharm],\n };\n },\n);\n"}}}}},"of:baedreihgqkymxkzwei3njgwyu3zirsmtnhz25zyylksj7crb23ta3hobwe":{"application/json":{"ba4jcan74za3f3lvzx4xwz47es6kn2ybd4f7cz6acpassotkymo22hduq":{"is":{"value":{"name":"/common-tools.tsx","contents":"/// <cts-enable />\nimport {\n BuiltInLLMTool,\n Cell,\n compileAndRun,\n computed,\n derive,\n fetchData,\n fetchProgram,\n handler,\n ifElse,\n navigateTo,\n recipe,\n} from \"commontools\";\n\n///// COMMON TOOLS (get it?) ////\n\n/**\n * Calculate the result of a mathematical expression.\n * Supports +, -, *, /, and parentheses.\n */\ntype CalculatorRequest = {\n /** The mathematical expression to evaluate. */\n expression: string;\n /** The base to use for the calculation. */\n base?: number;\n};\n\nexport const calculator = recipe<\n CalculatorRequest,\n string | { error: string }\n>(({ expression, base }) => {\n return derive({ expression, base }, ({ expression, base }) => {\n const sanitized = expression.replace(/[^0-9+\\-*/().\\s]/g, \"\");\n let sanitizedBase = Number(base);\n if (\n Number.isNaN(sanitizedBase) || sanitizedBase < 2 || sanitizedBase > 36\n ) {\n sanitizedBase = 10;\n }\n let result;\n try {\n result = Function(\n `\"use strict\"; return Number(${sanitized}).toString(${sanitizedBase})`,\n )();\n } catch (error) {\n result = { error: (error as any)?.message || \"<error>\" };\n }\n return result;\n });\n});\n\n/** Add an item to the list. */\ntype AddListItemRequest = {\n /** The item to add to the list. */\n item: string;\n result: Cell<string>;\n};\n\n/** Read all items from the list. */\ntype ReadListItemsRequest = {\n result: Cell<string>;\n};\n\nexport type ListItem = {\n title: string;\n};\n\nexport const addListItem = handler<\n AddListItemRequest,\n { list: Cell<ListItem[]> }\n>(\n (args, state) => {\n try {\n state.list.push({ title: args.item });\n args.result.set(`${state.list.get().length} items`);\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\nexport const readListItems = handler<\n ReadListItemsRequest,\n { list: ListItem[] }\n>(\n (args, state) => {\n try {\n const items = state.list;\n if (items.length === 0) {\n args.result.set(\"The list is empty\");\n } else {\n const itemList = items.map((item, index) =>\n `${index + 1}. ${item.title}`\n ).join(\"\\n\");\n args.result.set(`List items (${items.length} total):\\n${itemList}`);\n }\n } catch (error) {\n args.result.set(`Error: ${(error as any)?.message || \"<error>\"}`);\n }\n },\n);\n\n/** Search the web for information. */\ntype SearchQuery = {\n /** The query to search the web for. */\n query: string;\n};\n\ntype SearchWebResult = {\n results: {\n title: string;\n url: string;\n description: string;\n }[];\n};\n\nexport const searchWeb = recipe<\n SearchQuery,\n SearchWebResult | { error: string }\n>(({ query }) => {\n const { result, error } = fetchData<SearchWebResult>({\n url: \"/api/agent-tools/web-search\",\n mode: \"json\",\n options: {\n method: \"POST\",\n headers: {\n \"Content-Type\": \"application/json\",\n },\n body: {\n query,\n max_results: 5,\n },\n },\n });\n\n // TODO(seefeld): Should we instead return { result, error }? Or allocate a\n // special [ERROR] for errors? Ideally this isn't specific to using recipes as\n // tools but a general pattern.\n return ifElse(error, { error }, result);\n});\n\n/** Read and extract content from a specific webpage URL. */\ntype ReadWebRequest = {\n /** The URL of the webpage to read and extract content from. */\n url: string;\n};\n\ntype ReadWebResult = {\n content: string;\n metadata: {\n title?: string;\n author?: string;\n date?: string;\n word_count: number;\n };\n};\n\nexport const readWebpage = recipe<\n ReadWebRequest,\n ReadWebResult | { error: string }\n>(({ url }) => {\n const { result, error } = fetchData<ReadWebResult>({\n url: \"/api/agent-tools/web-read\",\n mode: \"json\",\n options: {\n method: \"POST\",\n headers: {\n \"Content-Type\": \"application/json\",\n },\n body: {\n url,\n max_tokens: 4000,\n include_code: true,\n },\n },\n });\n\n return ifElse(error, { error }, result);\n});\n\ntype ToolsInput = {\n list: ListItem[];\n};\n\nexport default recipe<ToolsInput>(({ list }) => {\n const tools: Record<string, BuiltInLLMTool> = {\n search_web: {\n pattern: searchWeb,\n },\n read_webpage: {\n pattern: readWebpage,\n },\n calculator: {\n pattern: calculator,\n },\n addListItem: {\n handler: addListItem({ list }),\n },\n };\n\n return { tools, list };\n});\n\n/**\n * `fetchAndRunPattern({ url: \"https://...\", args: {} })`\n *\n * Instantiates patterns (e.g. from listPatternIndex) and returns the cell that\n * contains the results. The instantiated pattern will keep running and updating\n * the cell. Pass the resulting cell to `navigateTo` to show the pattern's UI.\n *\n * Pass in arguments to initialize the pattern. It's especially useful to pass\n * in links to other cells as `{ \"@link\": \"/of:bafe.../path/to/data\" }`.\n */\ntype FetchAndRunPatternInput = {\n url: string;\n args: Cell<any>;\n};\nexport const fetchAndRunPattern = recipe<FetchAndRunPatternInput>(\n ({ url, args }) => {\n const { pending: _fetchPending, result: program, error: _fetchError } =\n fetchProgram({ url });\n\n // Use derive to safely handle when program is undefined/pending\n const compileParams = derive(program, (p) => ({\n files: p?.files ?? [],\n main: p?.main ?? \"\",\n input: args,\n }));\n\n const { pending, result, error } = compileAndRun(compileParams);\n\n return ifElse(\n computed(() => pending || (!result && !error)),\n undefined,\n {\n cell: result,\n error,\n },\n );\n },\n);\n\n/**\n * `navigateTo({ cell: { \"@link\": \"/of:xyz\" } })` - Navigates to that cell's UI\n *\n * Especially useful after instantiating a pattern with fetchAndRunPattern:\n * Pass the \"@link\" you get at `cell` to navigate to the pattern's view.\n */\ntype NavigateToPatternInput = { cell: Cell<any> }; // Hack to steer LLM\nexport const navigateToPattern = recipe<NavigateToPatternInput>(\n ({ cell }) => {\n const success = navigateTo(cell);\n\n return ifElse(success, { success }, undefined);\n },\n);\n\n/**\n * `listPatternIndex()` - Returns the index of patterns.\n *\n * Useful as input to fetchAndRun.\n */\ntype ListPatternIndexInput = Record<string, never>;\n\nexport const listPatternIndex = recipe<ListPatternIndexInput>(\n ({ _ }) => {\n const { pending, result } = fetchData({\n url: \"/api/patterns/index.md\",\n mode: \"text\",\n });\n return ifElse(computed(() => pending || !result), undefined, { result });\n },\n);\n"}}}}}}},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcbrdqrku7uqq7hope2qzaitpsehm7oajoiwhzfbmk46mcs7666imd":{}},"signature":{"/":{"bytes":"E1zAognbzWyhsPnaAY4RjfdYctJTaofcL0jmt7U6mxQxEz6C9Xg42YvW0hHuEAglvM4GXMgkeCaoDLoOYcYCBQ"}}}}	61977	
16:19:04.879
{"invocation":{"cmd":"/memory/transact","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"changes":{"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi":{"application/json":{"ba4jcbirzp25psvtv3foh7ltybu7htrr25rcst7e4xkxcbfl6s6dn6g73":true}},"of:baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu":{"application/json":{"ba4jcbtsn5mvkcl5jnyxp74hhnthlekpicrerg2uwrjvgsrhnuoupyopc":{"is":{"value":{"$TYPE":"ba4jcaodz2xu6wbjq3i54qb4dily77jzm6ofnrimmtbv6lcfgexob2umv","resultRef":{"/":{"link@1":{"path":[],"id":"of:baedreicw57gfkzm77cu2paqxnbyyjzyfviddbswnjixqxnfm6anx43khgi","schema":{"type":"object","properties":{"backlinksIndex":{"type":"object","properties":{"mentionable":{"$ref":"#/$defs/AnonymousType_1"}},"required":["mentionable"]},"sidebarUI":true,"fabUI":true},"additionalProperties":true,"required":["backlinksIndex","sidebarUI","fabUI"],"$defs":{"AnonymousType_1":{"type":"array","items":{"$ref":"#/$defs/MentionableCharm"}},"MentionableCharm":{"type":"object","properties":{"mentioned":{"$ref":"#/$defs/AnonymousType_1"},"backlinks":{"$ref":"#/$defs/AnonymousType_1"},"$NAME":{"type":"string"}},"required":["mentioned","backlinks"]}}},"rootSchema":{"type":"object","properties":{"backlinksIndex":{"type":"object","properties":{"mentionable":{"$ref":"#/$defs/AnonymousType_1"}},"required":["mentionable"]},"sidebarUI":true,"fabUI":true},"additionalProperties":true,"required":["backlinksIndex","sidebarUI","fabUI"],"$defs":{"AnonymousType_1":{"type":"array","items":{"$ref":"#/$defs/MentionableCharm"}},"MentionableCharm":{"type":"object","properties":{"mentioned":{"$ref":"#/$defs/AnonymousType_1"},"backlinks":{"$ref":"#/$defs/AnonymousType_1"},"$NAME":{"type":"string"}},"required":["mentioned","backlinks"]}}}}}},"internal":{"__#3stream":{"$stream":true},"__#4stream":{"$stream":true},"__#5stream":{"$stream":true},"__#6stream":{"$stream":true},"__#7stream":{"$stream":true},"__#8stream":{"$stream":true},"__#9stream":{"$stream":true},"backlinksIndex":{"/":{"link@1":{"path":[],"id":"of:baedreiew3r6xzertwztxn5gca4e7kpw4s6tkjpjhd4cqufpfabzaohr26u"}}},"__#2":{"/":{"link@1":{"path":[],"id":"of:baedreih7kptq7imqrynpbhqzvoijfygt5byc7xmvzwu73wfd54uld5xrmi"}}}},"spell":{"/":{"link@1":{"id":"of:baedreiayeohgxjzmij53y63lgaax5ndolqk5ksdwu6xscel4kx2m2s6c3q"}}},"argument":{}}}}}},"of:baedreiew3r6xzertwztxn5gca4e7kpw4s6tkjpjhd4cqufpfabzaohr26u":{"application/json":{"ba4jcahsanbjgs4njyhcrqwijc67xcm43w2he3r2jrpum2z2xomyb55fz":{"is":{"source":{"/":"baedreiezwqqfrasyiyojszbzjotpjyljq5varfcsq3q74muet4e6yclm5u"},"value":{"$NAME":"BacklinksIndex","mentionable":{"$alias":{"path":["internal","mentionable"],"cell":{"/":"baedreiezwqqfrasyiyojszbzjotpjyljq5varfcsq3q74muet4e6yclm5u"}}}}}}}},"of:baedreiezwqqfrasyiyojszbzjotpjyljq5varfcsq3q74muet4e6yclm5u":{"application/json":{"ba4jcb5urs2wmoo4s4w4h3ni7no3ii6e7mrpdu5udoaofn7q6csbv3j6g":{"is":{"value":{"$TYPE":"ba4jcbdxdxfk3tzkdxyywtnhwnmsciefb72ghxb2cinrqplaho75p5jqm","resultRef":{"/":{"link@1":{"path":[],"id":"of:baedreiew3r6xzertwztxn5gca4e7kpw4s6tkjpjhd4cqufpfabzaohr26u","schema":{"type":"object","properties":{"mentionable":{"$ref":"#/$defs/AnonymousType_1"}},"required":["mentionable"],"$defs":{"AnonymousType_1":{"type":"array","items":{"$ref":"#/$defs/MentionableCharm"}},"MentionableCharm":{"type":"object","properties":{"mentioned":{"$ref":"#/$defs/AnonymousType_1"},"backlinks":{"$ref":"#/$defs/AnonymousType_1"},"$NAME":{"type":"string"}},"required":["mentioned","backlinks"]}}},"rootSchema":{"type":"object","properties":{"mentionable":{"$ref":"#/$defs/AnonymousType_1"}},"required":["mentionable"],"$defs":{"AnonymousType_1":{"type":"array","items":{"$ref":"#/$defs/MentionableCharm"}},"MentionableCharm":{"type":"object","properties":{"mentioned":{"$ref":"#/$defs/AnonymousType_1"},"backlinks":{"$ref":"#/$defs/AnonymousType_1"},"$NAME":{"type":"string"}},"required":["mentioned","backlinks"]}}}}}},"internal":{},"spell":{"/":{"link@1":{"id":"of:baedreic2gtm7aqfvbe66bymvqwvj7pirepldufg7qqu5y5iyjywyit6f4u"}}},"argument":{"allCharms":{"$alias":{"path":["internal","__#0","allCharms"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}}}}}}},"of:baedreih7kptq7imqrynpbhqzvoijfygt5byc7xmvzwu73wfd54uld5xrmi":{"application/json":{"ba4jcbub54s4ivpgexu4bjk4pn6rzt4li557sbfgulws5skzrqdpw3xmf":{"is":{"source":{"/":"baedreihmi7ajmgufrnfez3rdpmiee6v7fhjgs5zq2cyult5atffptpbpqa"},"value":{"$NAME":"OmniboxFAB","messages":{"$alias":{"path":["internal","__#0","messages"],"cell":{"/":"baedreihmi7ajmgufrnfez3rdpmiee6v7fhjgs5zq2cyult5atffptpbpqa"}}},"$UI":{"type":"vnode","name":"ct-fab","props":{"expanded":{"$alias":{"path":["internal","__#12"],"cell":{"/":"baedreihmi7ajmgufrnfez3rdpmiee6v7fhjgs5zq2cyult5atffptpbpqa"}}},"variant":"primary","position":"bottom-right","pending":{"$alias":{"path":["internal","__#0","pending"],"cell":{"/":"baedreihmi7ajmgufrnfez3rdpmiee6v7fhjgs5zq2cyult5atffptpbpqa"}}},"$previewMessage":{"$alias":{"path":["internal","__#10"],"cell":{"/":"baedreihmi7ajmgufrnfez3rdpmiee6v7fhjgs5zq2cyult5atffptpbpqa"}}},"onct-fab-backdrop-click":{"$alias":{"path":["internal","__#13stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreihmi7ajmgufrnfez3rdpmiee6v7fhjgs5zq2cyult5atffptpbpqa"}}},"onct-fab-escape":{"$alias":{"path":["internal","__#14stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreihmi7ajmgufrnfez3rdpmiee6v7fhjgs5zq2cyult5atffptpbpqa"}}},"onClick":{"$alias":{"path":["internal","__#15stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreihmi7ajmgufrnfez3rdpmiee6v7fhjgs5zq2cyult5atffptpbpqa"}}}},"children":[{"type":"vnode","name":"div","props":{"style":"width: 100%; display: flex; flex-direction: column; max-height: 580px;"},"children":[{"type":"vnode","name":"div","props":{"style":"border-bottom: 1px solid #e5e5e5; flex-shrink: 0;"},"children":[{"type":"vnode","name":"ct-chevron-button","props":{"expanded":{"$alias":{"path":["internal","__#3"],"cell":{"/":"baedreihmi7ajmgufrnfez3rdpmiee6v7fhjgs5zq2cyult5atffptpbpqa"}}},"loading":{"$alias":{"path":["internal","__#0","pending"],"cell":{"/":"baedreihmi7ajmgufrnfez3rdpmiee6v7fhjgs5zq2cyult5atffptpbpqa"}}},"onct-toggle":{"$alias":{"path":["internal","__#4stream"],"schema":true,"rootSchema":true,"cell":{"/":"baedreihmi7ajmgufrnfez3rdpmiee6v7fhjgs5zq2cyult5atffptpbpqa"}}}},"children":[]}]},{"type":"vnode","name":"div","props":{"style":{"$alias":{"path":["internal","__#5"],"cell":{"/":"baedreihmi7ajmgufrnfez3rdpmiee6v7fhjgs5zq2cyult5atffptpbpqa"}}}},"children":[{"type":"vnode","name":"div","props":{"style":"padding: .25rem; flex-shrink: 0;"},"children":[{"$alias":{"path":["internal","__#0","ui","attachmentsAndTools"],"cell":{"/":"baedreihmi7ajmgufrnfez3rdpmiee6v7fhjgs5zq2cyult5atffptpbpqa"}}}]},{"type":"vnode","name":"div","props":{"style":"flex: 1; overflow-y: auto; min-height: 0;"},"children":[{"type":"vnode","name":"ct-cell-context","props":{"$cell":{"$alias":{"path":["internal","__#0"],"cell":{"/":"baedreihmi7ajmgufrnfez3rdpmiee6v7fhjgs5zq2cyult5atffptpbpqa"}}}},"children":[{"$alias":{"path":["internal","__#0","ui","chatLog"],"cell":{"/":"baedreihmi7ajmgufrnfez3rdpmiee6v7fhjgs5zq2cyult5atffptpbpqa"}}}]}]}]},{"$alias":{"path":["internal","__#11"],"cell":{"/":"baedreihmi7ajmgufrnfez3rdpmiee6v7fhjgs5zq2cyult5atffptpbpqa"}}},{"type":"vnode","name":"div","props":{"style":"padding: 0.5rem; flex-shrink: 0;"},"children":[{"$alias":{"path":["internal","__#0","ui","promptInput"],"cell":{"/":"baedreihmi7ajmgufrnfez3rdpmiee6v7fhjgs5zq2cyult5atffptpbpqa"}}}]}]}]},"fabExpanded":{"$alias":{"path":["internal","fabExpanded"],"schema":{"type":"boolean","default":false},"rootSchema":{"type":"boolean","default":false},"cell":{"/":"baedreihmi7ajmgufrnfez3rdpmiee6v7fhjgs5zq2cyult5atffptpbpqa"}}}}}}}},"of:baedreihmi7ajmgufrnfez3rdpmiee6v7fhjgs5zq2cyult5atffptpbpqa":{"application/json":{"ba4jcb7mwf6oaq3gthlbsia64jnq7fp4ugbva25bxdwjnb5jb4lvr6cyd":{"is":{"value":{"$TYPE":"ba4jcangkm4fwnvsvwriopn2eksgl2pw3le5z2nlgngk4rtymlnplerms","resultRef":{"/":{"link@1":{"path":[],"id":"of:baedreih7kptq7imqrynpbhqzvoijfygt5byc7xmvzwu73wfd54uld5xrmi","schema":{"type":"object","properties":{"$NAME":{"type":"string"},"messages":{"type":"array","items":{"type":"object","properties":{"role":{"enum":["system","user","assistant","tool"]},"content":{"anyOf":[{"type":"string"},{"type":"array","items":{"anyOf":[{"type":"object","properties":{"type":{"type":"string","enum":["text"]},"text":{"type":"string"}},"required":["type","text"]},{"type":"object","properties":{"type":{"type":"string","enum":["image"]},"image":{"anyOf":[{"type":"string"},true,{"type":"string","format":"uri"},true]}},"required":["type","image"]},{"type":"object","properties":{"type":{"type":"string","enum":["tool-call"]},"toolCallId":{"type":"string"},"toolName":{"type":"string"},"input":{"type":"object","properties":{},"additionalProperties":true}},"required":["type","toolCallId","toolName","input"]},{"type":"object","properties":{"type":{"type":"string","enum":["tool-result"]},"toolCallId":{"type":"string"},"toolName":{"type":"string"},"output":{"anyOf":[{"type":"object","properties":{"type":{"type":"string","enum":["text"]},"value":{"type":"string"}},"required":["type","value"]},{"type":"object","properties":{"type":{"type":"string","enum":["json"]},"value":true},"required":["type","value"]}]}},"required":["type","toolCallId","toolName","output"]}]}}]}},"required":["role","content"]},"asOpaque":true},"$UI":{"$ref":"#/$defs/Element"},"fabExpanded":{"type":"boolean"}},"required":["$NAME","messages","$UI","fabExpanded"],"$defs":{"Element":{"type":"object","properties":{"type":{"type":"string","enum":["vnode"]},"name":{"type":"string"},"props":{"$ref":"#/$defs/Props"},"children":{"$ref":"#/$defs/RenderNode"},"$UI":{"$ref":"#/$defs/VNode"}},"required":["type","name","props"]},"VNode":{"type":"object","properties":{"type":{"type":"string","enum":["vnode"]},"name":{"type":"string"},"props":{"$ref":"#/$defs/Props"},"children":{"$ref":"#/$defs/RenderNode"},"$UI":{"$ref":"#/$defs/VNode"}},"required":["type","name","props"]},"RenderNode":{"anyOf":[{"type":"string"},{"type":"number"},{"type":"boolean","enum":[false]},{"type":"boolean","enum":[true]},{"$ref":"#/$defs/VNode"},{"type":"object","properties":{}},{"type":"array","items":{"$ref":"#/$defs/RenderNode"}}]},"Props":{"type":"object","properties":{},"additionalProperties":{"anyOf":[{"type":"string"},{"type":"number"},{"type":"boolean","enum":[false]},{"type":"boolean","enum":[true]},{"type":"object","additionalProperties":true},{"type":"array","items":true},{},{},{"type":"null"}]}}}},"rootSchema":{"type":"object","properties":{"$NAME":{"type":"string"},"messages":{"type":"array","items":{"type":"object","properties":{"role":{"enum":["system","user","assistant","tool"]},"content":{"anyOf":[{"type":"string"},{"type":"array","items":{"anyOf":[{"type":"object","properties":{"type":{"type":"string","enum":["text"]},"text":{"type":"string"}},"required":["type","text"]},{"type":"object","properties":{"type":{"type":"string","enum":["image"]},"image":{"anyOf":[{"type":"string"},true,{"type":"string","format":"uri"},true]}},"required":["type","image"]},{"type":"object","properties":{"type":{"type":"string","enum":["tool-call"]},"toolCallId":{"type":"string"},"toolName":{"type":"string"},"input":{"type":"object","properties":{},"additionalProperties":true}},"required":["type","toolCallId","toolName","input"]},{"type":"object","properties":{"type":{"type":"string","enum":["tool-result"]},"toolCallId":{"type":"string"},"toolName":{"type":"string"},"output":{"anyOf":[{"type":"object","properties":{"type":{"type":"string","enum":["text"]},"value":{"type":"string"}},"required":["type","value"]},{"type":"object","properties":{"type":{"type":"string","enum":["json"]},"value":true},"required":["type","value"]}]}},"required":["type","toolCallId","toolName","output"]}]}}]}},"required":["role","content"]},"asOpaque":true},"$UI":{"$ref":"#/$defs/Element"},"fabExpanded":{"type":"boolean"}},"required":["$NAME","messages","$UI","fabExpanded"],"$defs":{"Element":{"type":"object","properties":{"type":{"type":"string","enum":["vnode"]},"name":{"type":"string"},"props":{"$ref":"#/$defs/Props"},"children":{"$ref":"#/$defs/RenderNode"},"$UI":{"$ref":"#/$defs/VNode"}},"required":["type","name","props"]},"VNode":{"type":"object","properties":{"type":{"type":"string","enum":["vnode"]},"name":{"type":"string"},"props":{"$ref":"#/$defs/Props"},"children":{"$ref":"#/$defs/RenderNode"},"$UI":{"$ref":"#/$defs/VNode"}},"required":["type","name","props"]},"RenderNode":{"anyOf":[{"type":"string"},{"type":"number"},{"type":"boolean","enum":[false]},{"type":"boolean","enum":[true]},{"$ref":"#/$defs/VNode"},{"type":"object","properties":{}},{"type":"array","items":{"$ref":"#/$defs/RenderNode"}}]},"Props":{"type":"object","properties":{},"additionalProperties":{"anyOf":[{"type":"string"},{"type":"number"},{"type":"boolean","enum":[false]},{"type":"boolean","enum":[true]},{"type":"object","additionalProperties":true},{"type":"array","items":true},{},{},{"type":"null"}]}}}}}}},"internal":{"__#2":false,"__#4stream":{"$stream":true},"__#6stream":{"$stream":true},"__#7":-1,"__#9stream":{"$stream":true},"fabExpanded":false,"__#13stream":{"$stream":true},"__#14stream":{"$stream":true},"__#15stream":{"$stream":true},"__#0":{"/":{"link@1":{"path":[],"id":"of:baedreifr3l6ptjg4p5yoxmogt6zmb4xsd32gt5gxz455de24wlheldsuii"}}}},"spell":{"/":{"link@1":{"id":"of:baedreict32xtwzbqigicopudxcssjko2bwk4zd7gesc5mmjsbdpvhmdqfm"}}},"argument":{"mentionable":{"$alias":{"path":["internal","backlinksIndex","mentionable"],"cell":{"/":"baedreievf6keesyk2g22lrcsa2kh3juccslx2zodpfe2hznxvlmonovoyu"}}}}}}}}},"of:baedreifr3l6ptjg4p5yoxmogt6zmb4xsd32gt5gxz455de24wlheldsuii":{"application/json":{"ba4jcaayjziyrtjnojp7jnodkzq65adf5n4fjsau5gukkhl32wrfcscsb":{"is":{"source":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"},"value":{"$NAME":{"$alias":{"path":["internal","$NAME"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"$UI":{"type":"vnode","name":"ct-screen","props":{},"children":[{"type":"vnode","name":"ct-vstack","props":{"slot":"header"},"children":[{"type":"vnode","name":"ct-heading","props":{"level":4},"children":[{"$alias":{"path":["internal","$NAME"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}}]},{"type":"vnode","name":"ct-hstack","props":{"align":"center","gap":"1"},"children":[{"type":"vnode","name":"ct-cell-context","props":{"$cell":{"$alias":{"path":["internal","__#2","pinnedCells"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}}},"children":[{"type":"vnode","name":"ct-attachments-bar","props":{"pinnedCells":{"$alias":{"path":["internal","__#2","pinnedCells"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}}},"children":[]}]},{"type":"vnode","name":"ct-tools-chip","props":{"tools":{"$alias":{"path":["internal","__#2","flattenedTools"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}}},"children":[]},{"type":"vnode","name":"ct-button","props":{"variant":"pill","type":"button","title":"Clear chat","onClick":{"$alias":{"path":["internal","__#4stream"],"schema":false,"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}}},"children":["Clear"]}]}]},{"type":"vnode","name":"ct-vscroll","props":{"style":"padding: 1rem;","flex":true,"showScrollbar":true,"fadeEdges":true,"snapToBottom":true},"children":[{"type":"vnode","name":"ct-chat","props":{"theme":{"$alias":{"path":["argument","theme"],"schema":{},"rootSchema":{"type":"object","properties":{"messages":{"type":"array","items":{"$ref":"#/$defs/BuiltInLLMMessage"},"default":[]},"tools":true,"theme":true,"system":{"type":"string"}},"$defs":{"BuiltInLLMMessage":{"type":"object","properties":{"role":{"enum":["system","user","assistant","tool"]},"content":{"$ref":"#/$defs/BuiltInLLMContent"}},"required":["role","content"]},"BuiltInLLMContent":{"anyOf":[{"type":"string"},{"type":"array","items":{"$ref":"#/$defs/BuiltInLLMContentPart"}}]},"BuiltInLLMContentPart":{"anyOf":[{"$ref":"#/$defs/BuiltInLLMTextPart"},{"$ref":"#/$defs/BuiltInLLMImagePart"},{"$ref":"#/$defs/BuiltInLLMToolCallPart"},{"$ref":"#/$defs/BuiltInLLMToolResultPart"}]},"BuiltInLLMToolResultPart":{"type":"object","properties":{"type":{"type":"string","enum":["tool-result"]},"toolCallId":{"type":"string"},"toolName":{"type":"string"},"output":{"anyOf":[{"type":"object","properties":{"type":{"type":"string","enum":["text"]},"value":{"type":"string"}},"required":["type","value"]},{"type":"object","properties":{"type":{"type":"string","enum":["json"]},"value":true},"required":["type","value"]}]}},"required":["type","toolCallId","toolName","output"]},"BuiltInLLMToolCallPart":{"type":"object","properties":{"type":{"type":"string","enum":["tool-call"]},"toolCallId":{"type":"string"},"toolName":{"type":"string"},"input":{"type":"object","properties":{},"additionalProperties":true}},"required":["type","toolCallId","toolName","input"]},"BuiltInLLMImagePart":{"type":"object","properties":{"type":{"type":"string","enum":["image"]},"image":{"anyOf":[{"type":"string"},true,{"type":"string","format":"uri"},true]}},"required":["type","image"]},"BuiltInLLMTextPart":{"type":"object","properties":{"type":{"type":"string","enum":["text"]},"text":{"type":"string"}},"required":["type","text"]}}},"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"$messages":{"$alias":{"path":["argument","messages"],"schema":{"type":"array","items":{"$ref":"#/$defs/BuiltInLLMMessage"},"default":[]},"rootSchema":{"type":"object","properties":{"messages":{"type":"array","items":{"$ref":"#/$defs/BuiltInLLMMessage"},"default":[]},"tools":true,"theme":true,"system":{"type":"string"}},"$defs":{"BuiltInLLMMessage":{"type":"object","properties":{"role":{"enum":["system","user","assistant","tool"]},"content":{"$ref":"#/$defs/BuiltInLLMContent"}},"required":["role","content"]},"BuiltInLLMContent":{"anyOf":[{"type":"string"},{"type":"array","items":{"$ref":"#/$defs/BuiltInLLMContentPart"}}]},"BuiltInLLMContentPart":{"anyOf":[{"$ref":"#/$defs/BuiltInLLMTextPart"},{"$ref":"#/$defs/BuiltInLLMImagePart"},{"$ref":"#/$defs/BuiltInLLMToolCallPart"},{"$ref":"#/$defs/BuiltInLLMToolResultPart"}]},"BuiltInLLMToolResultPart":{"type":"object","properties":{"type":{"type":"string","enum":["tool-result"]},"toolCallId":{"type":"string"},"toolName":{"type":"string"},"output":{"anyOf":[{"type":"object","properties":{"type":{"type":"string","enum":["text"]},"value":{"type":"string"}},"required":["type","value"]},{"type":"object","properties":{"type":{"type":"string","enum":["json"]},"value":true},"required":["type","value"]}]}},"required":["type","toolCallId","toolName","output"]},"BuiltInLLMToolCallPart":{"type":"object","properties":{"type":{"type":"string","enum":["tool-call"]},"toolCallId":{"type":"string"},"toolName":{"type":"string"},"input":{"type":"object","properties":{},"additionalProperties":true}},"required":["type","toolCallId","toolName","input"]},"BuiltInLLMImagePart":{"type":"object","properties":{"type":{"type":"string","enum":["image"]},"image":{"anyOf":[{"type":"string"},true,{"type":"string","format":"uri"},true]}},"required":["type","image"]},"BuiltInLLMTextPart":{"type":"object","properties":{"type":{"type":"string","enum":["text"]},"text":{"type":"string"}},"required":["type","text"]}}},"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"pending":{"$alias":{"path":["internal","__#2","pending"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"tools":{"$alias":{"path":["internal","__#2","flattenedTools"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}}},"children":[]}]},{"type":"vnode","name":"ct-prompt-input","props":{"slot":"footer","placeholder":"Ask the LLM a question...","pending":{"$alias":{"path":["internal","__#2","pending"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"$mentionable":{"$alias":{"path":["internal","__#10"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"modelItems":{"$alias":{"path":["internal","__#11"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"$model":{"$alias":{"path":["internal","__#1"],"schema":{"type":"string","default":"anthropic:claude-sonnet-4-5"},"rootSchema":{"type":"string","default":"anthropic:claude-sonnet-4-5"},"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"onct-send":{"$alias":{"path":["internal","__#3stream"],"schema":{"type":"object","properties":{"detail":{"type":"object","properties":{"text":{"type":"string"},"attachments":{"type":"array","items":{"$ref":"#/$defs/PromptAttachment"}},"mentions":{"type":"array","items":true},"message":{"type":"string"}},"required":["text","attachments","mentions","message"]}},"required":["detail"],"$defs":{"PromptAttachment":{"type":"object","properties":{"id":{"type":"string"},"name":{"type":"string"},"type":{"enum":["file","clipboard","mention"]},"data":true,"charm":true,"removable":{"type":"boolean"}},"required":["id","name","type"]}}},"rootSchema":{"type":"object","properties":{"detail":{"type":"object","properties":{"text":{"type":"string"},"attachments":{"type":"array","items":{"$ref":"#/$defs/PromptAttachment"}},"mentions":{"type":"array","items":true},"message":{"type":"string"}},"required":["text","attachments","mentions","message"]}},"required":["detail"],"$defs":{"PromptAttachment":{"type":"object","properties":{"id":{"type":"string"},"name":{"type":"string"},"type":{"enum":["file","clipboard","mention"]},"data":true,"charm":true,"removable":{"type":"boolean"}},"required":["id","name","type"]}}},"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"onct-stop":{"$alias":{"path":["internal","__#2","cancelGeneration"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}}},"children":[]}]},"messages":{"$alias":{"path":["argument","messages"],"schema":{"type":"array","items":{"$ref":"#/$defs/BuiltInLLMMessage"},"default":[]},"rootSchema":{"type":"object","properties":{"messages":{"type":"array","items":{"$ref":"#/$defs/BuiltInLLMMessage"},"default":[]},"tools":true,"theme":true,"system":{"type":"string"}},"$defs":{"BuiltInLLMMessage":{"type":"object","properties":{"role":{"enum":["system","user","assistant","tool"]},"content":{"$ref":"#/$defs/BuiltInLLMContent"}},"required":["role","content"]},"BuiltInLLMContent":{"anyOf":[{"type":"string"},{"type":"array","items":{"$ref":"#/$defs/BuiltInLLMContentPart"}}]},"BuiltInLLMContentPart":{"anyOf":[{"$ref":"#/$defs/BuiltInLLMTextPart"},{"$ref":"#/$defs/BuiltInLLMImagePart"},{"$ref":"#/$defs/BuiltInLLMToolCallPart"},{"$ref":"#/$defs/BuiltInLLMToolResultPart"}]},"BuiltInLLMToolResultPart":{"type":"object","properties":{"type":{"type":"string","enum":["tool-result"]},"toolCallId":{"type":"string"},"toolName":{"type":"string"},"output":{"anyOf":[{"type":"object","properties":{"type":{"type":"string","enum":["text"]},"value":{"type":"string"}},"required":["type","value"]},{"type":"object","properties":{"type":{"type":"string","enum":["json"]},"value":true},"required":["type","value"]}]}},"required":["type","toolCallId","toolName","output"]},"BuiltInLLMToolCallPart":{"type":"object","properties":{"type":{"type":"string","enum":["tool-call"]},"toolCallId":{"type":"string"},"toolName":{"type":"string"},"input":{"type":"object","properties":{},"additionalProperties":true}},"required":["type","toolCallId","toolName","input"]},"BuiltInLLMImagePart":{"type":"object","properties":{"type":{"type":"string","enum":["image"]},"image":{"anyOf":[{"type":"string"},true,{"type":"string","format":"uri"},true]}},"required":["type","image"]},"BuiltInLLMTextPart":{"type":"object","properties":{"type":{"type":"string","enum":["text"]},"text":{"type":"string"}},"required":["type","text"]}}},"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"pending":{"$alias":{"path":["internal","__#2","pending"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"addMessage":{"$alias":{"path":["internal","__#2","addMessage"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"clearChat":{"$alias":{"path":["internal","clearChat"],"schema":false,"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"cancelGeneration":{"$alias":{"path":["internal","__#2","cancelGeneration"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"title":{"$alias":{"path":["internal","$NAME"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"pinnedCells":{"$alias":{"path":["internal","__#2","pinnedCells"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"tools":{"$alias":{"path":["internal","__#2","flattenedTools"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"ui":{"chatLog":{"type":"vnode","name":"ct-vscroll","props":{"style":"padding: 1rem;","flex":true,"showScrollbar":true,"fadeEdges":true,"snapToBottom":true},"children":[{"type":"vnode","name":"ct-chat","props":{"theme":{"$alias":{"path":["argument","theme"],"schema":{},"rootSchema":{"type":"object","properties":{"messages":{"type":"array","items":{"$ref":"#/$defs/BuiltInLLMMessage"},"default":[]},"tools":true,"theme":true,"system":{"type":"string"}},"$defs":{"BuiltInLLMMessage":{"type":"object","properties":{"role":{"enum":["system","user","assistant","tool"]},"content":{"$ref":"#/$defs/BuiltInLLMContent"}},"required":["role","content"]},"BuiltInLLMContent":{"anyOf":[{"type":"string"},{"type":"array","items":{"$ref":"#/$defs/BuiltInLLMContentPart"}}]},"BuiltInLLMContentPart":{"anyOf":[{"$ref":"#/$defs/BuiltInLLMTextPart"},{"$ref":"#/$defs/BuiltInLLMImagePart"},{"$ref":"#/$defs/BuiltInLLMToolCallPart"},{"$ref":"#/$defs/BuiltInLLMToolResultPart"}]},"BuiltInLLMToolResultPart":{"type":"object","properties":{"type":{"type":"string","enum":["tool-result"]},"toolCallId":{"type":"string"},"toolName":{"type":"string"},"output":{"anyOf":[{"type":"object","properties":{"type":{"type":"string","enum":["text"]},"value":{"type":"string"}},"required":["type","value"]},{"type":"object","properties":{"type":{"type":"string","enum":["json"]},"value":true},"required":["type","value"]}]}},"required":["type","toolCallId","toolName","output"]},"BuiltInLLMToolCallPart":{"type":"object","properties":{"type":{"type":"string","enum":["tool-call"]},"toolCallId":{"type":"string"},"toolName":{"type":"string"},"input":{"type":"object","properties":{},"additionalProperties":true}},"required":["type","toolCallId","toolName","input"]},"BuiltInLLMImagePart":{"type":"object","properties":{"type":{"type":"string","enum":["image"]},"image":{"anyOf":[{"type":"string"},true,{"type":"string","format":"uri"},true]}},"required":["type","image"]},"BuiltInLLMTextPart":{"type":"object","properties":{"type":{"type":"string","enum":["text"]},"text":{"type":"string"}},"required":["type","text"]}}},"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"$messages":{"$alias":{"path":["argument","messages"],"schema":{"type":"array","items":{"$ref":"#/$defs/BuiltInLLMMessage"},"default":[]},"rootSchema":{"type":"object","properties":{"messages":{"type":"array","items":{"$ref":"#/$defs/BuiltInLLMMessage"},"default":[]},"tools":true,"theme":true,"system":{"type":"string"}},"$defs":{"BuiltInLLMMessage":{"type":"object","properties":{"role":{"enum":["system","user","assistant","tool"]},"content":{"$ref":"#/$defs/BuiltInLLMContent"}},"required":["role","content"]},"BuiltInLLMContent":{"anyOf":[{"type":"string"},{"type":"array","items":{"$ref":"#/$defs/BuiltInLLMContentPart"}}]},"BuiltInLLMContentPart":{"anyOf":[{"$ref":"#/$defs/BuiltInLLMTextPart"},{"$ref":"#/$defs/BuiltInLLMImagePart"},{"$ref":"#/$defs/BuiltInLLMToolCallPart"},{"$ref":"#/$defs/BuiltInLLMToolResultPart"}]},"BuiltInLLMToolResultPart":{"type":"object","properties":{"type":{"type":"string","enum":["tool-result"]},"toolCallId":{"type":"string"},"toolName":{"type":"string"},"output":{"anyOf":[{"type":"object","properties":{"type":{"type":"string","enum":["text"]},"value":{"type":"string"}},"required":["type","value"]},{"type":"object","properties":{"type":{"type":"string","enum":["json"]},"value":true},"required":["type","value"]}]}},"required":["type","toolCallId","toolName","output"]},"BuiltInLLMToolCallPart":{"type":"object","properties":{"type":{"type":"string","enum":["tool-call"]},"toolCallId":{"type":"string"},"toolName":{"type":"string"},"input":{"type":"object","properties":{},"additionalProperties":true}},"required":["type","toolCallId","toolName","input"]},"BuiltInLLMImagePart":{"type":"object","properties":{"type":{"type":"string","enum":["image"]},"image":{"anyOf":[{"type":"string"},true,{"type":"string","format":"uri"},true]}},"required":["type","image"]},"BuiltInLLMTextPart":{"type":"object","properties":{"type":{"type":"string","enum":["text"]},"text":{"type":"string"}},"required":["type","text"]}}},"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"pending":{"$alias":{"path":["internal","__#2","pending"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"tools":{"$alias":{"path":["internal","__#2","flattenedTools"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}}},"children":[]}]},"promptInput":{"type":"vnode","name":"ct-prompt-input","props":{"slot":"footer","placeholder":"Ask the LLM a question...","pending":{"$alias":{"path":["internal","__#2","pending"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"$mentionable":{"$alias":{"path":["internal","__#10"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"modelItems":{"$alias":{"path":["internal","__#11"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"$model":{"$alias":{"path":["internal","__#1"],"schema":{"type":"string","default":"anthropic:claude-sonnet-4-5"},"rootSchema":{"type":"string","default":"anthropic:claude-sonnet-4-5"},"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"onct-send":{"$alias":{"path":["internal","__#3stream"],"schema":{"type":"object","properties":{"detail":{"type":"object","properties":{"text":{"type":"string"},"attachments":{"type":"array","items":{"$ref":"#/$defs/PromptAttachment"}},"mentions":{"type":"array","items":true},"message":{"type":"string"}},"required":["text","attachments","mentions","message"]}},"required":["detail"],"$defs":{"PromptAttachment":{"type":"object","properties":{"id":{"type":"string"},"name":{"type":"string"},"type":{"enum":["file","clipboard","mention"]},"data":true,"charm":true,"removable":{"type":"boolean"}},"required":["id","name","type"]}}},"rootSchema":{"type":"object","properties":{"detail":{"type":"object","properties":{"text":{"type":"string"},"attachments":{"type":"array","items":{"$ref":"#/$defs/PromptAttachment"}},"mentions":{"type":"array","items":true},"message":{"type":"string"}},"required":["text","attachments","mentions","message"]}},"required":["detail"],"$defs":{"PromptAttachment":{"type":"object","properties":{"id":{"type":"string"},"name":{"type":"string"},"type":{"enum":["file","clipboard","mention"]},"data":true,"charm":true,"removable":{"type":"boolean"}},"required":["id","name","type"]}}},"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"onct-stop":{"$alias":{"path":["internal","__#2","cancelGeneration"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}}},"children":[]},"attachmentsAndTools":{"type":"vnode","name":"ct-hstack","props":{"align":"center","gap":"1"},"children":[{"type":"vnode","name":"ct-cell-context","props":{"$cell":{"$alias":{"path":["internal","__#2","pinnedCells"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}}},"children":[{"type":"vnode","name":"ct-attachments-bar","props":{"pinnedCells":{"$alias":{"path":["internal","__#2","pinnedCells"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}}},"children":[]}]},{"type":"vnode","name":"ct-tools-chip","props":{"tools":{"$alias":{"path":["internal","__#2","flattenedTools"],"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}}},"children":[]},{"type":"vnode","name":"ct-button","props":{"variant":"pill","type":"button","title":"Clear chat","onClick":{"$alias":{"path":["internal","__#4stream"],"schema":false,"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}}},"children":["Clear"]}]}}}}}}},"of:baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu":{"application/json":{"ba4jcah6vb2kcbaezniq5c3vgjwdxwgnu6mo7vnfliwndz7jrtlbtbkmo":{"is":{"value":{"$TYPE":"ba4jcau46w7evsb4pb5lwv2bvsq4tckgi2grr4rqpph6g6actgrcdgtuy","resultRef":{"/":{"link@1":{"path":[],"id":"of:baedreifr3l6ptjg4p5yoxmogt6zmb4xsd32gt5gxz455de24wlheldsuii","schema":{"type":"object","properties":{"messages":{"type":"array","items":{"$ref":"#/$defs/BuiltInLLMMessage"}},"pending":{"type":"boolean"},"addMessage":{"$ref":"#/$defs/BuiltInLLMMessage"},"clearChat":{},"cancelGeneration":{},"title":{"type":"string"},"pinnedCells":{"type":"array","items":{"$ref":"#/$defs/PromptAttachment"}},"tools":true,"ui":{"type":"object","properties":{"chatLog":{"$ref":"#/$defs/VNode"},"promptInput":{"$ref":"#/$defs/VNode"},"attachmentsAndTools":{"$ref":"#/$defs/VNode"}},"required":["chatLog","promptInput","attachmentsAndTools"]}},"required":["messages","addMessage","clearChat","cancelGeneration","pinnedCells","tools","ui"],"$defs":{"VNode":{"type":"object","properties":{"type":{"type":"string","enum":["vnode"]},"name":{"type":"string"},"props":{"$ref":"#/$defs/Props"},"children":{"$ref":"#/$defs/RenderNode"},"$UI":{"$ref":"#/$defs/VNode"}},"required":["type","name","props"]},"RenderNode":{"anyOf":[{"type":"string"},{"type":"number"},{"type":"boolean","enum":[false]},{"type":"boolean","enum":[true]},{"$ref":"#/$defs/VNode"},{"type":"object","properties":{}},{"type":"array","items":{"$ref":"#/$defs/RenderNode"}}]},"Props":{"type":"object","properties":{},"additionalProperties":{"anyOf":[{"type":"string"},{"type":"number"},{"type":"boolean","enum":[false]},{"type":"boolean","enum":[true]},{"type":"object","additionalProperties":true},{"type":"array","items":true},{},{},{"type":"null"}]}},"PromptAttachment":{"type":"object","properties":{"id":{"type":"string"},"name":{"type":"string"},"type":{"enum":["file","clipboard","mention"]},"data":true,"charm":true,"removable":{"type":"boolean"}},"required":["id","name","type"]},"BuiltInLLMMessage":{"type":"object","properties":{"role":{"enum":["system","user","assistant","tool"]},"content":{"$ref":"#/$defs/BuiltInLLMContent"}},"required":["role","content"]},"BuiltInLLMContent":{"anyOf":[{"type":"string"},{"type":"array","items":{"$ref":"#/$defs/BuiltInLLMContentPart"}}]},"BuiltInLLMContentPart":{"anyOf":[{"$ref":"#/$defs/BuiltInLLMTextPart"},{"$ref":"#/$defs/BuiltInLLMImagePart"},{"$ref":"#/$defs/BuiltInLLMToolCallPart"},{"$ref":"#/$defs/BuiltInLLMToolResultPart"}]},"BuiltInLLMToolResultPart":{"type":"object","properties":{"type":{"type":"string","enum":["tool-result"]},"toolCallId":{"type":"string"},"toolName":{"type":"string"},"output":{"anyOf":[{"type":"object","properties":{"type":{"type":"string","enum":["text"]},"value":{"type":"string"}},"required":["type","value"]},{"type":"object","properties":{"type":{"type":"string","enum":["json"]},"value":true},"required":["type","value"]}]}},"required":["type","toolCallId","toolName","output"]},"BuiltInLLMToolCallPart":{"type":"object","properties":{"type":{"type":"string","enum":["tool-call"]},"toolCallId":{"type":"string"},"toolName":{"type":"string"},"input":{"type":"object","properties":{},"additionalProperties":true}},"required":["type","toolCallId","toolName","input"]},"BuiltInLLMImagePart":{"type":"object","properties":{"type":{"type":"string","enum":["image"]},"image":{"anyOf":[{"type":"string"},true,{"type":"string","format":"uri"},true]}},"required":["type","image"]},"BuiltInLLMTextPart":{"type":"object","properties":{"type":{"type":"string","enum":["text"]},"text":{"type":"string"}},"required":["type","text"]}}},"rootSchema":{"type":"object","properties":{"messages":{"type":"array","items":{"$ref":"#/$defs/BuiltInLLMMessage"}},"pending":{"type":"boolean"},"addMessage":{"$ref":"#/$defs/BuiltInLLMMessage"},"clearChat":{},"cancelGeneration":{},"title":{"type":"string"},"pinnedCells":{"type":"array","items":{"$ref":"#/$defs/PromptAttachment"}},"tools":true,"ui":{"type":"object","properties":{"chatLog":{"$ref":"#/$defs/VNode"},"promptInput":{"$ref":"#/$defs/VNode"},"attachmentsAndTools":{"$ref":"#/$defs/VNode"}},"required":["chatLog","promptInput","attachmentsAndTools"]}},"required":["messages","addMessage","clearChat","cancelGeneration","pinnedCells","tools","ui"],"$defs":{"VNode":{"type":"object","properties":{"type":{"type":"string","enum":["vnode"]},"name":{"type":"string"},"props":{"$ref":"#/$defs/Props"},"children":{"$ref":"#/$defs/RenderNode"},"$UI":{"$ref":"#/$defs/VNode"}},"required":["type","name","props"]},"RenderNode":{"anyOf":[{"type":"string"},{"type":"number"},{"type":"boolean","enum":[false]},{"type":"boolean","enum":[true]},{"$ref":"#/$defs/VNode"},{"type":"object","properties":{}},{"type":"array","items":{"$ref":"#/$defs/RenderNode"}}]},"Props":{"type":"object","properties":{},"additionalProperties":{"anyOf":[{"type":"string"},{"type":"number"},{"type":"boolean","enum":[false]},{"type":"boolean","enum":[true]},{"type":"object","additionalProperties":true},{"type":"array","items":true},{},{},{"type":"null"}]}},"PromptAttachment":{"type":"object","properties":{"id":{"type":"string"},"name":{"type":"string"},"type":{"enum":["file","clipboard","mention"]},"data":true,"charm":true,"removable":{"type":"boolean"}},"required":["id","name","type"]},"BuiltInLLMMessage":{"type":"object","properties":{"role":{"enum":["system","user","assistant","tool"]},"content":{"$ref":"#/$defs/BuiltInLLMContent"}},"required":["role","content"]},"BuiltInLLMContent":{"anyOf":[{"type":"string"},{"type":"array","items":{"$ref":"#/$defs/BuiltInLLMContentPart"}}]},"BuiltInLLMContentPart":{"anyOf":[{"$ref":"#/$defs/BuiltInLLMTextPart"},{"$ref":"#/$defs/BuiltInLLMImagePart"},{"$ref":"#/$defs/BuiltInLLMToolCallPart"},{"$ref":"#/$defs/BuiltInLLMToolResultPart"}]},"BuiltInLLMToolResultPart":{"type":"object","properties":{"type":{"type":"string","enum":["tool-result"]},"toolCallId":{"type":"string"},"toolName":{"type":"string"},"output":{"anyOf":[{"type":"object","properties":{"type":{"type":"string","enum":["text"]},"value":{"type":"string"}},"required":["type","value"]},{"type":"object","properties":{"type":{"type":"string","enum":["json"]},"value":true},"required":["type","value"]}]}},"required":["type","toolCallId","toolName","output"]},"BuiltInLLMToolCallPart":{"type":"object","properties":{"type":{"type":"string","enum":["tool-call"]},"toolCallId":{"type":"string"},"toolName":{"type":"string"},"input":{"type":"object","properties":{},"additionalProperties":true}},"required":["type","toolCallId","toolName","input"]},"BuiltInLLMImagePart":{"type":"object","properties":{"type":{"type":"string","enum":["image"]},"image":{"anyOf":[{"type":"string"},true,{"type":"string","format":"uri"},true]}},"required":["type","image"]},"BuiltInLLMTextPart":{"type":"object","properties":{"type":{"type":"string","enum":["text"]},"text":{"type":"string"}},"required":["type","text"]}}}}}},"internal":{"__#1":"anthropic:claude-sonnet-4-5","clearChat":{"$stream":true},"__#3stream":{"$stream":true},"__#4stream":{"$stream":true},"$NAME":{"/":{"link@1":{"path":[],"id":"of:baedreihtfh3sodyny5tdxkhaw27blfyvapndgpj7lzqbochlp4bbdrmsgm"}}}},"spell":{"/":{"link@1":{"id":"of:baedreieyiogei24j2gp74jdnq7a2rfz3epxrpr2m7a3377pouo2b6irjrq"}}},"argument":{"system":"You are a polite but efficient assistant. Think Star Trek computer - helpful and professional without unnecessary conversation. Let your actions speak for themselves.\n\nTool usage priority:\n- For patterns: listPatternIndex first\n- For existing pages/notes/content: listRecent or listMentionable to identify what they're referencing\n- Attach relevant items to conversation after instantiation/retrieval if they support ongoing tasks\n- Remove attachments when no longer relevant\n- Search web only as last resort when nothing exists in the space\n\nBe matter-of-fact. Prefer action to explanation.","tools":{"searchWeb":{"pattern":{"argumentSchema":{"type":"object","properties":{"query":{"type":"string","description":"The query to search the web for."}},"required":["query"],"description":"Search the web for information."},"resultSchema":{"anyOf":[{"$ref":"#/$defs/SearchWebResult"},{"type":"object","properties":{"error":{"type":"string"}},"required":["error"]}],"$defs":{"SearchWebResult":{"type":"object","properties":{"results":{"type":"array","items":{"type":"object","properties":{"title":{"type":"string"},"url":{"type":"string"},"description":{"type":"string"}},"required":["title","url","description"]}}},"required":["results"]}}},"initial":{},"result":{"$alias":{"path":["internal","__#1"]}},"nodes":[{"module":{"type":"ref","implementation":"fetchData"},"inputs":{"url":"/api/agent-tools/web-search","mode":"json","options":{"method":"POST","headers":{"Content-Type":"application/json"},"body":{"query":{"$alias":{"path":["argument","query"],"schema":{"type":"string","description":"The query to search the web for."},"rootSchema":{"type":"object","properties":{"query":{"type":"string","description":"The query to search the web for."}},"required":["query"],"description":"Search the web for information."}}},"max_results":5}}},"outputs":{"$alias":{"path":["internal","__#0"]}}},{"module":{"type":"ref","implementation":"ifElse"},"inputs":{"condition":{"$alias":{"path":["internal","__#0","error"]}},"ifTrue":{"error":{"$alias":{"path":["internal","__#0","error"]}}},"ifFalse":{"$alias":{"path":["internal","__#0","result"]}}},"outputs":{"$alias":{"path":["internal","__#1"]}}}]}},"readWebpage":{"pattern":{"argumentSchema":{"type":"object","properties":{"url":{"type":"string","description":"The URL of the webpage to read and extract content from."}},"required":["url"],"description":"Read and extract content from a specific webpage URL."},"resultSchema":{"anyOf":[{"$ref":"#/$defs/ReadWebResult"},{"type":"object","properties":{"error":{"type":"string"}},"required":["error"]}],"$defs":{"ReadWebResult":{"type":"object","properties":{"content":{"type":"string"},"metadata":{"type":"object","properties":{"title":{"type":"string"},"author":{"type":"string"},"date":{"type":"string"},"word_count":{"type":"number"}},"required":["word_count"]}},"required":["content","metadata"]}}},"initial":{},"result":{"$alias":{"path":["internal","__#1"]}},"nodes":[{"module":{"type":"ref","implementation":"fetchData"},"inputs":{"url":"/api/agent-tools/web-read","mode":"json","options":{"method":"POST","headers":{"Content-Type":"application/json"},"body":{"url":{"$alias":{"path":["argument","url"],"schema":{"type":"string","description":"The URL of the webpage to read and extract content from."},"rootSchema":{"type":"object","properties":{"url":{"type":"string","description":"The URL of the webpage to read and extract content from."}},"required":["url"],"description":"Read and extract content from a specific webpage URL."}}},"max_tokens":4000,"include_code":true}}},"outputs":{"$alias":{"path":["internal","__#0"]}}},{"module":{"type":"ref","implementation":"ifElse"},"inputs":{"condition":{"$alias":{"path":["internal","__#0","error"]}},"ifTrue":{"error":{"$alias":{"path":["internal","__#0","error"]}}},"ifFalse":{"$alias":{"path":["internal","__#0","result"]}}},"outputs":{"$alias":{"path":["internal","__#1"]}}}]}},"calculator":{"pattern":{"argumentSchema":{"type":"object","properties":{"expression":{"type":"string","description":"The mathematical expression to evaluate."},"base":{"type":"number","description":"The base to use for the calculation."}},"required":["expression"],"description":"Calculate the result of a mathematical expression.\nSupports +, -, *, /, and parentheses."},"resultSchema":{"anyOf":[{"type":"string"},{"type":"object","properties":{"error":{"type":"string"}},"required":["error"]}]},"initial":{},"result":{"$alias":{"path":["internal","__#0"]}},"nodes":[{"module":{"type":"javascript","implementation":"({ expression, base }) => {\n const sanitized = expression.replace(/[^0-9+\\-*/().\\s]/g, \"\");\n let sanitizedBase = Number(base);\n if (Number.isNaN(sanitizedBase) || sanitizedBase < 2 || sanitizedBase > 36) {\n sanitizedBase = 10;\n }\n let result;\n try {\n result = Function(`\"use strict\"; return Number(${sanitized}).toString(${sanitizedBase})`)();\n }\n catch (error) {\n result = { error: error?.message || \"<error>\" };\n }\n return result;\n }","argumentSchema":{"type":"object","properties":{"expression":{"type":"string","asOpaque":true},"base":{"type":"number","asOpaque":true}},"required":["expression","base"]},"resultSchema":true},"inputs":{"expression":{"$alias":{"path":["argument","expression"],"schema":{"type":"string","description":"The mathematical expression to evaluate."},"rootSchema":{"type":"object","properties":{"expression":{"type":"string","description":"The mathematical expression to evaluate."},"base":{"type":"number","description":"The base to use for the calculation."}},"required":["expression"],"description":"Calculate the result of a mathematical expression.\nSupports +, -, *, /, and parentheses."}}},"base":{"$alias":{"path":["argument","base"],"schema":{"type":"number","description":"The base to use for the calculation."},"rootSchema":{"type":"object","properties":{"expression":{"type":"string","description":"The mathematical expression to evaluate."},"base":{"type":"number","description":"The base to use for the calculation."}},"required":["expression"],"description":"Calculate the result of a mathematical expression.\nSupports +, -, *, /, and parentheses."}}}},"outputs":{"$alias":{"path":["internal","__#0"]}}}]}},"fetchAndRunPattern":{"pattern":{"argumentSchema":{"type":"object","properties":{"url":{"type":"string"},"args":{}},"required":["url","args"],"description":"`fetchAndRunPattern({ url: \"https://...\", args: {} })`\n\nInstantiates patterns (e.g. from listPatternIndex) and returns the cell that\ncontains the results. The instantiated pattern will keep running and updating\nthe cell. Pass the resulting cell to `navigateTo` to show the pattern's UI.\n\nPass in arguments to initialize the pattern. It's especially useful to pass\nin links to other cells as `{ \"@link\": \"/of:bafe.../path/to/data\" }`."},"resultSchema":{"type":"object","properties":{"cell":true,"error":true},"required":["cell","error"],"asOpaque":true},"initial":{},"result":{"$alias":{"path":["internal","__#4"]}},"nodes":[{"module":{"type":"ref","implementation":"fetchProgram"},"inputs":{"url":{"$alias":{"path":["argument","url"],"schema":{"type":"string"},"rootSchema":{"type":"object","properties":{"url":{"type":"string"},"args":{}},"required":["url","args"],"description":"`fetchAndRunPattern({ url: \"https://...\", args: {} })`\n\nInstantiates patterns (e.g. from listPatternIndex) and returns the cell that\ncontains the results. The instantiated pattern will keep running and updating\nthe cell. Pass the resulting cell to `navigateTo` to show the pattern's UI.\n\nPass in arguments to initialize the pattern. It's especially useful to pass\nin links to other cells as `{ \"@link\": \"/of:bafe.../path/to/data\" }`."}}}},"outputs":{"$alias":{"path":["internal","__#0"]}}},{"module":{"type":"javascript","implementation":"({ program: p, args }) => ({\n files: p?.files ?? [],\n main: p?.main ?? \"\",\n input: args,\n })","argumentSchema":{"type":"object","properties":{"program":{"type":"object","properties":{"files":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"contents":{"type":"string"}},"required":["name","contents"]}},"main":{"type":"string"}},"required":["files","main"],"asOpaque":true},"args":{"asCell":true}},"required":["program","args"]},"resultSchema":{"type":"object","properties":{"files":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"contents":{"type":"string"}},"required":["name","contents"]}},"main":{"type":"string"},"input":{"asCell":true}},"required":["files","main","input"]}},"inputs":{"program":{"$alias":{"path":["internal","__#0","result"]}},"args":{"$alias":{"path":["argument","args"],"schema":{},"rootSchema":{"type":"object","properties":{"url":{"type":"string"},"args":{}},"required":["url","args"],"description":"`fetchAndRunPattern({ url: \"https://...\", args: {} })`\n\nInstantiates patterns (e.g. from listPatternIndex) and returns the cell that\ncontains the results. The instantiated pattern will keep running and updating\nthe cell. Pass the resulting cell to `navigateTo` to show the pattern's UI.\n\nPass in arguments to initialize the pattern. It's especially useful to pass\nin links to other cells as `{ \"@link\": \"/of:bafe.../path/to/data\" }`."}}}},"outputs":{"$alias":{"path":["internal","__#1"]}}},{"module":{"type":"ref","implementation":"compileAndRun"},"inputs":{"$alias":{"path":["internal","__#1"]}},"outputs":{"$alias":{"path":["internal","__#2"]}}},{"module":{"type":"javascript","implementation":"({ pending, result, error }) => pending || (!result && !error)","argumentSchema":{"type":"object","properties":{"pending":{"anyOf":[{"type":"boolean","enum":[false],"asOpaque":true},{"type":"boolean","enum":[true],"asOpaque":true}]},"result":true,"error":true},"required":["pending","result","error"]},"resultSchema":{"type":"boolean"}},"inputs":{"pending":{"$alias":{"path":["internal","__#2","pending"]}},"result":{"$alias":{"path":["internal","__#2","result"]}},"error":{"$alias":{"path":["internal","__#2","error"]}}},"outputs":{"$alias":{"path":["internal","__#3"]}}},{"module":{"type":"ref","implementation":"ifElse"},"inputs":{"condition":{"$alias":{"path":["internal","__#3"]}},"ifFalse":{"cell":{"$alias":{"path":["internal","__#2","result"]}},"error":{"$alias":{"path":["internal","__#2","error"]}}}},"outputs":{"$alias":{"path":["internal","__#4"]}}}]},"extraParams":{}},"listPatternIndex":{"pattern":{"argumentSchema":{"type":"object","properties":{},"additionalProperties":false,"description":"`listPatternIndex()` - Returns the index of patterns.\n\nUseful as input to fetchAndRun."},"resultSchema":{"type":"object","properties":{"result":{"$ref":"#/$defs/OpaqueCell"}},"required":["result"],"asOpaque":true,"$defs":{"OpaqueCell":{"asOpaque":true}}},"initial":{},"result":{"$alias":{"path":["internal","__#0"]}},"nodes":[{"module":{"type":"ref","implementation":"ifElse"},"inputs":{"condition":{"$alias":{"path":["internal","__#1"]}},"ifFalse":{"result":{"$alias":{"path":["internal","__#2","result"]}}}},"outputs":{"$alias":{"path":["internal","__#0"]}}},{"module":{"type":"javascript","implementation":"({ pending, result }) => pending || !result","argumentSchema":{"type":"object","properties":{"pending":{"anyOf":[{"type":"boolean","enum":[false],"asOpaque":true},{"type":"boolean","enum":[true],"asOpaque":true}]},"result":{"$ref":"#/$defs/OpaqueCell"}},"required":["pending","result"],"$defs":{"OpaqueCell":{"asOpaque":true}}},"resultSchema":{"anyOf":[{"type":"boolean","enum":[false]},{"type":"boolean","enum":[true],"asOpaque":true}]}},"inputs":{"pending":{"$alias":{"path":["internal","__#2","pending"]}},"result":{"$alias":{"path":["internal","__#2","result"]}}},"outputs":{"$alias":{"path":["internal","__#1"]}}},{"module":{"type":"ref","implementation":"fetchData"},"inputs":{"url":"/api/patterns/index.md","mode":"text"},"outputs":{"$alias":{"path":["internal","__#2"]}}}]},"extraParams":{}},"navigateTo":{"pattern":{"argumentSchema":{"type":"object","properties":{"cell":{}},"required":["cell"],"description":"`navigateTo({ cell: { \"@link\": \"/of:xyz\" } })` - Navigates to that cell's UI\n\nEspecially useful after instantiating a pattern with fetchAndRunPattern:\nPass the \"@link\" you get at `cell` to navigate to the pattern's view."},"resultSchema":{"type":"object","properties":{"success":{"anyOf":[{"type":"boolean","enum":[false],"asOpaque":true},{"type":"boolean","enum":[true],"asOpaque":true}]}},"required":["success"],"asOpaque":true},"initial":{},"result":{"$alias":{"path":["internal","__#1"]}},"nodes":[{"module":{"type":"ref","implementation":"navigateTo"},"inputs":{"$alias":{"path":["argument","cell"],"schema":{},"rootSchema":{"type":"object","properties":{"cell":{}},"required":["cell"],"description":"`navigateTo({ cell: { \"@link\": \"/of:xyz\" } })` - Navigates to that cell's UI\n\nEspecially useful after instantiating a pattern with fetchAndRunPattern:\nPass the \"@link\" you get at `cell` to navigate to the pattern's view."}}},"outputs":{"$alias":{"path":["internal","__#0"]}}},{"module":{"type":"ref","implementation":"ifElse"},"inputs":{"condition":{"$alias":{"path":["internal","__#0"]}},"ifTrue":{"success":{"$alias":{"path":["internal","__#0"]}}}},"outputs":{"$alias":{"path":["internal","__#1"]}}}]},"extraParams":{}}},"messages":[]}}}}}},"of:baedreihtfh3sodyny5tdxkhaw27blfyvapndgpj7lzqbochlp4bbdrmsgm":{"application/json":{"ba4jcaiyycvtxoxdxgx23j7rcwnuw3d3hmxkxuim3zjsn3zzq7mixd5j5":{"is":{"source":{"/":"baedreibdefuclgmo5yfw7nyufgt6hj4jwqdbdh5kooahygofse4rrjmqiq"},"value":{"$alias":{"path":["internal","__#2"],"cell":{"/":"baedreibdefuclgmo5yfw7nyufgt6hj4jwqdbdh5kooahygofse4rrjmqiq"}}}}}}},"of:baedreibdefuclgmo5yfw7nyufgt6hj4jwqdbdh5kooahygofse4rrjmqiq":{"application/json":{"ba4jcbcttvk6go5dnr66wwgolcifxgescykvtsvy6qhu6vjcy4bxqxsrc":{"is":{"value":{"$TYPE":"ba4jcbvdr4rwr7kcj7zi2x5vus6pknr5qoy2fuxsvrpfiixdcvms4idvp","resultRef":{"/":{"link@1":{"path":[],"id":"of:baedreihtfh3sodyny5tdxkhaw27blfyvapndgpj7lzqbochlp4bbdrmsgm","schema":true,"rootSchema":true}}},"internal":{},"spell":{"/":{"link@1":{"id":"of:baedreiekywlhi6tvmqi2jrcfq4jp3ruua5wttrti2x6lpdwjkqgjvbtxxy"}}},"argument":{"model":{"$alias":{"path":["internal","__#1"],"schema":{"type":"string","default":"anthropic:claude-sonnet-4-5"},"rootSchema":{"type":"string","default":"anthropic:claude-sonnet-4-5"},"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}},"messages":{"$alias":{"path":["argument","messages"],"schema":{"type":"array","items":{"$ref":"#/$defs/BuiltInLLMMessage"},"default":[]},"rootSchema":{"type":"object","properties":{"messages":{"type":"array","items":{"$ref":"#/$defs/BuiltInLLMMessage"},"default":[]},"tools":true,"theme":true,"system":{"type":"string"}},"$defs":{"BuiltInLLMMessage":{"type":"object","properties":{"role":{"enum":["system","user","assistant","tool"]},"content":{"$ref":"#/$defs/BuiltInLLMContent"}},"required":["role","content"]},"BuiltInLLMContent":{"anyOf":[{"type":"string"},{"type":"array","items":{"$ref":"#/$defs/BuiltInLLMContentPart"}}]},"BuiltInLLMContentPart":{"anyOf":[{"$ref":"#/$defs/BuiltInLLMTextPart"},{"$ref":"#/$defs/BuiltInLLMImagePart"},{"$ref":"#/$defs/BuiltInLLMToolCallPart"},{"$ref":"#/$defs/BuiltInLLMToolResultPart"}]},"BuiltInLLMToolResultPart":{"type":"object","properties":{"type":{"type":"string","enum":["tool-result"]},"toolCallId":{"type":"string"},"toolName":{"type":"string"},"output":{"anyOf":[{"type":"object","properties":{"type":{"type":"string","enum":["text"]},"value":{"type":"string"}},"required":["type","value"]},{"type":"object","properties":{"type":{"type":"string","enum":["json"]},"value":true},"required":["type","value"]}]}},"required":["type","toolCallId","toolName","output"]},"BuiltInLLMToolCallPart":{"type":"object","properties":{"type":{"type":"string","enum":["tool-call"]},"toolCallId":{"type":"string"},"toolName":{"type":"string"},"input":{"type":"object","properties":{},"additionalProperties":true}},"required":["type","toolCallId","toolName","input"]},"BuiltInLLMImagePart":{"type":"object","properties":{"type":{"type":"string","enum":["image"]},"image":{"anyOf":[{"type":"string"},true,{"type":"string","format":"uri"},true]}},"required":["type","image"]},"BuiltInLLMTextPart":{"type":"object","properties":{"type":{"type":"string","enum":["text"]},"text":{"type":"string"}},"required":["type","text"]}}},"cell":{"/":"baedreieey7hb5nt3et7hw4eqpos4bhe4yosmsm7v5dlndaes3oulbbilwu"}}}}}}}}}}},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jca2z6sg6gaqtj3yt2wj42kjsimswgpqs6qi7pllfecotzcujn6r3c":{}},"signature":{"/":{"bytes":"11nN5/7K8g00zc9ey8wZ6rmKkmPcNsaWxUd5WVO3mHxzXHdTCW/Y6lz2MEU1LitT9oCrKEPE7RGRaIFopE3WCw"}}}}	57081	
16:19:04.880
{"invocation":{"cmd":"/memory/graph/query","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"selectSchema":{"of:baedreiew3r6xzertwztxn5gca4e7kpw4s6tkjpjhd4cqufpfabzaohr26u":{"application/json":{"_":{"path":[],"schemaContext":{"schema":{"type":"object","properties":{"mentionable":{"$ref":"#/$defs/AnonymousType_1"}},"required":["mentionable"],"$defs":{"AnonymousType_1":{"type":"array","items":{"$ref":"#/$defs/MentionableCharm"}},"MentionableCharm":{"type":"object","properties":{"mentioned":{"$ref":"#/$defs/AnonymousType_1"},"backlinks":{"$ref":"#/$defs/AnonymousType_1"},"$NAME":{"type":"string"}},"required":["mentioned","backlinks"]}}},"rootSchema":{"type":"object","properties":{"mentionable":{"$ref":"#/$defs/AnonymousType_1"}},"required":["mentionable"],"$defs":{"AnonymousType_1":{"type":"array","items":{"$ref":"#/$defs/MentionableCharm"}},"MentionableCharm":{"type":"object","properties":{"mentioned":{"$ref":"#/$defs/AnonymousType_1"},"backlinks":{"$ref":"#/$defs/AnonymousType_1"},"$NAME":{"type":"string"}},"required":["mentioned","backlinks"]}}}}}}}},"subscribe":true,"excludeSent":true},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcarkrzstx2654wvkh7tr7vo2lubmzbdarvdv7xuqwdzhgxv57y5s5":{}},"signature":{"/":{"bytes":"rBqDfhikvCfPNCm+xsEU1xkw1aDfNG6U2x8SwAWi8rN3kwMl229uXaI/EOE8nRavWZp9B8n57s7IuzFg6IaeAg"}}}}	1446	
16:19:04.880
{"invocation":{"cmd":"/memory/graph/query","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"selectSchema":{"of:baedreiezwqqfrasyiyojszbzjotpjyljq5varfcsq3q74muet4e6yclm5u":{"application/json":{"_":{"path":["$TYPE"],"schemaContext":{"schema":false,"rootSchema":false}}}}},"subscribe":true,"excludeSent":true},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jcbg5jalszjtcp7edrfwzcehrk6gmradc57x2ebm4zxthwdpuy7wre":{}},"signature":{"/":{"bytes":"RceLJC4tfD6B86JIlDCIs1yqSNCIrt8p66NDSnIw3b5nbOUXjVtg5MUAyZrPLHEO5V+6qEptEtQoXy+EKx4gBA"}}}}	651	
16:19:04.880
{"invocation":{"cmd":"/memory/graph/query","sub":"did:key:z6MkgoUZZ8Bjhdv1LVFdJq3MuiSfDBN4xDCkBAJgByqVwaQs","args":{"selectSchema":{"of:baedreic2gtm7aqfvbe66bymvqwvj7pirepldufg7qqu5y5iyjywyit6f4u":{"application/json":{"_":{"path":[],"schemaContext":{"schema":{"type":"object","properties":{"id":{"type":"string"},"src":{"type":"string"},"spec":{"type":"string"},"parents":{"type":"array","items":{"type":"string"}},"recipeName":{"type":"string"},"program":{"type":"object","properties":{"main":{"type":"string"},"mainExport":{"type":"string"},"files":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"contents":{"type":"string"}},"required":["name","contents"]}}},"required":["main","files"]}},"required":["id"]},"rootSchema":{"type":"object","properties":{"id":{"type":"string"},"src":{"type":"string"},"spec":{"type":"string"},"parents":{"type":"array","items":{"type":"string"}},"recipeName":{"type":"string"},"program":{"type":"object","properties":{"main":{"type":"string"},"mainExport":{"type":"string"},"files":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"contents":{"type":"string"}},"required":["name","contents"]}}},"required":["main","files"]}},"required":["id"]}}}}}},"subscribe":true,"excludeSent":true},"iss":"did:key:z6Mkj8sYdHQU1xgzy6hde3MgVwqP5E7NCEu4FF5ua9zopH7U","prf":[],"iat":1764721140,"exp":1764724740},"authorization":{"access":{"ba4jca7rm2nm7od66ipjrio2pbgo2upjf5o6g6ftroxhadf6rnvygboza":{}},"signature":{"/":{"bytes":"h2qhNHQpRaMdkUu3XSXirnESIQrhSk5kDfR+sFdpIc1KCNIe6lAKVyon7aaMbDpMcqn5Ba114SVVoai8F1gkCQ"}}}}	1602	
16:19:04.880
